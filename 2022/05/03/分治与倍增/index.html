
<!DOCTYPE html>
<html lang="default" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>分治与倍增 - MarkStiff Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="博客学习,
 Double pow(double x, double y)
 倍增算法：
倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂,"> 
    <meta name="author" content="MarkStiff"> 
    <link rel="alternative" href="atom.xml" title="MarkStiff Blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="分治与倍增 - MarkStiff Blog"/>
    <meta name="twitter:description" content="博客学习,
 Double pow(double x, double y)
 倍增算法：
倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂,"/>
    
    
    
    
    <meta property="og:site_name" content="MarkStiff Blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="分治与倍增 - MarkStiff Blog"/>
    <meta property="og:description" content="博客学习,
 Double pow(double x, double y)
 倍增算法：
倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">MarkStiff Blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://Markstiff.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">分治与倍增</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">分治与倍增</h1>
        <div class="stuff">
            <span>五月 03, 2022</span>
            

        </div>
        <div class="content markdown">
            <hr />
<h4 id="double-powdouble-x-double-y"><a class="markdownIt-Anchor" href="#double-powdouble-x-double-y"></a> <code>Double pow(double x, double y)</code></h4>
<h4 id="倍增算法"><a class="markdownIt-Anchor" href="#倍增算法"></a> 倍增算法：</h4>
<p>倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂度的要求 ,那么我们就可以通过成倍的增长,只递推状态空间中在 2 的整数次幂位置上的值作为代表 。当需要其他位置上的值时,我们只需要通过&quot; 任意整数可以表示成若干个2的次幂项的和 &quot; 这一性质<code>(13 = 2^3 + 2^2 +2^0)</code>, 使用之前求出的代表值拼成所需的值。<br />
核心思想：不断以2的次幂的跨度向前试探，行进跨度，不行就降幂，迭代可以表示任意整数</p>
<h4 id="倍增主要应用"><a class="markdownIt-Anchor" href="#倍增主要应用"></a> 倍增主要应用：</h4>
<p><code>LCA(least common ancestors)</code>:最近公共祖先<br />
在有根树中，找出某两个结点u和v最近的公共祖先。<br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929170840386-1257726897.png" alt="" /><br />
在寻找两个节点的公共祖先时，按2的指数来跳，并且从大到小，……32, 16, 8 , 4 , 2, 1 【从大到小试探】</p>
<h4 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理：</h4>
<p>处理结点的深度、父节点、以及2i级的祖先<br />
<strong>开辟数组：</strong></p>
<pre><code>	&lt;1&gt;  depth数组是记录每个节点的深度
	&lt;2&gt;  fa[i][j]是指节点 i 的 2j 级的祖先的编号
	&lt;3&gt; lg数组是常数优化的数组，存的是log2N+1的值，注意用的时候要-1，开始之前先初始化一下，这样直接调用可以优化节约时间其中初始化的方法：l g [ i ] = l g [ i − 1 ] + ( 1 &lt; &lt; l g [ i − 1 ] = = i ) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i)lg[i]=lg[i−1]+(1&lt;&lt;lg[i−1]==i)，自己手算一下很清楚的（lg[1~10]为1 2 2 3 3 3 3 4 4 4，应该很好懂吧）
</code></pre>
<p><strong>手写对数运算lg2[i]:</strong></p>
<pre><code>	over(i,1,n)//预处理一下 
	lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;

	#include&lt;iostream&gt;
	#include&lt;stdio.h&gt;
	#include&lt;string.h&gt;
	#include&lt;algorithm&gt;
	#include&lt;queue&gt;
	#include&lt;math.h&gt;
	//可以学习宏定义简便写法
	#define ls (p&lt;&lt;1)  //取半
	#define rs (p&lt;&lt;1|1)   //取半加一
	#define mid (l+r)/2
	#define over(i,s,t) for(register long long i=s;i&lt;=t;++i)   //循环的简写 
	#define lver(i,t,s) for(register long long i=t;i&gt;=s;--i)
	
	using namespace std;
	typedef long long ll;//全用ll可能会MLE或者直接WA,试着改成int看会不会A
	const ll N=500007;
	const ll INF=1e9+9;
	const ll mod=2147483647;
	const double EPS=1e-10;//-10次方约等于趋近为0
	const double Pi=3.1415926535897;
	ll n,m;
	//前向星写法的数据结构实现：
	struct node
	&#123;
	    ll u,v,nex;
	&#125;e[N&lt;&lt;1];
	ll head[N],cnt;
	
	void add(ll u,ll v)
	&#123;
	    e[++cnt].v=v;    //记录边的终点
	    e[cnt].u=u;//没什么用，还白占空间
	    e[cnt].nex=head[u];     //以u为起点的上一条边，往往更喜欢写做pre
	    head[u]=cnt;    //更新以u为起点的上一条边
	&#125;
	ll depth[N],fa[N][30],lg[N],s,x,y;
	
	/*dfs函数的作用就是更新该点的所有祖先的fa数组，并通过递归把
	该节点的所有的子节点和该节点一样去更新*/
	void dfs(ll now,ll fath)//子节点和父节点
	&#123;
	    fa[now][0]=fath;//更新一下fa数组，2^0=1就是父节点
	    depth[now]=depth[fath]+1;//更新深度，递归的思想
	    over(i,1,lg[depth[now]]-1)
	        fa[now][i]=fa[fa[now][i-1]][i-1];
	        /*更新now的所有 2^i 级的祖先。先找到now的2^(i-1)级祖先，再往上找
	        该祖先的2^(i-1)级祖先，就是now的2^i祖先，必须一节一节地往上搜*/
	    for(ll i=head[now];i;i=e[i].nex)//链式前向星遍历
	        //如果now有子节点的话，就递归往子节点的子节点走（禁止套娃）
	        ll v = e[i].v;
	        if(v == fath) continue;
		dfs(e[i].v,now);
	&#125;

	inline ll LCA(ll x,ll y)
	&#123;
	    if(depth[x]&lt;depth[y])//用数学语言就是说不妨设x的深度比y的深度大
	        swap(x,y);//这样下面只需要写一种代码就好了
	    while(depth[x]&gt;depth[y])
	        //让x跳到y的高度（同一高度）
	        x=fa[x][lg[depth[x]-depth[y]]-1];
	    //如果跳到一块了那LCA肯定就是y了
	    if(x==y)
	        return x;
	    for(ll k=lg[depth[x]]-1;k&gt;=0;--k)//倒着从大到小地跳
	        /*因为我们要求跳到x和y的LCA的下一层，所以没有跳到的时候就
	        让x和y利用dfs里早就用倍增算法处理过的祖先路径快速地一块往上跳*/
	        if(fa[x][k]!=fa[y][k])
	            x=fa[x][k],y=fa[y][k];//往上跳
	    return fa[x][0];//返回x，y的父节点（肯定是相同的嘛）
	&#125;
	int main()
	&#123;
	    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;s);
	    over(i,1,n-1)
	    &#123;
	        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
	        add(x,y),add(y,x);//无向图一定要记得建双向边
	    &#125;
	    over(i,1,n)//预处理一下
	    lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;
	    dfs(s,0);//从树根开始，因为用的是链式前向星所以给一个假想根0（其实就是到这儿停）
	    //dfs一下，预处理各点的深度和祖先
	    over(i,1,m)
	    &#123;

	        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
	        printf(&quot;%lld\n&quot;,LCA(x,y));
	    &#125;
	    return 0;
	&#125;
</code></pre>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#double-powdouble-x-double-y"><span class="toc-number">1.</span> <span class="toc-text"> Double pow(double x, double y)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 倍增算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text"> 倍增主要应用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 数据预处理：</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
