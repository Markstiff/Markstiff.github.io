<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>串</title>
    <url>/2022/09/28/%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="数据结构串"><a class="markdownIt-Anchor" href="#数据结构串"></a> 数据结构——串</h2>
<p>(字符串实现与操作）</p>
<pre><code>pass
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/03/27/test/</url>
    <content><![CDATA[<h2 id="我是用来测试的"><a class="markdownIt-Anchor" href="#我是用来测试的"></a> 我是用来测试的</h2>
<p>###———<em>当前时间 北京时间2022年3月27日 15:54:29</em></p>
]]></content>
  </entry>
  <entry>
    <title>数模C题</title>
    <url>/2022/05/13/%E6%95%B0%E6%A8%A1C%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数模c题总结"><a class="markdownIt-Anchor" href="#数模c题总结"></a> 数模C题总结</h2>
<h4 id="第一部分问题分析"><a class="markdownIt-Anchor" href="#第一部分问题分析"></a> 第一部分——问题分析</h4>
<p>拆分问题，将各个问题进行拆分，尤其是效果分析类的</p>
<h4 id="第一部分数据预处理"><a class="markdownIt-Anchor" href="#第一部分数据预处理"></a> 第一部分——数据预处理</h4>
<p><strong>数据探索性分析</strong></p>
<pre><code>箱型图======&gt;探究是否有偏好情况=======&gt;决定了之后问题解决是否要考虑材料种类差异
对数直方图、洛伦兹图======&gt;探究数据是否存在数量级差异以及数据的均衡程度
散点图======&gt;探究数据的分布情况
</code></pre>
<h4 id="第二部分评价类"><a class="markdownIt-Anchor" href="#第二部分评价类"></a> 第二部分——评价类</h4>
<p><strong>熵权法-TOPSIS</strong></p>
<pre><code>叙述:
熵权法通过计算指标的信息熵，根据其相对变化程度对系统的整体影响来决定权重，避免了
层次分析法等主观赋权法的弊端，获取权重的客观性较强。在得到权重后， 利用 TOPSIS
方法将它们综合， TOPSIS 法通过构建评价问题的正理想解和负理想解，计算每个方案到理
想方案的相对贴近度来对方案进行排序，最终求解出最优方案。
</code></pre>
<h4 id="第三部分横纵向分析"><a class="markdownIt-Anchor" href="#第三部分横纵向分析"></a> 第三部分——横纵向分析</h4>
<pre><code>模型构建分析时，直接显著点出横向角度和纵向角度（一般有时间）来分析
核密度曲线
季节性分解
机会约束叙述：
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>分治与倍增</title>
    <url>/2022/05/03/%E5%88%86%E6%B2%BB%E4%B8%8E%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<hr />
<h4 id="double-powdouble-x-double-y"><a class="markdownIt-Anchor" href="#double-powdouble-x-double-y"></a> <code>Double pow(double x, double y)</code></h4>
<h4 id="倍增算法"><a class="markdownIt-Anchor" href="#倍增算法"></a> 倍增算法：</h4>
<p>倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂度的要求 ,那么我们就可以通过成倍的增长,只递推状态空间中在 2 的整数次幂位置上的值作为代表 。当需要其他位置上的值时,我们只需要通过&quot; 任意整数可以表示成若干个2的次幂项的和 &quot; 这一性质<code>(13 = 2^3 + 2^2 +2^0)</code>, 使用之前求出的代表值拼成所需的值。<br />
核心思想：不断以2的次幂的跨度向前试探，行进跨度，不行就降幂，迭代可以表示任意整数</p>
<h4 id="倍增主要应用"><a class="markdownIt-Anchor" href="#倍增主要应用"></a> 倍增主要应用：</h4>
<p><code>LCA(least common ancestors)</code>:最近公共祖先<br />
在有根树中，找出某两个结点u和v最近的公共祖先。<br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929170840386-1257726897.png" alt="" /><br />
在寻找两个节点的公共祖先时，按2的指数来跳，并且从大到小，……32, 16, 8 , 4 , 2, 1 【从大到小试探】</p>
<h4 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理：</h4>
<p>处理结点的深度、父节点、以及2i级的祖先<br />
<strong>开辟数组：</strong></p>
<pre><code>	&lt;1&gt;  depth数组是记录每个节点的深度
	&lt;2&gt;  fa[i][j]是指节点 i 的 2j 级的祖先的编号
	&lt;3&gt; lg数组是常数优化的数组，存的是log2N+1的值，注意用的时候要-1，开始之前先初始化一下，这样直接调用可以优化节约时间其中初始化的方法：l g [ i ] = l g [ i − 1 ] + ( 1 &lt; &lt; l g [ i − 1 ] = = i ) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i)lg[i]=lg[i−1]+(1&lt;&lt;lg[i−1]==i)，自己手算一下很清楚的（lg[1~10]为1 2 2 3 3 3 3 4 4 4，应该很好懂吧）
</code></pre>
<p><strong>手写对数运算lg2[i]:</strong></p>
<pre><code>	over(i,1,n)//预处理一下 
	lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;

	#include&lt;iostream&gt;
	#include&lt;stdio.h&gt;
	#include&lt;string.h&gt;
	#include&lt;algorithm&gt;
	#include&lt;queue&gt;
	#include&lt;math.h&gt;
	//可以学习宏定义简便写法
	#define ls (p&lt;&lt;1)  //取半
	#define rs (p&lt;&lt;1|1)   //取半加一
	#define mid (l+r)/2
	#define over(i,s,t) for(register long long i=s;i&lt;=t;++i)   //循环的简写 
	#define lver(i,t,s) for(register long long i=t;i&gt;=s;--i)
	
	using namespace std;
	typedef long long ll;//全用ll可能会MLE或者直接WA,试着改成int看会不会A
	const ll N=500007;
	const ll INF=1e9+9;
	const ll mod=2147483647;
	const double EPS=1e-10;//-10次方约等于趋近为0
	const double Pi=3.1415926535897;
	ll n,m;
	//前向星写法的数据结构实现：
	struct node
	&#123;
	    ll u,v,nex;
	&#125;e[N&lt;&lt;1];
	ll head[N],cnt;
	
	void add(ll u,ll v)
	&#123;
	    e[++cnt].v=v;    //记录边的终点
	    e[cnt].u=u;//没什么用，还白占空间
	    e[cnt].nex=head[u];     //以u为起点的上一条边，往往更喜欢写做pre
	    head[u]=cnt;    //更新以u为起点的上一条边
	&#125;
	ll depth[N],fa[N][30],lg[N],s,x,y;
	
	/*dfs函数的作用就是更新该点的所有祖先的fa数组，并通过递归把
	该节点的所有的子节点和该节点一样去更新*/
	void dfs(ll now,ll fath)//子节点和父节点
	&#123;
	    fa[now][0]=fath;//更新一下fa数组，2^0=1就是父节点
	    depth[now]=depth[fath]+1;//更新深度，递归的思想
	    over(i,1,lg[depth[now]]-1)
	        fa[now][i]=fa[fa[now][i-1]][i-1];
	        /*更新now的所有 2^i 级的祖先。先找到now的2^(i-1)级祖先，再往上找
	        该祖先的2^(i-1)级祖先，就是now的2^i祖先，必须一节一节地往上搜*/
	    for(ll i=head[now];i;i=e[i].nex)//链式前向星遍历
	        //如果now有子节点的话，就递归往子节点的子节点走（禁止套娃）
	        ll v = e[i].v;
	        if(v == fath) continue;
		dfs(e[i].v,now);
	&#125;

	inline ll LCA(ll x,ll y)
	&#123;
	    if(depth[x]&lt;depth[y])//用数学语言就是说不妨设x的深度比y的深度大
	        swap(x,y);//这样下面只需要写一种代码就好了
	    while(depth[x]&gt;depth[y])
	        //让x跳到y的高度（同一高度）
	        x=fa[x][lg[depth[x]-depth[y]]-1];
	    //如果跳到一块了那LCA肯定就是y了
	    if(x==y)
	        return x;
	    for(ll k=lg[depth[x]]-1;k&gt;=0;--k)//倒着从大到小地跳
	        /*因为我们要求跳到x和y的LCA的下一层，所以没有跳到的时候就
	        让x和y利用dfs里早就用倍增算法处理过的祖先路径快速地一块往上跳*/
	        if(fa[x][k]!=fa[y][k])
	            x=fa[x][k],y=fa[y][k];//往上跳
	    return fa[x][0];//返回x，y的父节点（肯定是相同的嘛）
	&#125;
	int main()
	&#123;
	    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;s);
	    over(i,1,n-1)
	    &#123;
	        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
	        add(x,y),add(y,x);//无向图一定要记得建双向边
	    &#125;
	    over(i,1,n)//预处理一下
	    lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;
	    dfs(s,0);//从树根开始，因为用的是链式前向星所以给一个假想根0（其实就是到这儿停）
	    //dfs一下，预处理各点的深度和祖先
	    over(i,1,m)
	    &#123;

	        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
	        printf(&quot;%lld\n&quot;,LCA(x,y));
	    &#125;
	    return 0;
	&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>算法竞赛——概述</title>
    <url>/2022/04/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="算法竞赛"><a class="markdownIt-Anchor" href="#算法竞赛"></a> 算法竞赛</h2>
<hr />
<h3 id="卡常技巧"><a class="markdownIt-Anchor" href="#卡常技巧"></a> 卡常技巧</h3>
<p><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929165652647-2103037728.png" alt="" /></p>
<p>注：最终的取模操作或者是在中间过程取模，使得不出现负数的余数</p>
<h3 id="rand函数生成随机数时一定要考虑rand_max的值"><a class="markdownIt-Anchor" href="#rand函数生成随机数时一定要考虑rand_max的值"></a> rand（）函数生成随机数时一定要考虑RAND_MAX的值</h3>
<h3 id="函数调用时对其参数求值的顺序就是未指定的"><a class="markdownIt-Anchor" href="#函数调用时对其参数求值的顺序就是未指定的"></a> 函数调用时，对其参数求值的顺序就是未指定的。</h3>
<h3 id="评测系统返回的错误信息"><a class="markdownIt-Anchor" href="#评测系统返回的错误信息"></a> 评测系统返回的错误信息：</h3>
<pre><code>* CE(compiler error): 无法编译成可执行文件（不算罚时)
* TL(TIMELIMIT):时间超限
* RE(RUN-ERROR):
	○ return返回值非0，未正常退出
	○ 也可能是内存超限
	○ 内存开得过大也可能报错
* OL(OUTPUT-LIMIT):输出超限
	○ 可能陷入了带输出的死循环
	○ 忘记删除调试输出
	○ 有时只是WA的一种表现形式
* WA(WRONG-ANSWER):
	○ 空白字符(行末空格和文末回车），因此每行应以&quot;\n&quot;结束
</code></pre>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<pre><code>Ø 栈溢出主要表现：
	○ RUN-ERROR
	○ 段错误
	○ segmentation fault (core dumped)
Ø 预防排查
	○    避免死递归
	○ 热身赛可以测试评测系统是否调整了栈空间
	○ 全局变量：
	不要将巨大的数组或结构体声明为自动局部变量或按值传递的参数，可以开全局或者静态变量，通过指针/引用传递
</code></pre>
<h3 id="整数溢出"><a class="markdownIt-Anchor" href="#整数溢出"></a> 整数溢出</h3>
<p>未定义行为：<br />
§ 带符号整数算术运算溢出<br />
§ 移位位数超过整数位数<br />
§ 使用 scanf 读取数字时，输入超过格式化字符串指定的表示范围<br />
§ 浮点数转化为整数时，其值超过了整数类型能表示的范围<br />
以下行为可能导致出人意料的结果：<br />
§ 无符号整数算术运算溢出 (丢弃高位)<br />
§ 使用 cin 读取数字时，输入超过变量的表示范围 (读入错误的值，并设定 failbit)<br />
§ 整数类型互相转化时高位被丢弃<br />
§ 浮点数转化为整数时小数部分被截断<br />
§ 浮点数精度问题导致负0的出现</p>
<h3 id="常见错误的预防和排查"><a class="markdownIt-Anchor" href="#常见错误的预防和排查"></a> 常见错误的预防和排查</h3>
<pre><code>I 开始编码前预先考虑好输入、中间结果、最终结果的可能范围 
I 该取模的模（指中间过程就开始取模运算，因为结果直接取模一般没必要） 
I 该开 64 位和 128 位整数的开 
I 该转型的转：1ll * a * b（转换成long long型的避免运算时结果溢出）
I 该换语言的换（指python方便处理时用）
I 该写高精度的写（不能用python时，必要就写） 
I 打开编译器相关警告选项（辅助） 
I 编造数据测试是否有溢出 
I 如果测试过程中发现溢出，打开运行时检查工具 
I 如果确实需要溢出，使用无符号整数 
I 反对盲目蛮干
</code></pre>
<h3 id="无效指针"><a class="markdownIt-Anchor" href="#无效指针"></a> 无效指针</h3>
<pre><code>Ø 未初始化的指针使用就是未定义行为 
Ø 越出数组界限的指针 
	○ 对不指向数组中元素的指针进行偏移运算是未定义的 
	○ 对指向数组中元素的指针进行偏移运算，越出数组范围 (结果不指向同一数组中的元素，或该数组最后一个元素“之后的一个元素”)，行为是未定义的
Ø 预防和排查
	○ 数组开得尽量大
	○ 对指针和数组下标进行必要检查
	○ 打开运行时检查进行检查
</code></pre>
<h3 id="无效迭代器"><a class="markdownIt-Anchor" href="#无效迭代器"></a> 无效迭代器</h3>
<p>在一些 (可能意想不到的) 情况下，迭代器会失效变成非法的<br />
Ø 迭代器不能越界<br />
Ø 例1：<br />
预防与排查：<br />
○ 不要滥用迭代器<br />
○ 在range-based for循环中，不要对迭代的容器进行插入或删除操作<br />
○ 在 set、map、multiset、multimap、list 等中进行删除操作时，可以使用 c.erase(it++) 的写法<br />
对于 C<ins>11 以上，还支持 it = c.erase(it) 的写法<br />
○ 如果怀疑使用了无效迭代器，可以打开 C</ins> 标准库的运行时检查</p>
<h3 id="超时的分析"><a class="markdownIt-Anchor" href="#超时的分析"></a> 超时的分析</h3>
<pre><code>Ø 算法的选择不合适
Ø 算法合适，但某个细节未考虑，导致高次时间复杂度
举例：
	
&lt;1&gt;循环多次调用strlen(s)，时间复杂度 O(n2)
&lt;2&gt;对大的数组，如果每组数据用的数组内存较少而数据组数较多时，多次memset会做很多无用功，导致时间复杂度较高 O(mn)
Ø 常数太大
I 典型代表：endl 或者忘了用 cin.tie(0)、valarray
预防和排查：
</code></pre>
]]></content>
  </entry>
</search>
