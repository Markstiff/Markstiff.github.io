<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Programming</title>
    <url>/2022/05/16/C++%20Programming/</url>
    <content><![CDATA[<h2 id="bfs算法"><a class="markdownIt-Anchor" href="#bfs算法"></a> BFS算法</h2>
<p>1、可以考虑压缩状态空间，用bool数组进行存储时将其转换为bool8个位，用一个整数存储即可<br />
2、A*算法</p>
<pre><code>Astr 、估价函数    
BFS 层次分析，状态压缩，进行整理总结能够简化运算  
DFS 不能进行状态压缩   
数据结构（增删改查）——树（决策树、搜索树）    
数据结构都是描述数据的关联性的，    
</code></pre>
<h2 id="二叉树存储"><a class="markdownIt-Anchor" href="#二叉树存储"></a> 二叉树存储：</h2>
<p>1、数组：关系用位置存储，存储结点<br />
2、链表存储：类似双向链表，<code>Lchild data Rchild</code><br />
3、三叉链表存储：作用是双向搜索<br />
先序遍历，循环递推结构<br />
<strong>程序设计：</strong><br />
1、不确定行为<code>bug：</code>未初始化值、数组越界、带符号整数溢出<br />
2、命名空间：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Namespace fluke
&#123;
		const int m &#x3D; 999999;
		poly poly_mul(poly a,poly b);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3、竞赛头文件：<code>#include&lt;bits/stdc++.h&gt;</code><br />
4、寻找指定数据所在范围</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
&#123;
	int a[] &#x3D; &#123; 1,1,4,5,1,4 &#125;;
	sort(a, a + 6);
	int l &#x3D; lower_bound(a, a + 6, 4) - a;
	int r &#x3D; upper_bound(a, a + 6, 4) - a;
	cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>5、二分查找函数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int recursive(vector&lt;int&gt;  arg)
&#123;
	if (arg &#x3D;&#x3D; final_state)
		return 114;
	vector&lt;int&gt; new_state1 &#x3D; get(arg);
	vector&lt;int&gt; new_state2 &#x3D; get(arg);
	return recuresive(new_state1) + recuresive(new_state2) + 514;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>6、重载运算符：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Struct vec
&#123;
		int x, y;
		long long len() &#123;…&#125;
		bool operator &lt; &#123;const vec &amp;rhs&#125; const
		&#123;
				return len() &lt;&#x3D; rhs.len();
		&#125;
		long long operator *(const vec &amp;rhs)  const
		&#123;
					return 111 * x * rhs.x + 111 * y * rhs.y;
			&#125;
		long long operator ^(const vec &amp;rhs) const
		&#123;
					return 111 * x * rhs.y - 111 * y * rhs.x;
		&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>7、<code>std::set</code>数据结构(基于有序的数据结构具体是二叉搜索树）</p>
<pre class="highlight"><code class="C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
		set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a: s)                        #简便写法类似python中的可迭代对象
			cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;
</code></pre>
<p><code>multiset</code>数据结构和<code>set</code>类似，只不过允许数据重复，插入时即是有序的<br />
8、映射数据结构</p>
<pre class="highlight"><code class="C++">map&lt;string, <span class="hljs-type">int</span>&gt; mp = &#123;
		&#123;<span class="hljs-string">&quot;Monday&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;Tuesday&quot;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&quot;Wenesday&quot;</span>,<span class="hljs-number">3</span>&#125;
	&#125;;
	cout &lt;&lt; mp[<span class="hljs-string">&quot;Tuesday&quot;</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	cout &lt;&lt; mp.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-string">&quot;Tue&quot;</span>)-&gt;first &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
	cout &lt;&lt; mp.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-string">&quot;Tue&quot;</span>)-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&gt;&gt;<span class="hljs-number">2</span>
&gt;&gt;Tuesday
&gt;&gt;<span class="hljs-number">2</span>
</code></pre>
<p>9、加快输入输出流的速度：</p>
<pre class="highlight"><code class="C++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);
用来加快cin、cout的速率
</code></pre>
<p>10、<code>cout &lt;&lt; x+y &lt;&lt; '\n' &lt;&lt; flush;</code>强行刷新缓冲区，使数据立即输出<br />
11、移位运算</p>
<pre class="highlight"><code class="C++">a &lt;&lt;= <span class="hljs-number">10</span>  <span class="hljs-comment">//a * 1024;</span>
a &lt;&lt;= k   <span class="hljs-comment">//a * 2^k;</span>
b &gt;&gt;= k   <span class="hljs-comment">//a / 2^k;</span>
a |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>);  <span class="hljs-comment">//将a的二进制第十一位换成1，进行调节</span>
a &amp; <span class="hljs-number">1</span> <span class="hljs-comment">// a % 2</span>
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Codetest</title>
    <url>/2022/10/02/code/</url>
    <content><![CDATA[<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;

using namespace std;
typedef struct student &#123;
    int num;
    char name[12];
    char axs;
    struct student* next;
&#125;Stu;
Stu* head;
bool Stu_read(Stu* &amp;p)
&#123;
    Stu* temp &#x3D; (Stu*)malloc(sizeof(Stu));
    if (!temp) return false;
    cin &gt;&gt; temp-&gt;name;
    if (temp-&gt;name[0] &#x3D;&#x3D; &#39;#&#39;) &#123;
        free(temp);
        return false;
    &#125;
    cin &gt;&gt; temp-&gt;num &gt;&gt; temp-&gt;axs;
    p-&gt;next &#x3D; temp;
    temp-&gt;next &#x3D; NULL;
    p &#x3D; p-&gt;next;
    head-&gt;num++;
    return true;
&#125;
bool Search_stu(int m)
&#123;
    Stu* p &#x3D; head;
    while (p-&gt;next) &#123;
        if (p-&gt;next-&gt;num &#x3D;&#x3D; m) &#123;
            Stu* q &#x3D; p-&gt;next;
            p-&gt;next &#x3D; p-&gt;next-&gt;next;
            free(q);
            return true;
        &#125;
        p &#x3D; p-&gt;next;
    &#125;
    return false;
&#125;
void Stu_print()
&#123;
    Stu* p &#x3D; head-&gt;next;
    while (p) &#123;
        cout &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;axs &lt;&lt; endl;
        p &#x3D; p-&gt;next;
    &#125;
    return;
&#125;
int main()
&#123;
    head &#x3D; (Stu*)malloc(sizeof(Stu));
    head-&gt;next &#x3D; NULL;
    head-&gt;num &#x3D; 0;
    Stu* temp &#x3D; head;
    while (Stu_read(temp) &#x3D;&#x3D; true);
    int Out_stu &#x3D; 0;
    cin &gt;&gt; Out_stu;
    if (Search_stu(Out_stu)) Stu_print();
    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>code</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB基本操作学习</title>
    <url>/2022/03/27/MATLAB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="matlab基本操作学习"><a class="markdownIt-Anchor" href="#matlab基本操作学习"></a> MATLAB基本操作学习</h2>
<pre class="line-numbers language-MATLAB" data-language="MATLAB"><code class="language-MATLAB">• 清除变量：clear pi &#x2F;clearvars pi inf   &#x2F;恢复默认变量
• 判别是否是关键字    iskeyword(&#39;for&#39;)
• 数据输出格式
Format rat 分子格式
Format compact 压缩格式，不显示空白行
• 常用函数
指数函数：exp      以2对数：log2     自然对数：log
取整: 四舍五入 round  正无穷方向取整  ceil 负无穷方向取整  floor  向零方向取整 fix 
求余函数：rem     取模函数：mod
反正弦：asin
求复数实部：real       求复数虚部：imag        求共轭复数：conj
求平均值：mean    标准差：std     方差：var     协方差：cov
相关系数：corrcoef                极差：range      
符号函数：sign    例sign(x)求 x 中元素的符号
• 规模化定义向量
X &#x3D; 初值：步长：终值&#x2F;初值：终值
X &#x3D; linspace(初值，终值，向量长度）  用来生成等间隔向量    
• 向量与矩阵的转换
X &#x3D; A(:)            % 矩阵A转为列向量x
A &#x3D; reshape(x, [m, n])    % 将长度为m*n的向量x转换为m行n列矩阵
• 按指定阵列复制矩阵
B &#x3D; repmat(A,[2, 3])      % 复制矩阵A按行方向复制两次，列方向复制3次
• 复数矩阵
C &#x3D; complex(a, b)            % 以a为实部，b为虚部生成复数矩阵   a, b 均为矩阵
• 符号矩阵
Y &#x3D; sym(y)  % 将数值矩阵y转换为符号矩阵Y
Z &#x3D; sym(&#39;a%d%d&#39;,[2,3])     % 其中%d、%d按照下标进行赋值
特殊矩阵    zeros(size(A)）生成与A相同大小的零矩阵
对角阵  diag      X  &#x3D; diag(v,k)    以向量v为第k个对角线生成对角矩阵
X  &#x3D; diag(v)  以v为主对角线生成对角阵
v  &#x3D; diag(X, k)   返回矩阵X的第k条对角线上元素   省略k时默认为主对角线
• 元胞数组
&lt;1&gt; 直接用花括号赋值创建；&lt;2&gt; cell(m, n, p···)创建空元胞数组
访问元胞：C(i,j)           访问元胞中的元素：C&#123;I,j&#125;          celldisp显示元胞数组里面所有内容
• 结构体数组
&lt;1&gt; 直接赋值定义  struct1(n).attris           指定第n个结构体数组单元的各属性
&lt;2&gt; struct函数构造    s  &#x3D;struct(&#39;field1&#39;, values1, &#39;field2&#39;, values2····)
Example: s  &#x3D; struct(&#39;name&#39;, &#123;&#39;Mark&#39;, &#39;Lucy&#39;&#125;, &#39;age&#39;, &#123;31,22&#125;)
• 数组转换
str2func - 根据字符向量构造函数句柄  
• 表格型数组（Table Class)
工作区的变量定义为表格型
T &#x3D; table(Age, Height, Weight, Blood, &#39;RowNames&#39;, Name)      (其中各变量均为向量)
访问 T.Height
• 逻辑运算
或运算：A|B   对应元素非零为1否则为0得到一个布尔矩阵
与运算：A&amp;B 均非零
非运算：~A 非零为零，零为1
异或运算：xor(A,B)    均为零或均非零为零否则为1
判断逻辑运算：A||B   判断A或B是否为零矩阵    A&amp;&amp;B
• 逆矩阵   Ai &#x3D; inv(A)    % 求A的逆矩阵
[V, D] &#x3D; eig(A)      % 求数值矩阵A的特征值D和特征向量矩阵V  （D为对角阵）
矩阵的迹  t  &#x3D;trace(A)
矩阵的秩  r  &#x3D; rank(A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>附录——常用数组转换函数</strong><br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172805394-926335148.png" alt="" /></p>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>分治与倍增</title>
    <url>/2022/05/03/%E5%88%86%E6%B2%BB%E4%B8%8E%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<hr />
<h4 id="double-powdouble-x-double-y"><a class="markdownIt-Anchor" href="#double-powdouble-x-double-y"></a> <code>Double pow(double x, double y)</code></h4>
<h4 id="倍增算法"><a class="markdownIt-Anchor" href="#倍增算法"></a> 倍增算法：</h4>
<p>倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂度的要求 ,那么我们就可以通过成倍的增长,只递推状态空间中在 2 的整数次幂位置上的值作为代表 。当需要其他位置上的值时,我们只需要通过&quot; 任意整数可以表示成若干个2的次幂项的和 &quot; 这一性质<code>(13 = 2^3 + 2^2 +2^0)</code>, 使用之前求出的代表值拼成所需的值。<br />
核心思想：不断以2的次幂的跨度向前试探，行进跨度，不行就降幂，迭代可以表示任意整数</p>
<h4 id="倍增主要应用"><a class="markdownIt-Anchor" href="#倍增主要应用"></a> 倍增主要应用：</h4>
<p><code>LCA(least common ancestors)</code>:最近公共祖先<br />
在有根树中，找出某两个结点u和v最近的公共祖先。<br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929170840386-1257726897.png" alt="" /><br />
在寻找两个节点的公共祖先时，按2的指数来跳，并且从大到小，……32, 16, 8 , 4 , 2, 1 【从大到小试探】</p>
<h4 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理：</h4>
<p>处理结点的深度、父节点、以及2i级的祖先<br />
<strong>开辟数组：</strong></p>
<pre class="highlight"><code class="C++">&lt;<span class="hljs-number">1</span>&gt;  depth数组是记录每个节点的深度        
&lt;<span class="hljs-number">2</span>&gt;  fa[i][j]是指节点 i 的 <span class="hljs-number">2</span>j 级的祖先的编号      
&lt;<span class="hljs-number">3</span>&gt; lg数组是常数优化的数组，存的是log2N+<span class="hljs-number">1</span>的值，注意用的时候要<span class="hljs-number">-1</span>，开始之前先初始化一下，这样直接调用可以优化节约时间其中初始化的方法：l g [ i ] = l g [ i − <span class="hljs-number">1</span> ] + ( <span class="hljs-number">1</span> &lt; &lt; l g [ i − <span class="hljs-number">1</span> ] = = i ) lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i)lg[i]=lg[i−<span class="hljs-number">1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i−<span class="hljs-number">1</span>]==i)，自己手算一下很清楚的（lg[<span class="hljs-number">1</span>~<span class="hljs-number">10</span>]为<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>，应该很好懂吧）   
</code></pre>
<p><strong>手写对数运算lg2[i]:</strong></p>
<pre class="highlight"><code class="C++"><span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n)<span class="hljs-comment">//预处理一下 </span>
lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span>
<span class="hljs-comment">//可以学习宏定义简便写法</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p&lt;&lt;1)  <span class="hljs-comment">//取半</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p&lt;&lt;1|1)   <span class="hljs-comment">//取半加一</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l+r)/2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> over(i,s,t) for(register long long i=s;i&lt;=t;++i)   <span class="hljs-comment">//循环的简写 </span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> lver(i,t,s) for(register long long i=t;i&gt;=s;--i)</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<span class="hljs-comment">//全用ll可能会MLE或者直接WA,试着改成int看会不会A</span>
<span class="hljs-type">const</span> ll N=<span class="hljs-number">500007</span>;
<span class="hljs-type">const</span> ll INF=<span class="hljs-number">1e9</span>+<span class="hljs-number">9</span>;
<span class="hljs-type">const</span> ll mod=<span class="hljs-number">2147483647</span>;
<span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS=<span class="hljs-number">1e-10</span>;<span class="hljs-comment">//-10次方约等于趋近为0</span>
<span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi=<span class="hljs-number">3.1415926535897</span>;
ll n,m;
<span class="hljs-comment">//前向星写法的数据结构实现：</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>
&#123;
	ll u,v,nex;
&#125;e[N&lt;&lt;<span class="hljs-number">1</span>];
ll head[N],cnt;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll u,ll v)</span>
</span>&#123;
	e[++cnt].v=v;    <span class="hljs-comment">//记录边的终点</span>
	e[cnt].u=u;<span class="hljs-comment">//没什么用，还白占空间</span>
	e[cnt].nex=head[u];     <span class="hljs-comment">//以u为起点的上一条边，往往更喜欢写做pre</span>
	head[u]=cnt;    <span class="hljs-comment">//更新以u为起点的上一条边</span>
&#125;
ll depth[N],fa[N][<span class="hljs-number">30</span>],lg[N],s,x,y;

<span class="hljs-comment">/*dfs函数的作用就是更新该点的所有祖先的fa数组，并通过递归把
该节点的所有的子节点和该节点一样去更新*/</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll now,ll fath)</span><span class="hljs-comment">//子节点和父节点</span>
</span>&#123;
	fa[now][<span class="hljs-number">0</span>]=fath;<span class="hljs-comment">//更新一下fa数组，2^0=1就是父节点</span>
	depth[now]=depth[fath]+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新深度，递归的思想</span>
	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,lg[depth[now]]<span class="hljs-number">-1</span>)
		fa[now][i]=fa[fa[now][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];
		<span class="hljs-comment">/*更新now的所有 2^i 级的祖先。先找到now的2^(i-1)级祖先，再往上找
		该祖先的2^(i-1)级祖先，就是now的2^i祖先，必须一节一节地往上搜*/</span>
	<span class="hljs-keyword">for</span>(ll i=head[now];i;i=e[i].nex)<span class="hljs-comment">//链式前向星遍历</span>
		<span class="hljs-comment">//如果now有子节点的话，就递归往子节点的子节点走（禁止套娃）</span>
		ll v = e[i].v;
		<span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;
	<span class="hljs-built_in">dfs</span>(e[i].v,now);
&#125;

<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">LCA</span><span class="hljs-params">(ll x,ll y)</span>
</span>&#123;
	<span class="hljs-keyword">if</span>(depth[x]&lt;depth[y])<span class="hljs-comment">//用数学语言就是说不妨设x的深度比y的深度大</span>
		<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//这样下面只需要写一种代码就好了</span>
	<span class="hljs-keyword">while</span>(depth[x]&gt;depth[y])
		<span class="hljs-comment">//让x跳到y的高度（同一高度）</span>
		x=fa[x][lg[depth[x]-depth[y]]<span class="hljs-number">-1</span>];
	<span class="hljs-comment">//如果跳到一块了那LCA肯定就是y了</span>
	<span class="hljs-keyword">if</span>(x==y)
		<span class="hljs-keyword">return</span> x;
	<span class="hljs-keyword">for</span>(ll k=lg[depth[x]]<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;--k)<span class="hljs-comment">//倒着从大到小地跳</span>
		<span class="hljs-comment">/*因为我们要求跳到x和y的LCA的下一层，所以没有跳到的时候就
		让x和y利用dfs里早就用倍增算法处理过的祖先路径快速地一块往上跳*/</span>
		<span class="hljs-keyword">if</span>(fa[x][k]!=fa[y][k])
			x=fa[x][k],y=fa[y][k];<span class="hljs-comment">//往上跳</span>
	<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<span class="hljs-comment">//返回x，y的父节点（肯定是相同的嘛）</span>
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;s);
	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)
	&#123;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);
		<span class="hljs-built_in">add</span>(x,y),<span class="hljs-built_in">add</span>(y,x);<span class="hljs-comment">//无向图一定要记得建双向边</span>
	&#125;
	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n)<span class="hljs-comment">//预处理一下</span>
	lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;</span>
	<span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<span class="hljs-comment">//从树根开始，因为用的是链式前向星所以给一个假想根0（其实就是到这儿停）</span>
	<span class="hljs-comment">//dfs一下，预处理各点的深度和祖先</span>
	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,m)
	&#123;

		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">LCA</span>(x,y));
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>串</title>
    <url>/2022/09/28/%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="数据结构串"><a class="markdownIt-Anchor" href="#数据结构串"></a> 数据结构——串</h2>
<p>(字符串实现与操作）</p>
<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">pass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2022/02/12/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一-基本操作语法"><a class="markdownIt-Anchor" href="#一-基本操作语法"></a> 一、基本操作语法</h2>
<h3 id="11-基本格式"><a class="markdownIt-Anchor" href="#11-基本格式"></a> 1.1 基本格式</h3>
<p>&lt;1&gt; 设置标题前后均留有空格</p>
<p>&lt;2&gt; 加粗:</p>
<p><strong>加粗示例1（较推荐）</strong></p>
<p><strong>加粗示例2</strong></p>
<p>&lt;3&gt; 斜体：</p>
<p><em>斜体示例1(较推荐）</em></p>
<p><em>斜体示例2</em></p>
<h3 id="12-段落和换行"><a class="markdownIt-Anchor" href="#12-段落和换行"></a> 1.2 段落和换行</h3>
<h4 id="没有空行示例"><a class="markdownIt-Anchor" href="#没有空行示例"></a> 没有空行示例</h4>
<p>第一行<br />
第二行</p>
<h4 id="有空行示例"><a class="markdownIt-Anchor" href="#有空行示例"></a> 有空行示例</h4>
<p>第一行</p>
<p>第二行</p>
<h4 id="段内换行"><a class="markdownIt-Anchor" href="#段内换行"></a> 段内换行</h4>
<p>第一行，如果在段内换行需要在结尾插入两个及以上的空格<br />
第二行</p>
<h3 id="13-有序列表"><a class="markdownIt-Anchor" href="#13-有序列表"></a> 1.3 有序列表</h3>
<h4 id="有序列表示例"><a class="markdownIt-Anchor" href="#有序列表示例"></a> 有序列表示例</h4>
<p>(数字序号+英文句号+空格+列表内容)</p>
<ol>
<li>我有一个梦想</li>
<li>我有两个梦想</li>
<li>我有三个梦想</li>
</ol>
<h3 id="14-无序列表"><a class="markdownIt-Anchor" href="#14-无序列表"></a> 1.4 无序列表</h3>
<h4 id="无序列表示例"><a class="markdownIt-Anchor" href="#无序列表示例"></a> 无序列表示例</h4>
<p>(*/+/- + 空格 + 列表内容)</p>
<h5 id="使用星号"><a class="markdownIt-Anchor" href="#使用星号"></a> 使用星号</h5>
<ul>
<li>我有一个梦想</li>
<li>我有两个梦想</li>
<li>我有三个梦想<br />
（其他标记效果相同）</li>
</ul>
<h3 id="15-嵌套列表"><a class="markdownIt-Anchor" href="#15-嵌套列表"></a> 1.5 嵌套列表</h3>
<h4 id="语法示例"><a class="markdownIt-Anchor" href="#语法示例"></a> 语法示例</h4>
<p>在第一层列表上，每一层多一个TAB键</p>
<ul>
<li>我有一个梦想
<ul>
<li>你有一个梦想
<ul>
<li>她有一个梦想
<ul>
<li>他有一个梦想<br />
(有序列表类似可以互相嵌套）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>(建议使用-标记无序列表避免与粗体和斜体混淆)</em></strong></p>
<h3 id="16-分割线"><a class="markdownIt-Anchor" href="#16-分割线"></a> 1.6 分割线</h3>
<h4 id="基本格式"><a class="markdownIt-Anchor" href="#基本格式"></a> 基本格式</h4>
<p>分割线由3个及以上的*/-/_来标记，对应效果不同。<br />
<strong>分割线示例</strong></p>
<ul>
<li>星号</li>
</ul>
<hr />
<hr />
<hr />
<ul>
<li>减号</li>
</ul>
<hr />
<hr />
<hr />
<ul>
<li>下画线</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="二-图片文件操作"><a class="markdownIt-Anchor" href="#二-图片文件操作"></a> 二、图片文件操作</h2>
<h3 id="21-插入图片"><a class="markdownIt-Anchor" href="#21-插入图片"></a> 2.1 插入图片</h3>
<h4 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h4>
<ul>
<li>
<p>本地图片<br />
（支持相对路径和绝对路径）<br />
<img src="D:/VisualStudioIDE/background/1.png" alt="本地图片" /></p>
</li>
<li>
<p>网络图片<br />
<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fd5f14e00482699c1c3b3509142b16f88126deff7.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1666447219&amp;t=b8c922e69db81319d3dc686fb66a0e53" alt="网络图片" /></p>
</li>
</ul>
<h3 id="22-链接"><a class="markdownIt-Anchor" href="#22-链接"></a> 2.2 链接</h3>
<h4 id="基本语法-2"><a class="markdownIt-Anchor" href="#基本语法-2"></a> 基本语法</h4>
<h5 id="文字链接"><a class="markdownIt-Anchor" href="#文字链接"></a> 文字链接</h5>
<p><strong><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接文字</a></strong><br />
经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a></p>
<h5 id="引用链接"><a class="markdownIt-Anchor" href="#引用链接"></a> 引用链接</h5>
<p>经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a></p>
<p>语法说明如下：</p>
<ul>
<li>链接标记可以有字母、数字、空格和标点符号；</li>
<li>链接标记不区分大小写；</li>
<li>定义的链接内容可以放在当前文件的任意位置，建议放在页尾；</li>
<li>当链接地址为网络地址时要以http/https开头，否则会被识别为本地地址。</li>
</ul>
<h4 id="网址链接"><a class="markdownIt-Anchor" href="#网址链接"></a> 网址链接</h4>
<p>在Markdown中，将网络地址或邮箱地址使用＜＞包裹起来会被自动转换为超链接。<br />
<strong>邮箱链接示例</strong><br />
获取更多信息，请访问MarkStiff的邮箱<a href="mailto:LZH1314521ligao@163.com">LZH1314521ligao@163.com</a></p>
<h4 id="链接标题"><a class="markdownIt-Anchor" href="#链接标题"></a> 链接标题</h4>
<p>如果想了解关于Markdown的更多信息，请查看<a href="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0.md">Markdown指南</a></p>
<h3 id="23-行内代码与代码块"><a class="markdownIt-Anchor" href="#23-行内代码与代码块"></a> 2.3 行内代码与代码块</h3>
<h4 id="行内代码"><a class="markdownIt-Anchor" href="#行内代码"></a> 行内代码</h4>
<p><strong>语法格式<code>Insert_Codes</code></strong></p>
<ul>
<li>使用<code>mkdir 文件夹</code>命令创建文件夹</li>
</ul>
<h4 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h4>
<p><strong>语法格式：Tab键或4个空格开头</strong> //注意代码块需要隔行</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;创建链表
typedef struct Node&#123;
    int data;
    struct Node* next;
&#125;node;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="24-引用"><a class="markdownIt-Anchor" href="#24-引用"></a> 2.4 引用</h3>
<p><strong>语法格式：&gt; + 引用内容</strong><br />
语法说明如下：</p>
<ol>
<li>多行引用也可以在每一行的开头都插入＞；</li>
<li>在引用中可以嵌套引用；</li>
<li>在引用中可以使用其他的Markdown语法；</li>
<li>段落与换行的格式在引用中也是适用的。</li>
</ol>
<h4 id="单行引用"><a class="markdownIt-Anchor" href="#单行引用"></a> 单行引用</h4>
<blockquote>
<p>基于改进的自约束差分进化算法的多目标优化模型</p>
</blockquote>
<h4 id="多行引用"><a class="markdownIt-Anchor" href="#多行引用"></a> 多行引用</h4>
<blockquote>
<p>引用MarkStiff的博客文章<a href="https://www.cnblogs.com/MarkStiff/p/16716797.html">MarkStiff</a><br />
算法介绍</p>
</blockquote>
<h4 id="嵌套引用"><a class="markdownIt-Anchor" href="#嵌套引用"></a> 嵌套引用</h4>
<blockquote>
<p>多目标优化模型</p>
<blockquote>
<p>差分进化算法</p>
<blockquote>
<p>改进的自约束处理</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="25-转义"><a class="markdownIt-Anchor" href="#25-转义"></a> 2.5 转义</h3>
<p><strong>介绍</strong><br />
当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用 <code>\</code> 进行转义<br />
<strong>语法格式：\特殊字符</strong></p>
<pre><code>`// 常见转义字符`
</code></pre>
<p>\   反斜线<br />
`   反引号<br />
*   星号<br />
_   底线<br />
{}  花括号<br />
[]  方括号<br />
()  括弧<br />
#   井字号<br />
+   加号<br />
-   减号<br />
.   英文句点<br />
!   惊叹号</p>
]]></content>
  </entry>
  <entry>
    <title>数模C题</title>
    <url>/2022/05/13/%E6%95%B0%E6%A8%A1C%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数模c题总结"><a class="markdownIt-Anchor" href="#数模c题总结"></a> 数模C题总结</h2>
<h4 id="第一部分问题分析"><a class="markdownIt-Anchor" href="#第一部分问题分析"></a> 第一部分——问题分析</h4>
<p>拆分问题，将各个问题进行拆分，尤其是效果分析类的</p>
<h4 id="第一部分数据预处理"><a class="markdownIt-Anchor" href="#第一部分数据预处理"></a> 第一部分——数据预处理</h4>
<p><strong>数据探索性分析</strong></p>
<pre><code>箱型图======&gt;探究是否有偏好情况=======&gt;决定了之后问题解决是否要考虑材料种类差异
对数直方图、洛伦兹图======&gt;探究数据是否存在数量级差异以及数据的均衡程度
散点图======&gt;探究数据的分布情况
</code></pre>
<h4 id="第二部分评价类"><a class="markdownIt-Anchor" href="#第二部分评价类"></a> 第二部分——评价类</h4>
<p><strong>熵权法-TOPSIS</strong></p>
<pre><code>叙述:
熵权法通过计算指标的信息熵，根据其相对变化程度对系统的整体影响来决定权重，避免了
层次分析法等主观赋权法的弊端，获取权重的客观性较强。在得到权重后， 利用 TOPSIS
方法将它们综合， TOPSIS 法通过构建评价问题的正理想解和负理想解，计算每个方案到理
想方案的相对贴近度来对方案进行排序，最终求解出最优方案。
</code></pre>
<h4 id="第三部分横纵向分析"><a class="markdownIt-Anchor" href="#第三部分横纵向分析"></a> 第三部分——横纵向分析</h4>
<pre><code>模型构建分析时，直接显著点出横向角度和纵向角度（一般有时间）来分析
核密度曲线
季节性分解
</code></pre>
<p><em>机会约束叙述：</em><br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172332648-38102188.png" alt="" /></p>
<pre><code>蒙特卡洛法
针状图====&gt;检验有效数据的完整性      
</code></pre>
<h4 id="第四部分方案实施效果分析"><a class="markdownIt-Anchor" href="#第四部分方案实施效果分析"></a> 第四部分——方案实施效果分析</h4>
<pre><code>绘制数据结果图=====&gt;结合图像说明或解释
变化面积图
置信因子α灵敏度分析:
分别取置信因子α=0.85， 0.9， 0.95对约束进行松弛，可以得到丌同的决策集合。
随着置信度𝛼的上升，随机变量𝜉的少数极端抖动造成约束条件难以满足， 迫使企
业需要增大订单量来对冲风险，亍是表现为总订单额的升高。
类似的，对亍转运损失率，随着置信度𝛼的上升，转运损失率也在违约率高的周
内相应明显升高，这也进一步印证了前文关亍损失率和违约率的机理猜测。    
</code></pre>
<h4 id="第五部分惩罚因子"><a class="markdownIt-Anchor" href="#第五部分惩罚因子"></a> 第五部分——惩罚因子</h4>
<pre><code>问题三只在问题二的基础上改变了一点要求，即尽量多地采购A 类和尽量少地采购C类原材料，
可以考虑为每立方米 A、 B、 C 三种材料分别赋予惩罚因子为 1、 5、10，以惩罚函数最小为目标，约束同问题二，建立右图所示的觃划模型。转运方案制定不方案实施效果分析同问题二。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>算法竞赛——概述</title>
    <url>/2022/04/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="算法竞赛"><a class="markdownIt-Anchor" href="#算法竞赛"></a> 算法竞赛</h2>
<hr />
<h3 id="卡常技巧"><a class="markdownIt-Anchor" href="#卡常技巧"></a> 卡常技巧</h3>
<p><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929165652647-2103037728.png" alt="" /></p>
<p>注：最终的取模操作或者是在中间过程取模，使得不出现负数的余数</p>
<h3 id="rand函数生成随机数时一定要考虑rand_max的值"><a class="markdownIt-Anchor" href="#rand函数生成随机数时一定要考虑rand_max的值"></a> rand（）函数生成随机数时一定要考虑RAND_MAX的值</h3>
<h3 id="函数调用时对其参数求值的顺序就是未指定的"><a class="markdownIt-Anchor" href="#函数调用时对其参数求值的顺序就是未指定的"></a> 函数调用时，对其参数求值的顺序就是未指定的。</h3>
<h3 id="评测系统返回的错误信息"><a class="markdownIt-Anchor" href="#评测系统返回的错误信息"></a> 评测系统返回的错误信息：</h3>
<pre><code>* CE(compiler error): 无法编译成可执行文件（不算罚时)
* TL(TIMELIMIT):时间超限
* RE(RUN-ERROR):
	○ return返回值非0，未正常退出
	○ 也可能是内存超限
	○ 内存开得过大也可能报错
* OL(OUTPUT-LIMIT):输出超限
	○ 可能陷入了带输出的死循环
	○ 忘记删除调试输出
	○ 有时只是WA的一种表现形式
* WA(WRONG-ANSWER):
	○ 空白字符(行末空格和文末回车），因此每行应以&quot;\n&quot;结束
</code></pre>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<pre><code>Ø 栈溢出主要表现：
	○ RUN-ERROR
	○ 段错误
	○ segmentation fault (core dumped)
Ø 预防排查
	○    避免死递归
	○ 热身赛可以测试评测系统是否调整了栈空间
	○ 全局变量：
	不要将巨大的数组或结构体声明为自动局部变量或按值传递的参数，可以开全局或者静态变量，通过指针/引用传递
</code></pre>
<h3 id="整数溢出"><a class="markdownIt-Anchor" href="#整数溢出"></a> 整数溢出</h3>
<p>未定义行为：<br />
§ 带符号整数算术运算溢出<br />
§ 移位位数超过整数位数<br />
§ 使用 scanf 读取数字时，输入超过格式化字符串指定的表示范围<br />
§ 浮点数转化为整数时，其值超过了整数类型能表示的范围<br />
以下行为可能导致出人意料的结果：<br />
§ 无符号整数算术运算溢出 (丢弃高位)<br />
§ 使用 cin 读取数字时，输入超过变量的表示范围 (读入错误的值，并设定 failbit)<br />
§ 整数类型互相转化时高位被丢弃<br />
§ 浮点数转化为整数时小数部分被截断<br />
§ 浮点数精度问题导致负0的出现</p>
<h3 id="常见错误的预防和排查"><a class="markdownIt-Anchor" href="#常见错误的预防和排查"></a> 常见错误的预防和排查</h3>
<pre><code>I 开始编码前预先考虑好输入、中间结果、最终结果的可能范围 
I 该取模的模（指中间过程就开始取模运算，因为结果直接取模一般没必要） 
I 该开 64 位和 128 位整数的开 
I 该转型的转：1ll * a * b（转换成long long型的避免运算时结果溢出）
I 该换语言的换（指python方便处理时用）
I 该写高精度的写（不能用python时，必要就写） 
I 打开编译器相关警告选项（辅助） 
I 编造数据测试是否有溢出 
I 如果测试过程中发现溢出，打开运行时检查工具 
I 如果确实需要溢出，使用无符号整数 
I 反对盲目蛮干
</code></pre>
<h3 id="无效指针"><a class="markdownIt-Anchor" href="#无效指针"></a> 无效指针</h3>
<pre><code>Ø 未初始化的指针使用就是未定义行为 
Ø 越出数组界限的指针 
	○ 对不指向数组中元素的指针进行偏移运算是未定义的 
	○ 对指向数组中元素的指针进行偏移运算，越出数组范围 (结果不指向同一数组中的元素，或该数组最后一个元素“之后的一个元素”)，行为是未定义的
Ø 预防和排查
	○ 数组开得尽量大
	○ 对指针和数组下标进行必要检查
	○ 打开运行时检查进行检查
</code></pre>
<h3 id="无效迭代器"><a class="markdownIt-Anchor" href="#无效迭代器"></a> 无效迭代器</h3>
<p>在一些 (可能意想不到的) 情况下，迭代器会失效变成非法的<br />
Ø 迭代器不能越界<br />
Ø 例1：<br />
预防与排查：<br />
○ 不要滥用迭代器<br />
○ 在range-based for循环中，不要对迭代的容器进行插入或删除操作<br />
○ 在 set、map、multiset、multimap、list 等中进行删除操作时，可以使用 c.erase(it++) 的写法<br />
对于 C<ins>11 以上，还支持 it = c.erase(it) 的写法<br />
○ 如果怀疑使用了无效迭代器，可以打开 C</ins> 标准库的运行时检查</p>
<h3 id="超时的分析"><a class="markdownIt-Anchor" href="#超时的分析"></a> 超时的分析</h3>
<pre><code>Ø 算法的选择不合适
Ø 算法合适，但某个细节未考虑，导致高次时间复杂度
举例：
	
&lt;1&gt;循环多次调用strlen(s)，时间复杂度 O(n2)
&lt;2&gt;对大的数组，如果每组数据用的数组内存较少而数据组数较多时，多次memset会做很多无用功，导致时间复杂度较高 O(mn)
Ø 常数太大
I 典型代表：endl 或者忘了用 cin.tie(0)、valarray
预防和排查：
</code></pre>
]]></content>
  </entry>
</search>
