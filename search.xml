<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Programming</title>
    <url>/2022/05/16/C++%20Programming/</url>
    <content><![CDATA[<h2 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h2><p>1、可以考虑压缩状态空间，用bool数组进行存储时将其转换为bool8个位，用一个整数存储即可<br>2、A*算法    </p>
<pre><code>Astr 、估价函数    
BFS 层次分析，状态压缩，进行整理总结能够简化运算  
DFS 不能进行状态压缩   
数据结构（增删改查）——树（决策树、搜索树）    
数据结构都是描述数据的关联性的，    
</code></pre><h2 id="二叉树存储："><a href="#二叉树存储：" class="headerlink" title="二叉树存储："></a>二叉树存储：</h2><p>1、数组：关系用位置存储，存储结点<br>2、链表存储：类似双向链表，<code>Lchild data Rchild</code><br>3、三叉链表存储：作用是双向搜索<br>  先序遍历，循环递推结构<br><strong>程序设计：</strong><br>1、不确定行为<code>bug：</code>未初始化值、数组越界、带符号整数溢出<br>2、命名空间：   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">Namespace fluke<br>&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-type">int</span> m = <span class="hljs-number">999999</span>;<br>		<span class="hljs-function">poly <span class="hljs-title">poly_mul</span><span class="hljs-params">(poly a,poly b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>3、竞赛头文件：<code>#include&lt;bits/stdc++.h&gt;</code><br>4、寻找指定数据所在范围   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-built_in">sort</span>(a, a + <span class="hljs-number">6</span>);<br>	<span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(a, a + <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) - a;<br>	<span class="hljs-type">int</span> r = <span class="hljs-built_in">upper_bound</span>(a, a + <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) - a;<br>	cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>5、二分查找函数   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;  arg)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (arg == final_state)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">114</span>;<br>	vector&lt;<span class="hljs-type">int</span>&gt; new_state1 = <span class="hljs-built_in">get</span>(arg);<br>	vector&lt;<span class="hljs-type">int</span>&gt; new_state2 = <span class="hljs-built_in">get</span>(arg);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">recuresive</span>(new_state1) + <span class="hljs-built_in">recuresive</span>(new_state2) + <span class="hljs-number">514</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>6、重载运算符：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">Struct vec<br>&#123;<br>		<span class="hljs-type">int</span> x, y;<br>		<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">len</span><span class="hljs-params">()</span> </span>&#123;…&#125;<br>		<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; &#123;<span class="hljs-type">const</span> vec &amp;rhs&#125; <span class="hljs-type">const</span><br>		&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>() &lt;= rhs.<span class="hljs-built_in">len</span>();<br>		&#125;<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> *(<span class="hljs-type">const</span> vec &amp;rhs)  <span class="hljs-type">const</span><br>		&#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-number">111</span> * x * rhs.x + <span class="hljs-number">111</span> * y * rhs.y;<br>			&#125;<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> ^(<span class="hljs-type">const</span> vec &amp;rhs) <span class="hljs-type">const</span><br>		&#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-number">111</span> * x * rhs.y - <span class="hljs-number">111</span> * y * rhs.x;<br>		&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>7、<code>std::set</code>数据结构(基于有序的数据结构具体是二叉搜索树）<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>		set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a: s)                        #简便写法类似python中的可迭代对象<br>			cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><code>multiset</code>数据结构和<code>set</code>类似，只不过允许数据重复，插入时即是有序的<br>8、映射数据结构<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">map&lt;string, <span class="hljs-type">int</span>&gt; mp = &#123;<br>		&#123;<span class="hljs-string">&quot;Monday&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;Tuesday&quot;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&quot;Wenesday&quot;</span>,<span class="hljs-number">3</span>&#125;<br>	&#125;;<br>	cout &lt;&lt; mp[<span class="hljs-string">&quot;Tuesday&quot;</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>	cout &lt;&lt; mp.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-string">&quot;Tue&quot;</span>)-&gt;first &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	cout &lt;&lt; mp.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-string">&quot;Tue&quot;</span>)-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&gt;&gt;<span class="hljs-number">2</span><br>&gt;&gt;Tuesday<br>&gt;&gt;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><br>9、加快输入输出流的速度：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>用来加快cin、cout的速率<br></code></pre></td></tr></table></figure><br>10、<code>cout &lt;&lt; x+y &lt;&lt; &#39;\n&#39; &lt;&lt; flush;</code>强行刷新缓冲区，使数据立即输出<br>11、移位运算<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">a &lt;&lt;= <span class="hljs-number">10</span>  <span class="hljs-comment">//a * 1024;</span><br>a &lt;&lt;= k   <span class="hljs-comment">//a * 2^k;</span><br>b &gt;&gt;= k   <span class="hljs-comment">//a / 2^k;</span><br>a |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>);  <span class="hljs-comment">//将a的二进制第十一位换成1，进行调节</span><br>a &amp; <span class="hljs-number">1</span> <span class="hljs-comment">// a % 2</span><br></code></pre></td></tr></table></figure></p>
<p>​    </p>
]]></content>
  </entry>
  <entry>
    <title>Latex基本操作</title>
    <url>/2022/10/04/Latex%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Latex学习一————基本结构"><a href="#Latex学习一————基本结构" class="headerlink" title="Latex学习一————基本结构"></a>Latex学习一————基本结构</h3><h4 id="1-1-主体结构"><a href="#1-1-主体结构" class="headerlink" title="1.1 主体结构"></a>1.1 主体结构</h4><p>源程序分为导言区和正文区，其中导言区设置文章的一些性质或自定义命令，选定文档类命令为<code>\documentclass&#123;article&#125;</code>，设置文章属性可以加入命令<code>\title&#123;&#125;</code>,<code>\auther&#123;&#125;</code>,<code>\date&#123;&#125;</code><br>正文区又称文稿区，设置文档环境命令<code>\begin&#123;document&#125;</code>,<code>\end&#123;document&#125;</code>,一篇文档有且只能设置一个文档环境。       </p>
<h4 id="1-2-部分命令"><a href="#1-2-部分命令" class="headerlink" title="1.2 部分命令"></a>1.2 部分命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\maketitle</span> <span class="hljs-comment">% 生成标题，用在`book/report/article`类的正文区中，而`letter`类在正文区并没有此命令。                    </span><br><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span>  <span class="hljs-comment">% 单`$`命令主要用于行内公式书写     </span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-comment">% 而双`$$`命令用于行间公式    </span><br><span class="hljs-keyword">\tableofcontents</span>  <span class="hljs-comment">% 输出文章目录       </span><br><span class="hljs-keyword">\bibliographystyle</span>   <span class="hljs-comment">% 声明参考文献的格式     </span><br><span class="hljs-keyword">\footnote</span>&#123;&#125;   <span class="hljs-comment">% 在正文后面设置脚注，花括号内的部分是命令的参数，即脚注的内容。   </span><br><span class="hljs-keyword">\emph</span>&#123;&#125;  <span class="hljs-comment">% 改变字体形状，表示强调(emphasis)的内容     </span><br><span class="hljs-keyword">\begin</span>&#123;quote&#125;<br><span class="hljs-comment">% 将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。</span><br><span class="hljs-comment">% 同时设置引用的字体</span><br><span class="hljs-keyword">\zihao</span>&#123;-5&#125;<span class="hljs-keyword">\kaishu</span>   <span class="hljs-comment">% 设置字号和字体命令  会影响后面所有文字(环境内)</span><br><span class="hljs-comment">% 注：\zihao&#123;&#125;有参数，-5即小五号</span><br><span class="hljs-keyword">\end</span>&#123;quote&#125;<br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>文章摘要环境，在<span class="hljs-keyword">\maketitle</span>之后设置<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br></code></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 导言区</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;    <span class="hljs-comment">% book,report,letter</span><br><br><span class="hljs-keyword">\title</span>&#123;My First Document&#125;<br><span class="hljs-keyword">\author</span>&#123;MarkStiff&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-comment">% 正文区(文稿区)</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>	<span class="hljs-keyword">\maketitle</span><br>	Hello World!<br>	<br>	<span class="hljs-comment">% here is my big formula</span><br>	Let <span class="hljs-built_in">$</span>f(x)<span class="hljs-built_in">$</span> be defined by the formula <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>f(x)=3x<span class="hljs-built_in">^</span>2+x-1<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> which is a polynomial of degree 2.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
<p>生成效果图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/1.png" alt=""></p>
<h3 id="Latex学习二————中文文档设置"><a href="#Latex学习二————中文文档设置" class="headerlink" title="Latex学习二————中文文档设置"></a>Latex学习二————中文文档设置</h3><h4 id="2-1-文档整体设置"><a href="#2-1-文档整体设置" class="headerlink" title="2.1 文档整体设置"></a>2.1 文档整体设置</h4><ul>
<li>可以加入<code>\usepackage&#123;ctex&#125;</code>命令使用扩展包；</li>
<li>直接设置整体文档类<code>\documentclass[UTF8]&#123;ctexart&#125;</code>,此外还有<code>ctexbook ctexrep</code>    </li>
</ul>
<p>可选参数表明中文文档的编码，主要有<code>GBK和UTF8</code>，不同<code>Latex</code>编辑器默认编码方式不同。      </p>
<h4 id="2-2-equation环境"><a href="#2-2-equation环境" class="headerlink" title="2.2 equation环境"></a>2.2 <code>equation</code>环境</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2.<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
<p>此环境命令主要是用于产生带编号的行间公式。</p>
<h4 id="2-4-章节设置"><a href="#2-4-章节设置" class="headerlink" title="2.4 章节设置"></a>2.4 章节设置</h4><p><code>\section&#123;章节标题&#125;</code>生成一节的标题   </p>
<h4 id="2-3-中文字体设置"><a href="#2-3-中文字体设置" class="headerlink" title="2.3 中文字体设置"></a>2.3 中文字体设置</h4><h5 id="字体族设置"><a href="#字体族设置" class="headerlink" title="字体族设置"></a>字体族设置</h5><p>——罗马字体、无衬线字体、打字机字体</p>
<ul>
<li>字体命令<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\textrm</span>&#123;文本&#125; <span class="hljs-comment">% 设置字体族为罗马字体</span><br><span class="hljs-keyword">\textsf</span>&#123;文本&#125;  <span class="hljs-comment">% 无衬线字体</span><br><span class="hljs-keyword">\texttt</span>&#123;文本&#125;  <span class="hljs-comment">% 打字机字体</span><br></code></pre></td></tr></table></figure></li>
<li>字体声明命令<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\rmfamily</span> 文本    <span class="hljs-comment">% 声明以后的字体使用罗马字体</span><br><span class="hljs-keyword">\sffamily</span> 文本 <span class="hljs-comment">% 无衬线字体</span><br><span class="hljs-keyword">\ttfamily</span> 文本  <span class="hljs-comment">% 打字机字体</span><br>&#123;<span class="hljs-keyword">\rmfamily</span> 文本&#125;  <span class="hljs-comment">% 使用括号限定字体声明范围</span><br></code></pre></td></tr></table></figure>
<h5 id="字体系列设置"><a href="#字体系列设置" class="headerlink" title="字体系列设置"></a>字体系列设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Pass<br></code></pre></td></tr></table></figure>
<h3 id="Latex学习三————-杂谈"><a href="#Latex学习三————-杂谈" class="headerlink" title="Latex学习三———— 杂谈"></a>Latex学习三———— 杂谈</h3><h4 id="3-1-定理环境"><a href="#3-1-定理环境" class="headerlink" title="3.1 定理环境"></a>3.1 定理环境</h4>文章定理之类的是用一类定理环境输出的，在使用之前需要在导言区做定义:<br><code>\newtheorem&#123;thm&#125;&#123;定理&#125;</code><br>定理环境有一个指定定理名字的可选参数，示例:      <figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;thm&#125;[勾股定理]<br>直角三角形斜边的平方等于两腰的平方和。<br><br>可以用符号语言表述为······<br>起源于6--7年份  <span class="hljs-comment">% 表示数字范围时可以用两个减号来输出Latex中的短横线</span><br><span class="hljs-keyword">\end</span>&#123;thm&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-数学公式"><a href="#3-2-数学公式" class="headerlink" title="3.2 数学公式"></a>3.2 数学公式</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 行间公式 行内公式 pass</span><br><span class="hljs-keyword">\angle</span> ACB = <span class="hljs-keyword">\pi</span>/2    <span class="hljs-comment">% 角符号以及使用pi命令</span><br>f<span class="hljs-built_in">_</span>pump   <span class="hljs-comment">% &#x27;_&#x27; 命令下标设置</span><br>f<span class="hljs-built_in">^</span>2      <span class="hljs-comment">% &#x27;^&#x27; 命令上标设置</span><br><span class="hljs-comment">% 注：如果上下标不止一个符号则需要用花括号进行分组</span><br>90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span>   <span class="hljs-comment">% 设置角度上标</span><br></code></pre></td></tr></table></figure>
实际效果如图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/20221006213148.png" alt=""></li>
</ul>
<h4 id="3-3-使用图表"><a href="#3-3-使用图表" class="headerlink" title="3.3 使用图表"></a>3.3 使用图表</h4><ul>
<li><p>插图功能<br>插图功能由<code>graphicx</code>宏包提供，需要在导言区进行设置<br><code>\usepackage&#123;graphicx&#125;</code><br>具体的插图命令为：<br><code>\includegraphics[width=3cm]&#123;xiantu.pdf&#125;</code><br>其中可选参数设置图片在文档中的宽度，第二个参数是图形的文件名（放在源文件所在目录）<br>使用xelatex命令编译时，支持的图形格式包括PDF、PNG、JPG、FPS等<br><strong>_图形放置_</strong><br>通常将图像放置在一个浮动体中，处于一个可以变动相对位置的环境中    </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;figure&#125;[ht]    <span class="hljs-comment">% 设置浮动体环境</span><br>	<span class="hljs-keyword">\centering</span>   <span class="hljs-comment">% 表示后面的内容居中</span><br>	<span class="hljs-keyword">\includegraphics</span>[scale=0.6]&#123;cover.jpg&#125;<br>	<span class="hljs-keyword">\caption</span>&#123;博客封面设计图&#125; <span class="hljs-comment">% 给插图加自动编号和标题</span><br>	<span class="hljs-keyword">\label</span>&#123;fig:封面图&#125;  <span class="hljs-comment">% 设置插图标签</span><br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br></code></pre></td></tr></table></figure>
<p>注：可选参数<code>ht</code>表示浮动体可以出现在环境周围的文本所在处(<code>here</code>)和一页的底部(<code>top</code>)<br>具体效果图如下：<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071411539.png" alt=""></p>
</li>
<li><p>制作表格<br>设置表格环境<code>tabular</code>：    </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|rrr|&#125;<br>	<span class="hljs-keyword">\hline</span><br>	直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边  <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>		3 <span class="hljs-built_in">&amp;</span>   4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>		5 <span class="hljs-built_in">&amp;</span>   12 <span class="hljs-built_in">&amp;</span>   13<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure>
<p>注：</p>
</li>
<li><p>可选参数<code>|rrr|</code>表示表格有三列，都是右对齐，行与行之间用<code>\\</code>隔开，列于列之间用<code>&amp;</code>隔开，表格中的横线用<code>\hline</code>绘制    </p>
</li>
<li>表格环境设置，一般表格也放置在浮动体中，即<code>table</code>环境<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\usepackage</span>&#123;float&#125;<br><span class="hljs-keyword">\begin</span>&#123;table&#125;[H] <span class="hljs-comment">% 使用H参数表示设置表格不浮动，需要在导言区添加float宏包</span><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|lll|&#125;<br>	<span class="hljs-keyword">\hline</span><br>	直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边  <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>	3 <span class="hljs-built_in">&amp;</span>   4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>	5 <span class="hljs-built_in">&amp;</span>   12 <span class="hljs-built_in">&amp;</span>   13<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<span class="hljs-comment">%</span><br><span class="hljs-keyword">\qquad</span>  <span class="hljs-comment">% 此命令可以产生两个M宽度的空格</span><br>(<span class="hljs-built_in">$</span>a<span class="hljs-built_in">^</span>2 + b<span class="hljs-built_in">^</span>2 = c<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span>)<br><span class="hljs-keyword">\end</span>&#123;table&#125;   <br></code></pre></td></tr></table></figure>
效果图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071412672.png" alt=""></li>
</ul>
<h4 id="3-4-图表引用"><a href="#3-4-图表引用" class="headerlink" title="3.4 图表引用"></a>3.4 图表引用</h4><ul>
<li>图片引用<br>根据上文插图设置的标签属性可以很容易引用图片一个示例：<code>图\ref&#123;fig:xiantu&#125;是我国古代对勾股定理的一种证明</code>。        </li>
<li>公式引用<br>公式添加标签示例:<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<span class="hljs-keyword">\label</span>&#123;eq:gougu&#125;   <span class="hljs-comment">% 设定公式标签名</span><br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
在正文中引用示例: <code>(\ref&#123;eq:gougu&#125;)</code>注意公式引用的括号要手动添加<br>另解，使用宏包<code>amsmath</code>,在导言区添加宏包，之后通过命令<code>\eqref&#123;eq:gougu&#125;</code>引用，并能自动产生括号 </li>
</ul>
<h4 id="3-5-设计文章格式"><a href="#3-5-设计文章格式" class="headerlink" title="3.5 设计文章格式"></a>3.5 设计文章格式</h4><p>一般设置文章整体格式可以借用宏包直接进行处理，现列举较为常用的文章格式宏包:<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\usepackage</span>&#123;gemetry&#125;   <span class="hljs-comment">% 设计页面尺寸宏包</span><br><span class="hljs-keyword">\geometry</span>&#123;a4paper,centering,scale=0.8&#125;  <span class="hljs-comment">% 定义A4纸大小，版心居中，宽0.8倍</span><br><br><span class="hljs-keyword">\usepackage</span>[format=hang,font=small,texfont=it]&#123;caption&#125;   <span class="hljs-comment">% 改变图表标题格式</span><br><span class="hljs-comment">% 设定图表标题悬挂对齐，整体用小字号，标题文本使用斜体（对汉字而言是楷书）</span><br><span class="hljs-keyword">\usepackage</span>[nottoc]&#123;tocbibind&#125;  <span class="hljs-comment">% 增加目录的项目</span><br><span class="hljs-comment">% 宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身</span><br></code></pre></td></tr></table></figure><br><strong>_自定义环境_</strong><br>如果需要设置特定的段落环境，可以利用已有的环境在导言区构造新的环境，以达到增加格式控制的目的<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 这里对引用(quote)环境重新设置，增加更多格式控制命令</span><br><span class="hljs-keyword">\newenvironment</span>&#123;myquote&#125;<br>	&#123;<span class="hljs-keyword">\begin</span>&#123;quote&#125;<span class="hljs-keyword">\kaishu</span><span class="hljs-keyword">\zihao</span>&#123;-5&#125;&#125;<br>	&#123;<span class="hljs-keyword">\end</span>&#123;quote&#125;&#125;<br><span class="hljs-comment">% 这里新环境由环境名字、环境开始代码和环境末尾代码三个参数，这样在导言区定义可以重复使用</span><br><span class="hljs-comment">% 使用</span><br><span class="hljs-keyword">\begin</span>&#123;myquote&#125;<br>text······<br><span class="hljs-keyword">\end</span>&#123;myquote&#125;<br></code></pre></td></tr></table></figure><br><strong>_自定义命令_</strong><br>在一些需要的地方，<code>Latex</code>给我们提供了自定义新的命令的代码，这极大地拓展了不同背景和领域使用的便利性。   </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 这里以角度上标为例</span><br><span class="hljs-keyword">\newcommand</span><span class="hljs-keyword">\degree</span>&#123;<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span>&#125;      <span class="hljs-comment">% 在导言区定义</span><br><span class="hljs-built_in">$</span>90<span class="hljs-keyword">\degree</span><span class="hljs-built_in">$</span> = <span class="hljs-built_in">$</span>90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span><span class="hljs-built_in">$</span>  <br></code></pre></td></tr></table></figure>
<p>插图版式调整后效果:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071440767.png" alt=""></p>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex组织文本</title>
    <url>/2022/10/07/Latex%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%84%E7%BB%87%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="一、标点符号"><a href="#一、标点符号" class="headerlink" title="一、标点符号"></a>一、标点符号</h3><h4 id="1-1-引号"><a href="#1-1-引号" class="headerlink" title="1.1 引号"></a>1.1 引号</h4><p><code>Latex</code>使用<code>‘’</code>来表示引号，如果遇到连续使用单引号和双引号的情形，则需要使用<code>\,</code>命令隔开，会产生很小的间距</p>
<h4 id="1-2-符号"><a href="#1-2-符号" class="headerlink" title="1.2 符号-"></a>1.2 符号<code>-</code></h4><ul>
<li>数学减号</li>
<li>单独使用时表示连字符</li>
<li>两个连用时，是<code>en dash</code>，表示数字范围</li>
<li>三个连用时，是<code>em dash</code>，即破折号</li>
</ul>
<p><code>~</code>符号命令：数学模式<code>$\sim$</code>    </p>
<h4 id="1-3-省略号"><a href="#1-3-省略号" class="headerlink" title="1.3 省略号"></a>1.3 省略号</h4><p>西文省略号: <code>\ldots</code>或者<code>\dots</code>，在句中使用时直接命令，而在句末使用时要把省略号放进数学模式中。<br>中文写作使用全角标点，一般由<code>xsCJK</code>宏包控制，可以使用<code>\punctstyle&#123;&#125;</code>命令修改，<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071546897.png" alt=""></p>
<h4 id="1-4-空格"><a href="#1-4-空格" class="headerlink" title="1.4 空格"></a>1.4 空格</h4><p>以字母命名的宏后面空格会被自动忽略掉，此时可以使用<code>\</code>命令添加<br>或者添加一个空分组<code>&#123;&#125;</code>分隔，或者<code>&#123;\TeX&#125;</code>包裹进来<br><strong>不可打断的空格(带子)</strong><br>用<code>~</code>表示，<code>function ~$f(x)$</code><br>西方文体中，句末标点和缩写标点问题<br><code>Latex</code>默认在大写字母的点看作缩写标记，小写字母后面的点看作句子结束而设置不同的点间隔；但当特殊情况时需要明确指定具体用法，示例:<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">Tinker et al.<span class="hljs-keyword">\ </span>made the double play.  <span class="hljs-comment">% &#x27;\空格&#x27;命令放在&#x27;.&#x27;后直接分隔单词</span><br><br>Tinker et al,made the double play. <span class="hljs-comment">% 一般情况下标点后需加空格</span><br><br><span class="hljs-keyword">\frenchspacing</span>  <span class="hljs-comment">% 禁止标点后的额外间距</span><br>Roman number XII<span class="hljs-keyword">\@</span>. Yes.  <span class="hljs-comment">% &#x27;\@&#x27;命令放在&#x27;.&#x27;前面只处理&#x27;.&#x27;是句子结束点，之后再添加空格表示正常的句号标点</span><br></code></pre></td></tr></table></figure></p>
<h4 id="1-5-幻影空格"><a href="#1-5-幻影空格" class="headerlink" title="1.5 幻影空格"></a>1.5 幻影空格</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 幻影空格实际上起到占位作用，接受一个参数，生成与参数内容大小一样的空盒子</span><br><span class="hljs-comment">% 类似的还有\hphantom和\vphantom表示水平竖直方向上的幻影</span><br>MarkStiff<span class="hljs-keyword">\phantom</span>&#123;神奇&#125;速速隐形<br><br>MarkStiff神奇速速显形<br></code></pre></td></tr></table></figure>
<h4 id="1-6-换行"><a href="#1-6-换行" class="headerlink" title="1.6 换行"></a>1.6 换行</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\\</span>[2cm]  <span class="hljs-comment">% 命令直接另起一行，上一行保持原样,可选参数设置换行后增加的额外垂直距离</span><br><span class="hljs-keyword">\linebreak</span> <span class="hljs-comment">% 命令指定一行的断点，上一行仍按完整一行散开对齐</span><br></code></pre></td></tr></table></figure>
<h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><h4 id="2-1-字体族格式命令"><a href="#2-1-字体族格式命令" class="headerlink" title="2.1 字体族格式命令"></a>2.1 字体族格式命令</h4><p>带参数命令主要用于少量字体的更换，三种字体族对应的带参数命令，而声明命令主要用偶遇分组或环境中字体的整体更换.<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textrm</span>&#123;Roman font family&#125;<br>	<span class="hljs-keyword">\textsf</span>&#123;Sans serif font family&#125;<br>	<span class="hljs-keyword">\texttt</span>&#123;Typewriter font family&#125;<br>	<br>声明命令<br>	&#123;<span class="hljs-keyword">\rmfamily</span> Roman font family&#125;<br>	&#123;<span class="hljs-keyword">\sffamily</span> Sans serif font family&#125;<br>	&#123;<span class="hljs-keyword">\ttfamily</span> Typewriter font family&#125;<br></code></pre></td></tr></table></figure><br>效果图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071651052.png" alt=""></p>
<h4 id="2-2-字体形状命令"><a href="#2-2-字体形状命令" class="headerlink" title="2.2 字体形状命令"></a>2.2 字体形状命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textup</span>&#123;Upright shape&#125;  <span class="hljs-comment">% 直立形状</span><br>	<span class="hljs-keyword">\textit</span>&#123;Italic shape&#125; <span class="hljs-comment">% 意大利形状</span><br>	<span class="hljs-keyword">\textsl</span>&#123;Slanted shape&#125; <span class="hljs-comment">% 倾斜形状</span><br>	<span class="hljs-keyword">\textsc</span>&#123;SMALL CAPITALS SHAPE&#125; <span class="hljs-comment">% 小型大写形状</span><br><br>声明命令<br>	&#123;<span class="hljs-keyword">\upshape</span> Upright shape&#125;<br>	&#123;<span class="hljs-keyword">\itshape</span> Italic shape&#125;<br>	&#123;<span class="hljs-keyword">\slshape</span> Slanted shape&#125;<br>	&#123;<span class="hljs-keyword">\scshape</span> SMALL CAPITALS SHAPE&#125;<br></code></pre></td></tr></table></figure>
<p>效果图：<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071650619.png" alt=""><br>倾斜形状一般是对符号直接倾斜产生的，而通常的“斜体”往往指意大利形状，数学公式的字体一般就使用意大利形状</p>
<h4 id="2-3-字体系列命令"><a href="#2-3-字体系列命令" class="headerlink" title="2.3 字体系列命令"></a>2.3 字体系列命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textmd</span>&#123;Medium series&#125; <span class="hljs-comment">% 中等字体，正文默认使用此系列</span><br>	<span class="hljs-keyword">\textbf</span>&#123;Bold extended series&#125; <span class="hljs-comment">% 加宽加粗</span><br>	<br>声明命令<br>	&#123;<span class="hljs-keyword">\mdseries</span> Medium series&#125; 	<br>	&#123;<span class="hljs-keyword">\bfseries</span> Bold extended series&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-字体坐标"><a href="#2-4-字体坐标" class="headerlink" title="2.4 字体坐标"></a>2.4 字体坐标</h4><p>经上文介绍了字体的三个特征，综合起来构成了确定一种字体的三维坐标：族、形状、系列，不同组合会产生不同的字体效果。<br>具体组合效果图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071702667.png" alt=""><br><strong>_恢复普通字体_</strong><br>在复杂的字体环境中，恢复普通字体就显得十分重要了。<br><code>\textnormal&#123;文字&#125; % 带参数命令</code><br><code>&#123;\normalfont 文字&#125; % 声明命令</code><br><strong>_斜体校正_</strong><br>在使用斜体声明<code>\itshape、\slshape</code>时，最后一个倾斜的字体会超过右边界，使得间距过近；<br>而用带参数命令<code>\textit、\textsl</code>时，可以自动修正这个距离，也可以手工使用<code>\/</code>命令进行校正。<br><strong>_禁止校正_</strong><br>有时对于倾斜校正是不必要的，则应关闭带参数倾斜命令的自动校正功能:<br><code>\textit&#123;M\nocorr&#125;M</code> 通过添加命令<code>\nocorr</code>命令来关闭自动校正    </p>
<h4 id="2-5-中文字体族"><a href="#2-5-中文字体族" class="headerlink" title="2.5 中文字体族"></a>2.5 中文字体族</h4><p>对于中文字体，一般只使用不同的字体族进行区分，选择中文字体族使用<code>\CJKfamily</code>命令<br>在<code>ctex</code>宏包及文档下有一些预定义，默认情况下配置了四种字体族：<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">&#123;<span class="hljs-keyword">\heiti</span> 这是黑体&#125;<br>&#123;<span class="hljs-keyword">\songti</span> 这是宋体&#125;<br>&#123;<span class="hljs-keyword">\kaishu</span> 这是楷书&#125;<br>&#123;<span class="hljs-keyword">\fangsong</span> 这是仿宋&#125;<br></code></pre></td></tr></table></figure><br><strong>_组合字体_</strong><br><code>ctex</code>宏包及文档类也定义了一些组合字体，可以让中文也具备使用粗体和意大利体功能，并且重定义<code>\rmfamily</code>使它同时对中文起作用<br>默认的中文字体是<code>rm</code>，正常字体是宋体，粗体是黑体，意大利体是楷体 </p>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex篇章结构</title>
    <url>/2022/10/16/Latex%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一、构建小节"><a href="#一、构建小节" class="headerlink" title="一、构建小节"></a>一、构建小节</h3><ul>
<li>小节<code>\section&#123;&#125;</code></li>
<li>子小节<code>\subsection&#123;&#125;</code></li>
<li>子子小节<code>\subsubsection&#123;&#125;</code></li>
<li>生成目录<code>\tableofcontents</code></li>
<li>换行<code>\\</code>或者<code>\par</code>:产生新的段落<br>具体效果如下图：<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210162213125.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210162214021.png" alt=""><h3 id="二、章节大纲"><a href="#二、章节大纲" class="headerlink" title="二、章节大纲"></a>二、章节大纲</h3>命令<code>\chapter&#123;&#125;</code><br>在使用之前需要更换文本类型，设置<code>\documentclass&#123;ctexbook&#125;</code><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210162238918.png" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB基本操作学习</title>
    <url>/2022/03/27/MATLAB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="MATLAB基本操作学习"><a href="#MATLAB基本操作学习" class="headerlink" title="MATLAB基本操作学习"></a>MATLAB基本操作学习</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><code class="hljs MATLAB">• 清除变量：clear <span class="hljs-built_in">pi</span> /clearvars <span class="hljs-built_in">pi</span> <span class="hljs-built_in">inf</span>   /恢复默认变量<br>• 判别是否是关键字    iskeyword(<span class="hljs-string">&#x27;for&#x27;</span>)<br>• 数据输出格式<br>Format <span class="hljs-built_in">rat</span> 分子格式<br>Format compact 压缩格式，不显示空白行<br>• 常用函数<br>指数函数：<span class="hljs-built_in">exp</span>      以<span class="hljs-number">2</span>对数：<span class="hljs-built_in">log2</span>     自然对数：<span class="hljs-built_in">log</span><br>取整: 四舍五入 <span class="hljs-built_in">round</span>  正无穷方向取整  <span class="hljs-built_in">ceil</span> 负无穷方向取整  <span class="hljs-built_in">floor</span>  向零方向取整 <span class="hljs-built_in">fix</span> <br>求余函数：<span class="hljs-built_in">rem</span>     取模函数：<span class="hljs-built_in">mod</span><br>反正弦：<span class="hljs-built_in">asin</span><br>求复数实部：<span class="hljs-built_in">real</span>       求复数虚部：<span class="hljs-built_in">imag</span>        求共轭复数：<span class="hljs-built_in">conj</span><br>求平均值：<span class="hljs-built_in">mean</span>    标准差：std     方差：var     协方差：cov<br>相关系数：corrcoef                极差：range      <br>符号函数：<span class="hljs-built_in">sign</span>    例<span class="hljs-built_in">sign</span>(x)求 x 中元素的符号<br>• 规模化定义向量<br>X = 初值：步长：终值/初值：终值<br>X = <span class="hljs-built_in">linspace</span>(初值，终值，向量长度）  用来生成等间隔向量    <br>• 向量与矩阵的转换<br>X = A(:)            <span class="hljs-comment">% 矩阵A转为列向量x</span><br>A = <span class="hljs-built_in">reshape</span>(x, [m, n])    <span class="hljs-comment">% 将长度为m*n的向量x转换为m行n列矩阵</span><br>• 按指定阵列复制矩阵<br>B = <span class="hljs-built_in">repmat</span>(A,[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])      <span class="hljs-comment">% 复制矩阵A按行方向复制两次，列方向复制3次</span><br>• 复数矩阵<br>C = <span class="hljs-built_in">complex</span>(a, b)            <span class="hljs-comment">% 以a为实部，b为虚部生成复数矩阵   a, b 均为矩阵</span><br>• 符号矩阵<br>Y = sym(y)  <span class="hljs-comment">% 将数值矩阵y转换为符号矩阵Y</span><br>Z = sym(<span class="hljs-string">&#x27;a%d%d&#x27;</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])     <span class="hljs-comment">% 其中%d、%d按照下标进行赋值</span><br>特殊矩阵    <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(A)）生成与A相同大小的零矩阵<br>对角阵  <span class="hljs-built_in">diag</span>      X  = <span class="hljs-built_in">diag</span>(v,k)    以向量v为第k个对角线生成对角矩阵<br>X  = <span class="hljs-built_in">diag</span>(v)  以v为主对角线生成对角阵<br>v  = <span class="hljs-built_in">diag</span>(X, k)   返回矩阵X的第k条对角线上元素   省略k时默认为主对角线<br>• 元胞数组<br>&lt;<span class="hljs-number">1</span>&gt; 直接用花括号赋值创建；&lt;<span class="hljs-number">2</span>&gt; cell(m, n, p···)创建空元胞数组<br>访问元胞：C(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>)           访问元胞中的元素：C&#123;I,<span class="hljs-built_in">j</span>&#125;          celldisp显示元胞数组里面所有内容<br>• 结构体数组<br>&lt;<span class="hljs-number">1</span>&gt; 直接赋值定义  struct1(n).attris           指定第n个结构体数组单元的各属性<br>&lt;<span class="hljs-number">2</span>&gt; struct函数构造    s  =struct(<span class="hljs-string">&#x27;field1&#x27;</span>, values1, <span class="hljs-string">&#x27;field2&#x27;</span>, values2····)<br>Example: s  = struct(<span class="hljs-string">&#x27;name&#x27;</span>, &#123;<span class="hljs-string">&#x27;Mark&#x27;</span>, <span class="hljs-string">&#x27;Lucy&#x27;</span>&#125;, <span class="hljs-string">&#x27;age&#x27;</span>, &#123;<span class="hljs-number">31</span>,<span class="hljs-number">22</span>&#125;)<br>• 数组转换<br>str2func - 根据字符向量构造函数句柄  <br>• 表格型数组（Table Class)<br>工作区的变量定义为表格型<br>T = <span class="hljs-built_in">table</span>(Age, Height, Weight, Blood, <span class="hljs-string">&#x27;RowNames&#x27;</span>, Name)      (其中各变量均为向量)<br>访问 T.Height<br>• 逻辑运算<br>或运算：A|B   对应元素非零为<span class="hljs-number">1</span>否则为<span class="hljs-number">0</span>得到一个布尔矩阵<br>与运算：A&amp;B 均非零<br>非运算：~A 非零为零，零为<span class="hljs-number">1</span><br>异或运算：xor(A,B)    均为零或均非零为零否则为<span class="hljs-number">1</span><br>判断逻辑运算：A||B   判断A或B是否为零矩阵    A&amp;&amp;B<br>• 逆矩阵   Ai = inv(A)    <span class="hljs-comment">% 求A的逆矩阵</span><br>[V, D] = eig(A)      <span class="hljs-comment">% 求数值矩阵A的特征值D和特征向量矩阵V  （D为对角阵）</span><br>矩阵的迹  t  =trace(A)<br>矩阵的秩  r  = rank(A)<br></code></pre></td></tr></table></figure>
<p><strong>附录——常用数组转换函数</strong><br><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172805394-926335148.png" alt=""></p>
<p>​    </p>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Codetest</title>
    <url>/2022/10/02/code/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">12</span>];<br>    <span class="hljs-type">char</span> axs;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>* next;<br>&#125;Stu;<br>Stu* head;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stu_read</span><span class="hljs-params">(Stu* &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Stu* temp = (Stu*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Stu));<br>    <span class="hljs-keyword">if</span> (!temp) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    cin &gt;&gt; temp-&gt;name;<br>    <span class="hljs-keyword">if</span> (temp-&gt;name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>        <span class="hljs-built_in">free</span>(temp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    cin &gt;&gt; temp-&gt;num &gt;&gt; temp-&gt;axs;<br>    p-&gt;next = temp;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    p = p-&gt;next;<br>    head-&gt;num++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search_stu</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    Stu* p = head;<br>    <span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next-&gt;num == m) &#123;<br>            Stu* q = p-&gt;next;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            <span class="hljs-built_in">free</span>(q);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stu_print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Stu* p = head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        cout &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;axs &lt;&lt; endl;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = (Stu*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Stu));<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;num = <span class="hljs-number">0</span>;<br>    Stu* temp = head;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Stu_read</span>(temp) == <span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> Out_stu = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; Out_stu;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search_stu</span>(Out_stu)) <span class="hljs-built_in">Stu_print</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>code</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>不等式</title>
    <url>/2022/10/20/%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第六讲、不等式"><a href="#第六讲、不等式" class="headerlink" title="第六讲、不等式"></a>第六讲、不等式</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210201907542.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210201908392.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210201908435.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210201909712.png" alt=""></p>
<h3 id="六、典型例题"><a href="#六、典型例题" class="headerlink" title="六、典型例题"></a>六、典型例题</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/10/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树（Binary-Tree-三种遍历算法"><a href="#二叉树（Binary-Tree-三种遍历算法" class="headerlink" title="二叉树（Binary Tree)三种遍历算法"></a>二叉树（Binary Tree)三种遍历算法</h3><p>基于链表结构实现的二叉树又称二叉链表，本文主要介绍二叉树的存储以及先序遍历、中序遍历和后序遍历三种遍历方式的递归和非递归算法：    </p>
<h4 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h4><p>二叉树抽象数据类型定义—— <strong>基于链表实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//----------二叉树的二叉链表存储表示--------------</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> TElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><span class="hljs-comment">// 树节点定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>* lchild, * rchild;<br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><br>二叉树递归构造： 通过指定按照满二叉树的节点输入顺序进行输入，对空树以 ‘.’ 表示<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*---------------------二叉树创建函数------------------*/</span><br><span class="hljs-function">Status <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree&amp; T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归读入二叉树的各元素，因此最开始的T还是指向根节点</span><br>    TElemType ch;<br>    cin &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(T = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        T-&gt;data = ch;          <span class="hljs-comment">// 生成根节点</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);   <span class="hljs-comment">// 递归构造左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);   <span class="hljs-comment">// 递归构造右子树</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="二叉树操作算子"><a href="#二叉树操作算子" class="headerlink" title="二叉树操作算子"></a>二叉树操作算子</h4><p>对二叉树的遍历往往是一个广泛的概念，遍历是对二叉树的每一个节点做一系列操作，其中最简单的就是输出节点数据域，这里只是以输出函数为例说明问题。<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">TreeTransOperator</span><span class="hljs-params">(TElemType e)</span>    <span class="hljs-comment">// 二叉树遍历算子</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对数据元素操作的应用函数</span><br>    cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>总体而言，递归算法较为简单，只需更换二叉树节点三部分的顺序即可，但需要注意的是左子树始终在右子树之前遍历； </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//--------------------递归遍历算法-------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTranRecursion</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*---------------先序遍历二叉树的递归算法-------------------*/</span><br>    <span class="hljs-comment">// 采用二叉链表存储结构，Visit是对数据元素操作应用的函数</span><br>    <span class="hljs-comment">// 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层</span><br>    <span class="hljs-keyword">if</span> (T) &#123;   <span class="hljs-comment">// T所指节点非空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Visit</span>(T-&gt;data)) &#123;      <span class="hljs-comment">// 调用操作函数，Visit采用函数指针，指向操作函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PreOrderTranRecursion</span>(T-&gt;lchild, Visit)) &#123;    <span class="hljs-comment">// 递归调用：Visit所指函数也进行递归</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PreOrderTranRecursion</span>(T-&gt;rchild, Visit))  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">InOrderTranRecursion</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*---------------中序遍历二叉树的递归算法-------------------*/</span><br>    <span class="hljs-comment">// 采用二叉链表存储结构，Visit是对数据元素操作应用的函数</span><br>    <span class="hljs-comment">// 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层</span><br>    <span class="hljs-keyword">if</span> (T) &#123;   <span class="hljs-comment">// T所指节点非空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">InOrderTranRecursion</span>(T-&gt;lchild, Visit)) &#123;      <span class="hljs-comment">// 调用操作函数，Visit采用函数指针，指向操作函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Visit</span>(T-&gt;data)) &#123;    <span class="hljs-comment">// 递归调用：Visit所指函数也进行递归</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">InOrderTranRecursion</span>(T-&gt;rchild, Visit))  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">PostOrderTranRecursion</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*---------------后序遍历二叉树的递归算法-------------------*/</span><br>    <span class="hljs-comment">// 采用二叉链表存储结构，Visit是对数据元素操作应用的函数</span><br>    <span class="hljs-comment">// 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层</span><br>    <span class="hljs-keyword">if</span> (T) &#123;   <span class="hljs-comment">// T所指节点非空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PostOrderTranRecursion</span>(T-&gt;lchild, Visit)) &#123;      <span class="hljs-comment">// 调用操作函数，Visit采用函数指针，指向操作函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PostOrderTranRecursion</span>(T-&gt;rchild, Visit)) &#123;    <span class="hljs-comment">// 递归调用：Visit所指函数也进行递归</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Visit</span>(T-&gt;data))  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//--------------------递归遍历算法-------------------------//  </span><br></code></pre></td></tr></table></figure>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><p>对于递归算法而言，当数据量比较大时，程序的时间复杂度往往较高，不易于直接使用；一个好的处理方式是，将递归函数转换为循环结构进行求解，而通过栈来模拟递归机理；<br>这里给出一个自定义栈模板类的程序，作为非递归算法的数据存储结构：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-comment">//-----------------------自定义栈模板类--------------</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-comment">// 抽象数据类型定义</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TElemType</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span> *next, *pre;    <span class="hljs-comment">// 基于双向链表模拟栈</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TElemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mystack</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&lt;TElemType&gt; *base,*top;   <span class="hljs-comment">// 栈底和栈顶指针</span><br>        <span class="hljs-function">Status <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(!(base = (<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            top = base;    <span class="hljs-comment">// 判断栈空标志</span><br>            base-&gt;data = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 栈顶结点数据域记录栈中元素数</span><br>            base-&gt;next = <span class="hljs-literal">NULL</span>;<br>            base-&gt;pre = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(TElemType e)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&lt;TElemType&gt; *stemp;<br>            <span class="hljs-keyword">if</span>(!(stemp=(<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            top-&gt;next = stemp;<br>            stemp-&gt;data = e;<br>            stemp-&gt;pre = top;<br>            stemp-&gt;next = <span class="hljs-literal">NULL</span>;<br>            top = top-&gt;next; <span class="hljs-comment">// 移动top指针始终位于栈顶</span><br><br>            base-&gt;data++;      <span class="hljs-comment">// 栈元素计数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(TElemType &amp;e)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(top == base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 栈空</span><br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&lt;TElemType&gt; *stemp = top;<br>            top = top-&gt;pre;<br>            top-&gt;next = <span class="hljs-literal">NULL</span>;<br>            e = stemp-&gt;data;<br>            <span class="hljs-built_in">free</span>(stemp);<br><br>            base-&gt;data--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function">Status <span class="hljs-title">Top</span><span class="hljs-params">(TElemType &amp;p)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(top == base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = top-&gt;data;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-function">Status <span class="hljs-title">Empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(top == base) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> base-&gt;data;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><br>有了遍历所依赖的数据栈结构，那么便可以通过模拟递归的机理来进行处理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//--------------------非递归遍历算法-------------------------//</span><br><span class="hljs-comment">//---------------------先序遍历二叉树------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTranverse_1</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先序遍历二叉树T的非递归算法一</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建并初始化遍历二叉链表所需要的栈</span><br>    S.<span class="hljs-built_in">Push</span>(T);    <span class="hljs-comment">// 根指针进栈</span><br>    BiTree p;     <span class="hljs-comment">// 创建二叉树游标指针</span><br>    <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">Top</span>(p) &amp;&amp; p) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            S.<span class="hljs-built_in">Push</span>(p-&gt;lchild);<br>        &#125;<br>        S.<span class="hljs-built_in">Pop</span>(p);    <span class="hljs-comment">// 将向左尽头的空指针弹出</span><br>        <span class="hljs-keyword">if</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>            S.<span class="hljs-built_in">Pop</span>(p);   <span class="hljs-comment">// 根节点出栈</span><br>            S.<span class="hljs-built_in">Push</span>(p-&gt;rchild);   <span class="hljs-comment">// 遍历后转向</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">PreOrderTranverse_2</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先序遍历二叉树T非递归算法二</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建遍历二叉链表所需要的栈</span><br>    BiTree p = T;<br>    <span class="hljs-keyword">while</span> (p || !S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            S.<span class="hljs-built_in">Push</span>(p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 遍历左子树,当p=NULL时未进栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S.<span class="hljs-built_in">Pop</span>(p);<br>            p = p-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//---------------------中序遍历二叉树------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">InOrderTranverse_1</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 中序遍历二叉树T的非递归算法一</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建并初始化遍历二叉链表所需要的栈</span><br>    S.<span class="hljs-built_in">Push</span>(T);    <span class="hljs-comment">// 根指针进栈</span><br>    BiTree p;     <span class="hljs-comment">// 创建二叉树游标指针</span><br>    <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">Top</span>(p) &amp;&amp; p) S.<span class="hljs-built_in">Push</span>(p-&gt;lchild);   <span class="hljs-comment">// 向左走到尽头</span><br>        S.<span class="hljs-built_in">Pop</span>(p);    <span class="hljs-comment">// 将向左尽头的空指针弹出</span><br>        <span class="hljs-keyword">if</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;    <br>            S.<span class="hljs-built_in">Pop</span>(p);   <span class="hljs-comment">// 根节点出栈</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//遍历</span><br>            S.<span class="hljs-built_in">Push</span>(p-&gt;rchild);   <span class="hljs-comment">// 遍历后转向</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InOrderTranverse_2</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 中序遍历二叉树T非递归算法二</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建遍历二叉链表所需要的栈</span><br>    BiTree p = T;<br>    <span class="hljs-keyword">while</span> (p || !S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            S.<span class="hljs-built_in">Push</span>(p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 遍历左子树</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S.<span class="hljs-built_in">Pop</span>(p);<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//---------------------后序遍历二叉树------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTranverse_1</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 后序遍历二叉树T的非递归算法一</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建并初始化遍历二叉链表所需要的栈</span><br>    S.<span class="hljs-built_in">Push</span>(T);    <span class="hljs-comment">// 根指针进栈</span><br>    BiTree p,lastp = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// 创建二叉树游标指针</span><br>    <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">Top</span>(p) &amp;&amp; p) S.<span class="hljs-built_in">Push</span>(p-&gt;lchild);   <span class="hljs-comment">// 向左走到尽头</span><br>        S.<span class="hljs-built_in">Pop</span>(p);    <span class="hljs-comment">// 将向左尽头的空指针弹出</span><br>        <span class="hljs-keyword">if</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>            S.<span class="hljs-built_in">Top</span>(p);   <span class="hljs-comment">// 获取根节点 </span><br>            <span class="hljs-keyword">if</span> (p-&gt;rchild == <span class="hljs-literal">NULL</span>||p-&gt;rchild == lastp) &#123;   <span class="hljs-comment">// 节点信息无用时直接出栈</span><br>                S.<span class="hljs-built_in">Pop</span>(p);  <span class="hljs-comment">// 此时结点才可出栈</span><br>                lastp = p;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//遍历</span><br>                S.<span class="hljs-built_in">Push</span>(<span class="hljs-literal">NULL</span>);       <span class="hljs-comment">//保证返回上层结点而不是下一轮继续向左走</span><br>            &#125;<span class="hljs-keyword">else</span> S.<span class="hljs-built_in">Push</span>(p-&gt;rchild);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">PostOrderTranverse_2</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 后序遍历二叉树T非递归算法二</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建遍历二叉链表所需要的栈</span><br>    BiTree p = T,lastp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p || !S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            S.<span class="hljs-built_in">Push</span>(p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 遍历左子树,当p=NULL时未进栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S.<span class="hljs-built_in">Top</span>(p);<br>            <span class="hljs-keyword">if</span> (p-&gt;rchild == <span class="hljs-literal">NULL</span> || p-&gt;rchild == lastp) &#123;<br>                S.<span class="hljs-built_in">Pop</span>(p);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                lastp = p;<br>                p = <span class="hljs-literal">NULL</span>;          <span class="hljs-comment">// 往回溯，置于NULL</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> p = p-&gt;rchild;        <span class="hljs-comment">// 控制右移转向</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>```     <br><br><br>#### 主函数设定   <br>为了直观的观察遍历结果，主函数设定一些输出参数：              <br>``` C++<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree T;    <span class="hljs-comment">// 构造一棵二叉树</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input binary tree elements in order: (note: &#x27;.&#x27; means empty tree)\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateBiTree</span>(T)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Space allocate error!\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;------------------Binary Recursion Traverse----------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Binary Tree First Order Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">PreOrderTranRecursion</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Middle Order Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">InOrderTranRecursion</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Post Order Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">PostOrderTranRecursion</span>(T, TreeTransOperator);<br><br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;------------------Binary NonRecursion Traverse-------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Binary Tree First Order Traverse 1:\n&quot;</span>;<br>    <span class="hljs-built_in">PreOrderTranverse_1</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree First Order Traverse 2:\n&quot;</span>;<br>    <span class="hljs-built_in">PreOrderTranverse_2</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Middle Order Traverse 1:\n&quot;</span>;<br>    <span class="hljs-built_in">InOrderTranverse_1</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Middle Order Traverse 2:\n&quot;</span>;<br>    <span class="hljs-built_in">InOrderTranverse_2</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Post Order Traverse 1:\n&quot;</span>;<br>    <span class="hljs-built_in">PostOrderTranverse_1</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Post Order Traverse 2:\n&quot;</span>;<br>    <span class="hljs-built_in">PostOrderTranverse_2</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">One Example:</span><br><span class="hljs-comment">Input binary tree elements in order: (note: &#x27;.&#x27; means empty tree)</span><br><span class="hljs-comment">A B C . . D E . G . . F . . .</span><br><span class="hljs-comment">------------------Binary Recursion Traverse----------------------</span><br><span class="hljs-comment">Binary Tree First Order Traverse:</span><br><span class="hljs-comment">A B C D E G F</span><br><span class="hljs-comment">Binary Tree Middle Order Traverse:</span><br><span class="hljs-comment">C B E G D F A</span><br><span class="hljs-comment">Binary Tree Post Order Traverse:</span><br><span class="hljs-comment">C G E F D B A</span><br><span class="hljs-comment">------------------Binary NonRecursion Traverse-------------------</span><br><span class="hljs-comment">Binary Tree First Order Traverse 1:</span><br><span class="hljs-comment">A B C D E G F</span><br><span class="hljs-comment">Binary Tree First Order Traverse 2:</span><br><span class="hljs-comment">A B C D E G F</span><br><span class="hljs-comment">Binary Tree Middle Order Traverse 1:</span><br><span class="hljs-comment">C B E G D F A</span><br><span class="hljs-comment">Binary Tree Middle Order Traverse 2:</span><br><span class="hljs-comment">C B E G D F A</span><br><span class="hljs-comment">Binary Tree Post Order Traverse 1:</span><br><span class="hljs-comment">C G E F D B A</span><br><span class="hljs-comment">Binary Tree Post Order Traverse 2:</span><br><span class="hljs-comment">C G E F D B A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治与倍增</title>
    <url>/2022/05/03/%E5%88%86%E6%B2%BB%E4%B8%8E%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<hr>
<h4 id="Double-pow-double-x-double-y"><a href="#Double-pow-double-x-double-y" class="headerlink" title="Double pow(double x, double y)"></a><code>Double pow(double x, double y)</code></h4><h4 id="xxxxxxxxxx-passPython"><a href="#xxxxxxxxxx-passPython" class="headerlink" title="xxxxxxxxxx     passPython"></a>xxxxxxxxxx     passPython</h4><p>倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂度的要求 ,那么我们就可以通过成倍的增长,只递推状态空间中在 2 的整数次幂位置上的值作为代表 。当需要其他位置上的值时,我们只需要通过” 任意整数可以表示成若干个2的次幂项的和 “ 这一性质<code>(13 = 2^3 + 2^2 +2^0)</code>, 使用之前求出的代表值拼成所需的值。<br>核心思想：不断以2的次幂的跨度向前试探，行进跨度，不行就降幂，迭代可以表示任意整数</p>
<h4 id="倍增主要应用："><a href="#倍增主要应用：" class="headerlink" title="倍增主要应用："></a>倍增主要应用：</h4><p><code>LCA(least common ancestors)</code>:最近公共祖先<br>在有根树中，找出某两个结点u和v最近的公共祖先。<br><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929170840386-1257726897.png" alt=""><br>在寻找两个节点的公共祖先时，按2的指数来跳，并且从大到小，…..32, 16, 8 , 4 , 2, 1 【从大到小试探】     </p>
<h4 id="数据预处理："><a href="#数据预处理：" class="headerlink" title="数据预处理："></a>数据预处理：</h4><p>处理结点的深度、父节点、以及2i级的祖先<br><strong>开辟数组：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">&lt;<span class="hljs-number">1</span>&gt;  depth数组是记录每个节点的深度        <br>&lt;<span class="hljs-number">2</span>&gt;  fa[i][j]是指节点 i 的 <span class="hljs-number">2</span>j 级的祖先的编号      <br>&lt;<span class="hljs-number">3</span>&gt; lg数组是常数优化的数组，存的是log2N+<span class="hljs-number">1</span>的值，注意用的时候要<span class="hljs-number">-1</span>，开始之前先初始化一下，这样直接调用可以优化节约时间其中初始化的方法：l g [ i ] = l g [ i − <span class="hljs-number">1</span> ] + ( <span class="hljs-number">1</span> &lt; &lt; l g [ i − <span class="hljs-number">1</span> ] = = i ) lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i)lg[i]=lg[i−<span class="hljs-number">1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i−<span class="hljs-number">1</span>]==i)，自己手算一下很清楚的（lg[<span class="hljs-number">1</span>~<span class="hljs-number">10</span>]为<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>，应该很好懂吧）   <br></code></pre></td></tr></table></figure><br><strong>手写对数运算lg2[i]:</strong>     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n)<span class="hljs-comment">//预处理一下 </span><br>lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-comment">//可以学习宏定义简便写法</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p&lt;&lt;1)  <span class="hljs-comment">//取半</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p&lt;&lt;1|1)   <span class="hljs-comment">//取半加一</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l+r)/2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> over(i,s,t) for(register long long i=s;i&lt;=t;++i)   <span class="hljs-comment">//循环的简写 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lver(i,t,s) for(register long long i=t;i&gt;=s;--i)</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<span class="hljs-comment">//全用ll可能会MLE或者直接WA,试着改成int看会不会A</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">500007</span>;<br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">1e9</span>+<span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS=<span class="hljs-number">1e-10</span>;<span class="hljs-comment">//-10次方约等于趋近为0</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi=<span class="hljs-number">3.1415926535897</span>;<br>ll n,m;<br><span class="hljs-comment">//前向星写法的数据结构实现：</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	ll u,v,nex;<br>&#125;e[N&lt;&lt;<span class="hljs-number">1</span>];<br>ll head[N],cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll u,ll v)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++cnt].v=v;    <span class="hljs-comment">//记录边的终点</span><br>	e[cnt].u=u;<span class="hljs-comment">//没什么用，还白占空间</span><br>	e[cnt].nex=head[u];     <span class="hljs-comment">//以u为起点的上一条边，往往更喜欢写做pre</span><br>	head[u]=cnt;    <span class="hljs-comment">//更新以u为起点的上一条边</span><br>&#125;<br>ll depth[N],fa[N][<span class="hljs-number">30</span>],lg[N],s,x,y;<br><br><span class="hljs-comment">/*dfs函数的作用就是更新该点的所有祖先的fa数组，并通过递归把</span><br><span class="hljs-comment">该节点的所有的子节点和该节点一样去更新*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll now,ll fath)</span><span class="hljs-comment">//子节点和父节点</span></span><br><span class="hljs-function"></span>&#123;<br>	fa[now][<span class="hljs-number">0</span>]=fath;<span class="hljs-comment">//更新一下fa数组，2^0=1就是父节点</span><br>	depth[now]=depth[fath]+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新深度，递归的思想</span><br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,lg[depth[now]]<span class="hljs-number">-1</span>)<br>		fa[now][i]=fa[fa[now][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>		<span class="hljs-comment">/*更新now的所有 2^i 级的祖先。先找到now的2^(i-1)级祖先，再往上找</span><br><span class="hljs-comment">		该祖先的2^(i-1)级祖先，就是now的2^i祖先，必须一节一节地往上搜*/</span><br>	<span class="hljs-keyword">for</span>(ll i=head[now];i;i=e[i].nex)<span class="hljs-comment">//链式前向星遍历</span><br>		<span class="hljs-comment">//如果now有子节点的话，就递归往子节点的子节点走（禁止套娃）</span><br>		ll v = e[i].v;<br>		<span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>	<span class="hljs-built_in">dfs</span>(e[i].v,now);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">LCA</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(depth[x]&lt;depth[y])<span class="hljs-comment">//用数学语言就是说不妨设x的深度比y的深度大</span><br>		<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//这样下面只需要写一种代码就好了</span><br>	<span class="hljs-keyword">while</span>(depth[x]&gt;depth[y])<br>		<span class="hljs-comment">//让x跳到y的高度（同一高度）</span><br>		x=fa[x][lg[depth[x]-depth[y]]<span class="hljs-number">-1</span>];<br>	<span class="hljs-comment">//如果跳到一块了那LCA肯定就是y了</span><br>	<span class="hljs-keyword">if</span>(x==y)<br>		<span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(ll k=lg[depth[x]]<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;--k)<span class="hljs-comment">//倒着从大到小地跳</span><br>		<span class="hljs-comment">/*因为我们要求跳到x和y的LCA的下一层，所以没有跳到的时候就</span><br><span class="hljs-comment">		让x和y利用dfs里早就用倍增算法处理过的祖先路径快速地一块往上跳*/</span><br>		<span class="hljs-keyword">if</span>(fa[x][k]!=fa[y][k])<br>			x=fa[x][k],y=fa[y][k];<span class="hljs-comment">//往上跳</span><br>	<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<span class="hljs-comment">//返回x，y的父节点（肯定是相同的嘛）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;s);<br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)<br>	&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">add</span>(x,y),<span class="hljs-built_in">add</span>(y,x);<span class="hljs-comment">//无向图一定要记得建双向边</span><br>	&#125;<br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n)<span class="hljs-comment">//预处理一下</span><br>	lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;</span><br>	<span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<span class="hljs-comment">//从树根开始，因为用的是链式前向星所以给一个假想根0（其实就是到这儿停）</span><br>	<span class="hljs-comment">//dfs一下，预处理各点的深度和祖先</span><br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,m)<br>	&#123;<br><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">LCA</span>(x,y));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>十字链表</title>
    <url>/2022/10/10/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="稀疏矩阵的十字链表表示"><a href="#稀疏矩阵的十字链表表示" class="headerlink" title="稀疏矩阵的十字链表表示"></a>稀疏矩阵的十字链表表示</h3><p>本文对矩阵采用链式存储结构实现三元组的线性表，整个存储结构称作十字链表，并基于此数据结构实现矩阵运算<code>A+B</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//-----------稀疏矩阵的十字链表表示法-----</span><br><span class="hljs-comment">// 抽象数据类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-comment">// 非零元结点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OLNode</span> &#123;<br>    <span class="hljs-type">int</span> i, j;      <span class="hljs-comment">// 非零元的行列下标</span><br>    ElemType value;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OLNode</span>* right, * down;   <span class="hljs-comment">// 非零元所在的行表和列表的后继元</span><br>&#125;OLNode, * OLink;<br><span class="hljs-comment">// 十字链表结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    OLink* rhead, * chead; <span class="hljs-comment">// row_head and column_head 头节点指针向量</span><br>    <span class="hljs-type">int</span> cols, rows, nums;<br>&#125;CrossList;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateCrossList</span><span class="hljs-params">(CrossList&amp; M)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CrossListPrint</span><span class="hljs-params">(CrossList M)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">MatrixAdd</span><span class="hljs-params">(CrossList&amp; A, CrossList B)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">DestroyCrossList</span><span class="hljs-params">(CrossList B)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CrossList A, B;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateCrossList</span>(A) || !<span class="hljs-built_in">CreateCrossList</span>(B)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Space allocate error!\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;After addiction:\n&quot;</span>;<br>    <span class="hljs-built_in">MatrixAdd</span>(A, B);<br>    <span class="hljs-built_in">DestroyCrossList</span>(B);<br>    <span class="hljs-built_in">CrossListPrint</span>(A);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateCrossList</span><span class="hljs-params">(CrossList&amp; M)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix rows, cols and nums:\n&quot;</span>;<br>    cin &gt;&gt; M.rows &gt;&gt; M.cols &gt;&gt; M.nums;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix elements:(x, y, value)\n&quot;</span>;<br><br>    <span class="hljs-comment">// 为行表和列表指针申请空间，注意rhead,chead为指向指针的指针</span><br>    <span class="hljs-keyword">if</span> (!(M.rhead = (OLink*)<span class="hljs-built_in">malloc</span>(M.rows * <span class="hljs-built_in">sizeof</span>(OLink))))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!(M.chead = (OLink*)<span class="hljs-built_in">malloc</span>(M.cols * <span class="hljs-built_in">sizeof</span>(OLink))))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 初始化行列头指针向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M.rows; i++) M.rhead[i] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M.cols; i++) M.chead[i] = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-type">int</span> temp_i, temp_j, temp_value;<br>    <span class="hljs-keyword">for</span> (cin &gt;&gt; temp_i &gt;&gt; temp_j &gt;&gt; temp_value; temp_i != <span class="hljs-number">0</span>; cin &gt;&gt; temp_i &gt;&gt; temp_j &gt;&gt; temp_value) &#123;<br>        <span class="hljs-comment">// 假定输入以“0 0 0”结束</span><br>        OLink p;<br>        <span class="hljs-keyword">if</span> (!(p = (OLink)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(OLNode)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 生成结点</span><br>        p-&gt;i = temp_i; p-&gt;j = temp_j;<br>        p-&gt;value = temp_value;<br><br>        <span class="hljs-comment">/*-----------处理行插入情况------------*/</span><br>        <span class="hljs-keyword">if</span> (M.rhead[temp_i - <span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span> || M.rhead[temp_i - <span class="hljs-number">1</span>]-&gt;j &gt; temp_j) &#123;  <span class="hljs-comment">// 判断是否在首节点插入</span><br>            p-&gt;right = M.rhead[temp_i - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 这个地方一定保证了下面搜寻情况时最后一个结点的right域始终是NULL</span><br>            M.rhead[temp_i - <span class="hljs-number">1</span>] = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则需要遍历在行表中的插入位置</span><br>            <span class="hljs-comment">// 最先就比较当前行的第二个元素q-&gt;right，这种情况无法探查首结点，也是为何需要特判首结点</span><br>            <span class="hljs-comment">// 试探性的比较主要由单向链表结构决定的，只能巡查next，不能回溯</span><br>            OLink q = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">for</span> (q = M.rhead[temp_i - <span class="hljs-number">1</span>]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j &lt; temp_j; q = q-&gt;right);<br>            <span class="hljs-comment">// 最终停在待插入节点位置的前一个位置上</span><br>            p-&gt;right = q-&gt;right; q-&gt;right = p;<br>        &#125;<br><br>        <span class="hljs-comment">/*-----------处理列插入情况------------*/</span><br>        <span class="hljs-comment">// 列插入情况与行插入类似</span><br>        <span class="hljs-keyword">if</span> (M.chead[temp_j - <span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span> || M.chead[temp_j - <span class="hljs-number">1</span>]-&gt;i &gt; temp_i) &#123;<br>            p-&gt;down = M.chead[temp_j - <span class="hljs-number">1</span>];<br>            M.chead[temp_j - <span class="hljs-number">1</span>] = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            OLink q = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">for</span> (q = M.chead[temp_j - <span class="hljs-number">1</span>]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i &lt; temp_i; q = q-&gt;down);<br>            p-&gt;down = q-&gt;down; q-&gt;down = p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">MatrixAdd</span><span class="hljs-params">(CrossList &amp;A, CrossList B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 实现十字链表表示的矩阵加法</span><br>    <span class="hljs-comment">// 判断矩阵同型</span><br>    <span class="hljs-keyword">if</span> (A.rows != B.rows || A.cols != B.cols) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 构造矩阵A每一列的游标</span><br>    OLink colptr[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.cols; i++) colptr[i] = A.chead[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; A.rows; k++) &#123;<br>        <span class="hljs-comment">// pre指向矩阵A中pa前一节点</span><br>        OLink pa = A.rhead[k], pb = B.rhead[k], pre = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">while</span> (pb) &#123;    <span class="hljs-comment">// 处理B矩阵每一行元素</span><br>            <span class="hljs-comment">// A+B情况分类处理</span><br>            <span class="hljs-comment">// &lt;1&gt; 直接复制B结点到A矩阵中(可以直接移动但考虑最后释放B矩阵的开销，不如直接复制再释放)</span><br>            <span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span> || pa-&gt;j &gt; pb-&gt;j) &#123;<br>                <span class="hljs-comment">// 复制结点</span><br>                OLink p = (OLink)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(OLNode));<br>                <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                p-&gt;i = pb-&gt;i; p-&gt;j = pb-&gt;j; p-&gt;value = pb-&gt;value;  <span class="hljs-comment">//新节点值域更新</span><br><br>                <span class="hljs-comment">// 行表更改——归属于哪一行</span><br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) A.rhead[pb-&gt;i - <span class="hljs-number">1</span>] = p;<br>                <span class="hljs-keyword">else</span> pre-&gt;right = p;<br>                p-&gt;right = pa;       <span class="hljs-comment">// 新节点right域更新</span><br>                pre = p;<br><br>                <span class="hljs-comment">//列表更改——归属于哪一列</span><br>                <span class="hljs-keyword">if</span> (!A.chead[p-&gt;j - <span class="hljs-number">1</span>] || A.chead[p-&gt;j - <span class="hljs-number">1</span>]-&gt;i &gt; p-&gt;i)<br>                &#123;<br>                    p-&gt;down = A.chead[p-&gt;j - <span class="hljs-number">1</span>];  <span class="hljs-comment">//新节点down域更新</span><br>                    A.chead[p-&gt;j - <span class="hljs-number">1</span>] = p;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    p-&gt;down = colptr[p-&gt;j - <span class="hljs-number">1</span>]-&gt;down;<br>                    colptr[p-&gt;j - <span class="hljs-number">1</span>]-&gt;down = p;<br>                &#125;<br>                colptr[p-&gt;j - <span class="hljs-number">1</span>] = p;<br>                pb = pb-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">NULL</span> &amp;&amp; pa-&gt;j &lt; pb-&gt;j) &#123;<br>                <span class="hljs-comment">// &lt;2&gt; A矩阵同行元素位置在前时直接指针后移</span><br>                pre = pa;<br>                pa = pa-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;j == pb-&gt;j) &#123;<br>                <span class="hljs-comment">// &lt;3&gt; 执行加法运算</span><br>                pa-&gt;value += pb-&gt;value;<br>                <span class="hljs-keyword">if</span> (pa-&gt;value == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 特判和为零时从矩阵A中删除节点</span><br>                    <span class="hljs-comment">// 行表</span><br>                    <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) A.rhead[pa-&gt;i - <span class="hljs-number">1</span>] = pa-&gt;right;<br>                    <span class="hljs-keyword">else</span> pre-&gt;right = pa-&gt;right;<br>                    OLink p = pa;<br>                    pa = pa-&gt;right;   <span class="hljs-comment">// 后移继续下一运算</span><br>                    <span class="hljs-comment">// 列表</span><br>                    <span class="hljs-keyword">if</span> (A.chead[p-&gt;j - <span class="hljs-number">1</span>] == p) A.chead[p-&gt;j - <span class="hljs-number">1</span>] = colptr[p-&gt;j - <span class="hljs-number">1</span>] = p-&gt;down;<br>                    <span class="hljs-keyword">else</span> colptr[p-&gt;j - <span class="hljs-number">1</span>]-&gt;down = p-&gt;down;<br>                    <span class="hljs-built_in">free</span>(p);<br>                &#125;<br>                pb = pb-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.cols; i++)<br>            <span class="hljs-keyword">if</span> (colptr[i] &amp;&amp; colptr[i]-&gt;down &amp;&amp; colptr[i]-&gt;down-&gt;j &lt; k + <span class="hljs-number">2</span>) colptr[i] = colptr[i]-&gt;down;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CrossListPrint</span><span class="hljs-params">(CrossList M)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Output Matrix:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M.rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M.cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (M.rhead[i] &amp;&amp; M.rhead[i]-&gt;j == (j + <span class="hljs-number">1</span>)) &#123;<br>                cout &lt;&lt; M.rhead[i]-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                M.rhead[i] = M.rhead[i]-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DestroyCrossList</span><span class="hljs-params">(CrossList B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; B.rows; i++) &#123;<br>        OLink p = B.rhead[i];<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            OLink q = p;<br>            p = p-&gt;right;<br>            <span class="hljs-built_in">free</span>(q);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(B.rhead); <span class="hljs-built_in">free</span>(B.chead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个具体实现算例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*------One Example:</span><br><span class="hljs-comment">Input Matrix rows, cols and nums:</span><br><span class="hljs-comment">4 3 12</span><br><span class="hljs-comment">Input Matrix elements:(x, y, value)</span><br><span class="hljs-comment">1 1 -1</span><br><span class="hljs-comment">1 3 2</span><br><span class="hljs-comment">2 3 -1</span><br><span class="hljs-comment">3 1 2</span><br><span class="hljs-comment">0 0 0           // End_Input_Sign</span><br><span class="hljs-comment">Input Matrix rows, cols and nums:</span><br><span class="hljs-comment">4 3 12</span><br><span class="hljs-comment">Input Matrix elements:(x, y, value)</span><br><span class="hljs-comment">2 1 3</span><br><span class="hljs-comment">2 3 1</span><br><span class="hljs-comment">3 2 4</span><br><span class="hljs-comment">4 1 2</span><br><span class="hljs-comment">0 0 0           // End_Input_Sign</span><br><span class="hljs-comment">After addiction:</span><br><span class="hljs-comment">Output Matrix:</span><br><span class="hljs-comment">-1 0 2</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment">2 4 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2022/02/12/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、基本操作语法"><a href="#一、基本操作语法" class="headerlink" title="一、基本操作语法"></a>一、基本操作语法</h2><h3 id="1-1-基本格式"><a href="#1-1-基本格式" class="headerlink" title="1.1 基本格式"></a>1.1 基本格式</h3><p><1> 设置标题前后均留有空格</p>
<p><2> 加粗:</p>
<p><strong>加粗示例1（较推荐）</strong></p>
<p><strong>加粗示例2</strong></p>
<p><3> 斜体：</p>
<p><em>斜体示例1(较推荐）</em></p>
<p>_斜体示例2_</p>
<h3 id="1-2-段落和换行"><a href="#1-2-段落和换行" class="headerlink" title="1.2 段落和换行"></a>1.2 段落和换行</h3><h4 id="没有空行示例"><a href="#没有空行示例" class="headerlink" title="没有空行示例"></a>没有空行示例</h4><p>第一行<br>第二行</p>
<h4 id="有空行示例"><a href="#有空行示例" class="headerlink" title="有空行示例"></a>有空行示例</h4><p>第一行</p>
<p>第二行</p>
<h4 id="段内换行"><a href="#段内换行" class="headerlink" title="段内换行"></a>段内换行</h4><p>第一行，如果在段内换行需要在结尾插入两个及以上的空格<br>第二行</p>
<h3 id="1-3-有序列表"><a href="#1-3-有序列表" class="headerlink" title="1.3 有序列表"></a>1.3 有序列表</h3><h4 id="有序列表示例"><a href="#有序列表示例" class="headerlink" title="有序列表示例"></a>有序列表示例</h4><p>(数字序号+英文句号+空格+列表内容)  </p>
<ol>
<li>我有一个梦想  </li>
<li>我有两个梦想  </li>
<li>我有三个梦想  </li>
</ol>
<h3 id="1-4-无序列表"><a href="#1-4-无序列表" class="headerlink" title="1.4 无序列表"></a>1.4 无序列表</h3><h4 id="无序列表示例"><a href="#无序列表示例" class="headerlink" title="无序列表示例"></a>无序列表示例</h4><p>(*/+/- + 空格 + 列表内容)</p>
<h5 id="使用星号"><a href="#使用星号" class="headerlink" title="使用星号"></a>使用星号</h5><ul>
<li>我有一个梦想</li>
<li>我有两个梦想</li>
<li>我有三个梦想<br>（其他标记效果相同）  </li>
</ul>
<h3 id="1-5-嵌套列表"><a href="#1-5-嵌套列表" class="headerlink" title="1.5 嵌套列表"></a>1.5 嵌套列表</h3><h4 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h4><p>在第一层列表上，每一层多一个TAB键    </p>
<ul>
<li>我有一个梦想<ul>
<li>你有一个梦想<ul>
<li>她有一个梦想<ul>
<li>他有一个梦想<br>(有序列表类似可以互相嵌套）    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>_(建议使用-标记无序列表避免与粗体和斜体混淆)_</strong>  </p>
<h3 id="1-6-分割线"><a href="#1-6-分割线" class="headerlink" title="1.6 分割线"></a>1.6 分割线</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p>分割线由3个及以上的<em>/-/_来标记，对应效果不同。<br><em>*分割线示例</em></em>  </p>
<ul>
<li>星号</li>
</ul>
<hr>
<hr>
<hr>
<ul>
<li>减号</li>
</ul>
<hr>
<h2 id=""><a href="#" class="headerlink" title="- - -"></a>- - -</h2><ul>
<li>下画线  </li>
</ul>
<hr>
<hr>
<hr>
<h2 id="二、图片文件操作"><a href="#二、图片文件操作" class="headerlink" title="二、图片文件操作"></a>二、图片文件操作</h2><h3 id="2-1-插入图片"><a href="#2-1-插入图片" class="headerlink" title="2.1 插入图片"></a>2.1 插入图片</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><p>本地图片<br>（支持相对路径和绝对路径）<br><img src="D:/VisualStudioIDE/background/1.png" alt="本地图片">  </p>
</li>
<li><p>网络图片<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fd5f14e00482699c1c3b3509142b16f88126deff7.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1666447219&amp;t=b8c922e69db81319d3dc686fb66a0e53" alt="网络图片"> </p>
</li>
</ul>
<h3 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h5><p><strong><a href="链接地址">链接文字</a></strong><br>经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a>   </p>
<h5 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h5><p>经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a>  </p>
<p>语法说明如下：</p>
<ul>
<li>链接标记可以有字母、数字、空格和标点符号；</li>
<li>链接标记不区分大小写；</li>
<li>定义的链接内容可以放在当前文件的任意位置，建议放在页尾；</li>
<li>当链接地址为网络地址时要以http/https开头，否则会被识别为本地地址。  <h4 id="网址链接"><a href="#网址链接" class="headerlink" title="网址链接"></a>网址链接</h4>在Markdown中，将网络地址或邮箱地址使用＜＞包裹起来会被自动转换为超链接。<br><strong>邮箱链接示例</strong><br>获取更多信息，请访问MarkStiff的邮箱<a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x4c;&#90;&#72;&#x31;&#x33;&#49;&#52;&#x35;&#x32;&#x31;&#x6c;&#x69;&#x67;&#x61;&#x6f;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;">&#x4c;&#90;&#72;&#x31;&#x33;&#49;&#52;&#x35;&#x32;&#x31;&#x6c;&#x69;&#x67;&#x61;&#x6f;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;</a>   <h4 id="链接标题"><a href="#链接标题" class="headerlink" title="链接标题"></a>链接标题</h4>如果想了解关于Markdown的更多信息，请查看<a href="基本操作学习.md">Markdown指南</a>   </li>
</ul>
<h3 id="2-3-行内代码与代码块"><a href="#2-3-行内代码与代码块" class="headerlink" title="2.3 行内代码与代码块"></a>2.3 行内代码与代码块</h3><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p><strong>语法格式<code>Insert_Codes</code></strong>  </p>
<ul>
<li>使用<code>mkdir 文件夹</code>命令创建文件夹  </li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p><strong>语法格式：Tab键或4个空格开头</strong> //注意代码块需要隔行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;node;  <br></code></pre></td></tr></table></figure>
<h3 id="2-4-引用"><a href="#2-4-引用" class="headerlink" title="2.4 引用"></a>2.4 引用</h3><p><strong>语法格式：&gt; + 引用内容</strong><br>语法说明如下：</p>
<ol>
<li>多行引用也可以在每一行的开头都插入＞；</li>
<li>在引用中可以嵌套引用；</li>
<li>在引用中可以使用其他的Markdown语法；</li>
<li>段落与换行的格式在引用中也是适用的。  </li>
</ol>
<h4 id="单行引用"><a href="#单行引用" class="headerlink" title="单行引用"></a>单行引用</h4><blockquote>
<p>基于改进的自约束差分进化算法的多目标优化模型  </p>
<h4 id="多行引用"><a href="#多行引用" class="headerlink" title="多行引用"></a>多行引用</h4><p>引用MarkStiff的博客文章<a href="https://www.cnblogs.com/MarkStiff/p/16716797.html">MarkStiff</a><br>算法介绍</p>
<h4 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h4><p>多目标优化模型</p>
<blockquote>
<p>差分进化算法</p>
<blockquote>
<p>改进的自约束处理  </p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="2-5-转义"><a href="#2-5-转义" class="headerlink" title="2.5 转义"></a>2.5 转义</h3><p><strong>介绍</strong><br>当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用 <code>\</code> 进行转义<br><strong>语法格式：\特殊字符</strong>  </p>
<pre><code>`// 常见转义字符`
</code></pre><p>\   反斜线<br>`   反引号<br>*   星号<br>_   底线<br>\{}  花括号<br>[]  方括号<br>()  括弧<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   惊叹号  </p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>大物期中总结</title>
    <url>/2022/10/20/%E5%A4%A7%E7%89%A9%E6%9C%9F%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="第一章-静电场"><a href="#第一章-静电场" class="headerlink" title="第一章 静电场"></a>第一章 静电场</h2><p><img src="https://s1.ax1x.com/2022/10/21/x67kWV.md.jpg" alt="x67kWV.md.jpg" style="zoom:200%;" /></p>
<h3 id="第一讲-库仑定律"><a href="#第一讲-库仑定律" class="headerlink" title="第一讲 库仑定律"></a>第一讲 库仑定律</h3><h4 id="库仑定理——（真空静止点电荷）"><a href="#库仑定理——（真空静止点电荷）" class="headerlink" title="库仑定理——（真空静止点电荷）"></a>库仑定理——（真空静止点电荷）</h4><script type="math/tex; mode=display">
F = \frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\boldsymbol{r}^0\tag 1</script><p>其中真空介电常数 $\varepsilon_0 \approx 8.85\times10^{-12}  C^2N^{-1}m^{-2}$，令 $k=\frac{1}{4\pi\varepsilon_0}$ 则 $k\approx 9\times 10^9Nm^2/C^2$，矢量 $\boldsymbol{r}^0$ 由施力电荷指向受力电荷</p>
<h3 id="第二讲-电场强度-E"><a href="#第二讲-电场强度-E" class="headerlink" title="第二讲 电场强度$E$"></a>第二讲 电场强度$E$</h3><h4 id="2-1-电场强度"><a href="#2-1-电场强度" class="headerlink" title="2.1 电场强度"></a>2.1 电场强度</h4><script type="math/tex; mode=display">
E = \frac{F}{q_0}=\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}\boldsymbol{r}^0\tag 2</script><h4 id="2-2-均匀带电细圆环"><a href="#2-2-均匀带电细圆环" class="headerlink" title="2.2 均匀带电细圆环"></a>2.2 均匀带电细圆环</h4><p>圆环轴线上一点$P$的电场强度：</p>
<script type="math/tex; mode=display">
E = \frac{1}{4\pi\varepsilon_0}\frac{qx}{(R^2+x^2)^\frac{3}{2}}\tag 3</script><p>其中，$x$表示$P$点到圆环中心$O$的距离，$R$表示圆环半径，$q$表示圆环带电量；    </p>
<h4 id="2-3-有限长直线段"><a href="#2-3-有限长直线段" class="headerlink" title="2.3 有限长直线段"></a>2.3 有限长直线段</h4><p>直线外一点$P$电场强度：</p>
<script type="math/tex; mode=display">
E_x=\frac{\lambda}{4\pi\varepsilon_0 a}(cos\theta_1-cos\theta_2)\\
E_y=\frac{\lambda}{4\pi\varepsilon_0 a}(sin\theta_2-sin\theta_1)\tag 4</script><p>注：在建立坐标系的情况下，上式均带有方向，其中沿 $y$ 轴正向：$\theta_1\rightarrow \theta_2$，$\theta$ 为与 $y$ 轴正向夹角；<br>其中，$a$表示$P$点到直线的垂直距离；    </p>
<h4 id="2-4-均匀带电无限长直线"><a href="#2-4-均匀带电无限长直线" class="headerlink" title="2.4 均匀带电无限长直线"></a>2.4 均匀带电无限长直线</h4><p>由 $2.4$ 推得：令$\theta_1=0,\theta_2=\pi$     </p>
<script type="math/tex; mode=display">
E_x = \frac{\lambda}{2\pi\varepsilon_0 a}, E_y = 0\tag 5</script><h4 id="2-5-均匀带电无限大平面"><a href="#2-5-均匀带电无限大平面" class="headerlink" title="2.5 均匀带电无限大平面"></a>2.5 均匀带电无限大平面</h4><script type="math/tex; mode=display">
E=\frac{\sigma}{2\varepsilon_0} \tag 6</script><h4 id="2-6-无限大均匀带异号电荷平板间"><a href="#2-6-无限大均匀带异号电荷平板间" class="headerlink" title="2.6 无限大均匀带异号电荷平板间"></a>2.6 无限大均匀带异号电荷平板间</h4><script type="math/tex; mode=display">
E=\frac{\sigma}{\varepsilon_0}\tag 7</script><p>其中，$\sigma$表示每个平板的电荷面密度；     </p>
<h4 id="2-7-电偶极子"><a href="#2-7-电偶极子" class="headerlink" title="2.7 电偶极子"></a>2.7 电偶极子</h4><p>电偶极矩：$\boldsymbol{p}=q\boldsymbol{l}$<br>中垂线上一点$P$场强：</p>
<script type="math/tex; mode=display">
E = -\frac{\boldsymbol{p}}{4\pi\varepsilon_0y^3}   (y\gg l)\tag 8</script><p>共线上一点$P$场强：   </p>
<script type="math/tex; mode=display">
E=\frac{2\boldsymbol{p}}{4\pi\varepsilon_0x^3}(x\gg l)\tag 9</script><p>其中$\boldsymbol{l}$方向由负电荷指向正电荷；     </p>
<h4 id="2-8-力偶矩"><a href="#2-8-力偶矩" class="headerlink" title="2.8 力偶矩"></a>2.8 力偶矩</h4><p>电偶极子在匀强电场中得力偶矩：</p>
<script type="math/tex; mode=display">
\boldsymbol{F}_+=q\boldsymbol{E},\boldsymbol{F}_-=-q\boldsymbol{E}\\
M = F_+\cdot\frac{1}{2}lsin\theta+F_-\cdot\frac{1}{2}lsin\theta=qlEsin\theta\\
\Rightarrow\boldsymbol{M}=q\boldsymbol{l}\times\boldsymbol{E}=\boldsymbol{p}\times\boldsymbol{E}\tag{10}</script><p>注：电偶极子在电场的作用下总要使 $\boldsymbol{p}$ 转向 $\boldsymbol{E}$ 的方向；    </p>
<h3 id="第三讲-电通量-bigstar-高斯定理"><a href="#第三讲-电通量-bigstar-高斯定理" class="headerlink" title="第三讲 电通量 $\bigstar$高斯定理"></a>第三讲 电通量 $\bigstar$高斯定理</h3><h4 id="3-1-电通量"><a href="#3-1-电通量" class="headerlink" title="3.1 电通量"></a>3.1 电通量</h4><script type="math/tex; mode=display">
\Phi_e=\oint_S\boldsymbol{E}\cdot d\boldsymbol{S}\tag{11}</script><h4 id="3-2-高斯定理"><a href="#3-2-高斯定理" class="headerlink" title="3.2 高斯定理"></a>3.2 高斯定理</h4><p>选定高斯面后，电通量：</p>
<script type="math/tex; mode=display">
\Phi_e=\oint_S\boldsymbol{E}\cdot d\boldsymbol{S}=\frac{1}{\varepsilon_0}\sum_{(内)}q_i\tag{12}</script><h4 id="3-3-轴对称性电场"><a href="#3-3-轴对称性电场" class="headerlink" title="3.3 轴对称性电场"></a>3.3 轴对称性电场</h4><p>无限长均匀带电直线外一点$P$场强：</p>
<script type="math/tex; mode=display">
\Phi_e=\boldsymbol{E}\oint_侧d\boldsymbol{S}=2\pi rEl=\frac{1}{\varepsilon_0}\lambda l\\
\Rightarrow E = \frac{\lambda}{2\pi\varepsilon_0r}\tag{13}</script><p>其中，$r$表示$P$距离导线垂直距离；    </p>
<h4 id="3-4-球面对称性电场"><a href="#3-4-球面对称性电场" class="headerlink" title="3.4 球面对称性电场"></a>3.4 球面对称性电场</h4><p>均匀带电球面电场分布：</p>
<script type="math/tex; mode=display">
\Phi_e=\boldsymbol{E}\oint_S\boldsymbol{S}=E\cdot 4\pi r^2=\sum_{(内)}q_i=q\\
\Rightarrow E=\left\{\begin{array}{lcc} \frac{1}{4\pi \varepsilon_0}\frac{q}{r^2}\boldsymbol{r}^0&(r>R) \\ 0&(r<R)\tag{14}\end{array}\right.</script><h4 id="3-5-无限大均匀带电平面"><a href="#3-5-无限大均匀带电平面" class="headerlink" title="3.5 无限大均匀带电平面"></a>3.5 无限大均匀带电平面</h4><p>选定圆柱面作为高斯面：</p>
<script type="math/tex; mode=display">
\Phi_e=\oint_{左端面}\boldsymbol{E}\cdot d\boldsymbol{S}+\oint_{右端面}\boldsymbol{E}\cdot d\boldsymbol{S}=2ES=\frac{1}{\varepsilon_0}\sigma S\\
\Rightarrow E=\frac{\sigma}{2\varepsilon_0}\tag{15}</script><h4 id="3-6-均匀带电圆盘"><a href="#3-6-均匀带电圆盘" class="headerlink" title="3.6 均匀带电圆盘"></a>3.6 均匀带电圆盘</h4><script type="math/tex; mode=display">
E = \frac{\sigma}{2\varepsilon_0}(1-\frac{x}{\sqrt{R^2+x^2}})\tag{16}</script><h4 id="3-7-均匀带电球体"><a href="#3-7-均匀带电球体" class="headerlink" title="3.7 均匀带电球体"></a>3.7 均匀带电球体</h4><script type="math/tex; mode=display">
\boldsymbol{E}=\left\{\begin{array}{c}\frac{Q}{4\pi\varepsilon_0r^2}\boldsymbol{r_0}&(r>R)\\\frac{\rho}{3\varepsilon_0}\boldsymbol{r} & (r<R)\end{array}\right.</script><h3 id="第四讲-静电场的环路定理-电势能"><a href="#第四讲-静电场的环路定理-电势能" class="headerlink" title="第四讲 静电场的环路定理 电势能"></a>第四讲 静电场的环路定理 电势能</h3><h4 id="4-1-电场强度环流"><a href="#4-1-电场强度环流" class="headerlink" title="4.1 电场强度环流"></a>4.1 电场强度环流</h4><script type="math/tex; mode=display">
\oint\boldsymbol{E}\cdot d\boldsymbol{l}=0\tag{17}</script><p>环路定理表明静电场是无旋有源场；     </p>
<h4 id="4-2-电势能"><a href="#4-2-电势能" class="headerlink" title="4.2 电势能"></a>4.2 电势能</h4><p>选定电势能零参考点，则点$A$处的电势能：</p>
<script type="math/tex; mode=display">
w_a=A_{a'0'}=\int_a^{'0'}q_0\boldsymbol{E}\cdot d\boldsymbol{l}\tag{18}</script><p>注：电势能是标量，相对于电势能零参考点有负值；           </p>
<h3 id="第五讲-电势-电势差"><a href="#第五讲-电势-电势差" class="headerlink" title="第五讲 电势 电势差"></a>第五讲 电势 电势差</h3><h4 id="5-1-电势与电势差"><a href="#5-1-电势与电势差" class="headerlink" title="5.1 电势与电势差"></a>5.1 电势与电势差</h4><p>$A$点电势：</p>
<script type="math/tex; mode=display">
u_a=\frac{W_a}{q_0}=\int_a^{'0'}\boldsymbol{E}\cdot d\boldsymbol{l}\tag{19}</script><p>注：电势为标量；     </p>
<script type="math/tex; mode=display">
U_{ab}=u_a-u_b=\int_a^b\boldsymbol{E}\cdot d\boldsymbol{l}\tag{20}</script><p>电荷$q$$a\rightarrow b$时，静电力做功：</p>
<script type="math/tex; mode=display">
A_{ab}=q(u_a-u_b)\tag{21}</script><h4 id="5-2-电偶极子电势能"><a href="#5-2-电偶极子电势能" class="headerlink" title="5.2 电偶极子电势能"></a>5.2 电偶极子电势能</h4><p>在电场 $\boldsymbol{E}$ 中：</p>
<script type="math/tex; mode=display">
W=-\boldsymbol{p}\cdot\boldsymbol{E}\tag{22}</script><p>当$\boldsymbol{E}$为非均匀电场时，上式应改为积分形式；     </p>
<h4 id="5-3-电势叠加原理"><a href="#5-3-电势叠加原理" class="headerlink" title="5.3 电势叠加原理"></a>5.3 电势叠加原理</h4><p>对于点电荷选取无穷远处作为零电势点：</p>
<script type="math/tex; mode=display">
u_a=\int_a^{\infty}\boldsymbol{E}\cdot d\boldsymbol{l}=\frac{1}{4\pi\varepsilon_0}\frac{q}{r}\\
W_a = \frac{1}{4\pi\varepsilon_0}\frac{q^2}{r}\tag{23}</script><p>叠加原理——标量叠加         </p>
<script type="math/tex; mode=display">
u_a=\sum u_i\\
\Rightarrow u_a=\int_Q\frac{1}{4\pi\varepsilon_0}\frac{dq}{r}(积分形式)\tag{24}</script><h4 id="5-4-电荷分布求电势"><a href="#5-4-电荷分布求电势" class="headerlink" title="5.4 电荷分布求电势"></a>5.4 电荷分布求电势</h4><p>积分形式：</p>
<script type="math/tex; mode=display">
u_a=\int_Q\frac{1}{4\pi\varepsilon_0}\frac{dq}{r}\tag{25}</script><p>电偶极子外任一点$C$的电势：</p>
<script type="math/tex; mode=display">
U_C = \frac{1}{4\pi\varepsilon_0}\frac{q}{r_+}-\frac{1}{4\pi\varepsilon_0}\frac{q}{r_-}=\frac{q}{4\pi\varepsilon_0}\frac{r_--r_+}{r_-r_+}\\
r\gg l\Rightarrow r_+r_-\approx r^2,r_--r_+\approx lcos\theta\\
\Rightarrow u_C = \frac{1}{4\pi\varepsilon_0}\frac{\boldsymbol{p}\cdot\boldsymbol{r}}{r^3}\tag{26}</script><h4 id="5-5-电场强度求电势"><a href="#5-5-电场强度求电势" class="headerlink" title="5.5 电场强度求电势"></a>5.5 电场强度求电势</h4><p>场强与电势关系：</p>
<script type="math/tex; mode=display">
u_a=\int_a^{\infty}\boldsymbol{E}\cdot d\boldsymbol{l}\tag{27}</script><p>带电体电荷分布具有对称性时，利用高斯定理求出场强分布进而求电势；<br><strong>【无限长均匀带电圆柱面】</strong><br>由高斯定理求得电场分布：</p>
<script type="math/tex; mode=display">
E = \left\{ \begin{array}{c}0 & r<R \\ \frac{\lambda}{2\pi\varepsilon_0r} & r>R\end{array}\right.\tag{28}</script><p>_一般而言，当电荷分布延伸到无穷远时，是不能选取无穷远处为电势零参考点的；_     </p>
<script type="math/tex; mode=display">
u_P=\int_P^{P_0}\boldsymbol{E}\cdot d\boldsymbol{l}=\int_P^{P'}\boldsymbol{E}\cdot d\boldsymbol{l}+\int_{P'}^{P_0}\boldsymbol{E}\cdot d\boldsymbol{l}\\
=0+\int_r^{r_0}\frac{\lambda}{2\pi\varepsilon_0r}dr\\
=-\frac{\lambda}{2\pi\varepsilon_0}\ln r+\frac{\lambda}{2\pi\varepsilon_0}\ln r_0\\
=-\frac{\lambda}{2\pi\varepsilon_0}\ln r+C(r>R)\tag{29}</script><script type="math/tex; mode=display">
u_P=\int_P^{P_0}\boldsymbol{E}\cdot d\boldsymbol{l}=\int_r^R\boldsymbol{E}\cdot d\boldsymbol{l}+\int_R^{r_0}\boldsymbol{E}\cdot d\boldsymbol{l}\\
=0+\int_R^{r_0}\frac{\lambda}{2\pi\varepsilon_0r}dr\\
=-\frac{\lambda}{2\pi\varepsilon_0}\ln R + C(r<R)\tag{30}</script><p>其中，$C=\frac{\lambda}{2\pi\varepsilon_0}\ln r_0$     </p>
<h4 id="5-6-均匀带电球面电势"><a href="#5-6-均匀带电球面电势" class="headerlink" title="5.6 均匀带电球面电势"></a>5.6 均匀带电球面电势</h4><script type="math/tex; mode=display">
V(r) = \left\{ \begin{array}{c}\frac{1}{4\pi\varepsilon_0} \frac{q}{R} & (r \le R)\\\frac{1}{4\pi\varepsilon_0}\frac{q}{r}&(r>R)\end{array}\right.\tag{31}</script><h4 id="5-7-均匀带电球体电势"><a href="#5-7-均匀带电球体电势" class="headerlink" title="5.7 均匀带电球体电势"></a>5.7 均匀带电球体电势</h4><p>球内距离球心$r$处一点$P$电势：</p>
<script type="math/tex; mode=display">
u = u_1+u_2=\frac{1}{4\pi\varepsilon_0}\frac{Q}{R^3}r^2+\int_r^R\frac{1}{4\pi\varepsilon_0}\frac{dq_2}{r'}\\
=\frac{1}{4\pi\varepsilon_0}\frac{Q}{R^3}r^2+\int_r^R\frac{3Qr'}{4\pi\varepsilon_0R^3}dr'\\
=\frac{Q(3R^2-r^2)}{8\pi\varepsilon_0R^3}(r<R)\tag{32}</script><p>球外距离球心$r$处一点$P$电势：</p>
<script type="math/tex; mode=display">
u = \frac{Q}{4\pi\varepsilon_0r}(r\ge R)\tag{33}</script><p>注：在$P$点的电场强度犹如电荷集中在球心处的点电荷在$P$点产生的电场强度一样，故电势同理；       </p>
<h3 id="第六讲-电势与场强微分关系"><a href="#第六讲-电势与场强微分关系" class="headerlink" title="第六讲 电势与场强微分关系"></a>第六讲 电势与场强微分关系</h3><script type="math/tex; mode=display">
E = -\frac{du}{dn}\\
E_l=-\frac{du}{dl}\\
\boldsymbol{E}=-(\frac{\partial u}{\partial x}\boldsymbol{i}+\frac{\partial u}{\partial y}\boldsymbol{j}+\frac{\partial u}{\partial z}\boldsymbol{k})\\
u(x,y,z)\Rightarrow E(x,y,z)\tag{34}</script><h3 id="第七讲-静电场中的导体-电容"><a href="#第七讲-静电场中的导体-电容" class="headerlink" title="第七讲 静电场中的导体 电容"></a>第七讲 静电场中的导体 电容</h3><h4 id="7-1-静电平衡导体表面"><a href="#7-1-静电平衡导体表面" class="headerlink" title="7.1 静电平衡导体表面"></a>7.1 静电平衡导体表面</h4><p>电场强度：</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\frac{\sigma}{\varepsilon_0}\boldsymbol{n}\tag{35}</script><p>区别于无限大带电平面产生的电场(缺少静电平衡的条件)：</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\frac{\sigma}{2\varepsilon_0}\boldsymbol{n}\tag{36}</script><h4 id="7-2-孤立导体电容"><a href="#7-2-孤立导体电容" class="headerlink" title="7.2 孤立导体电容"></a>7.2 孤立导体电容</h4><script type="math/tex; mode=display">
C = \frac{q}{u}\tag{37}</script><h4 id="7-3-平行板电容器电容"><a href="#7-3-平行板电容器电容" class="headerlink" title="7.3 平行板电容器电容"></a>7.3 平行板电容器电容</h4><script type="math/tex; mode=display">
C = \frac{q}{u_1-u_2}\\
=\frac{q}{Ed}=\frac{q}{\frac{\sigma}{\varepsilon_0}d}\\
=\frac{q}{\frac{qd}{\varepsilon_0S}}=\frac{\varepsilon_0S}{d}\tag{38}</script><h4 id="7-4-球形电容器电容"><a href="#7-4-球形电容器电容" class="headerlink" title="7.4 球形电容器电容"></a>7.4 球形电容器电容</h4><p>两球面间电场强度：</p>
<script type="math/tex; mode=display">
E=\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}\tag{39}</script><script type="math/tex; mode=display">
u_1-u_2=\int_{R_1}^{R_2}\boldsymbol{E}\cdot d\boldsymbol{l} = \int_{R_1}^{R_2}\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}dr\\
=\frac{q}{4\pi\varepsilon_0}\frac{R_2-R_1}{R_1R_2}\\
\Rightarrow C = \frac{q}{u_1-u_2}=\frac{4\pi\varepsilon_0R_1R_2}{R_2-R_1}\tag{40}</script><h4 id="7-5-电容器串并联"><a href="#7-5-电容器串并联" class="headerlink" title="7.5 电容器串并联"></a>7.5 电容器串并联</h4><script type="math/tex; mode=display">
\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}+\cdot\cdot\cdot+\frac{1}{C_n}(串联)\\
C = C_1+C_2+\cdot\cdot\cdot+C_n(并联)\tag{41}</script><h3 id="第八讲-静电能"><a href="#第八讲-静电能" class="headerlink" title="第八讲 静电能"></a>第八讲 静电能</h3><h4 id="8-1-静电能公式推导"><a href="#8-1-静电能公式推导" class="headerlink" title="8.1 静电能公式推导"></a>8.1 静电能公式推导</h4><script type="math/tex; mode=display">
U(t) = \frac{q(t)}{C}\\dA = U(t)dq = \frac{q(t)}{C}dq\\
A = \int dA = \int_0^Q\frac{q(t)}{C}dq=\frac{Q^2}{2C}\\
Q=CU\Rightarrow A = \frac{1}{2}CU^2=\frac{1}{2}QU\\
\Rightarrow W=A=\frac{Q^2}{2C}=\frac{1}{2}CU^2=\frac{1}{2}QU\tag{42}</script><h4 id="8-2-电场能量密度推导"><a href="#8-2-电场能量密度推导" class="headerlink" title="8.2 电场能量密度推导"></a>8.2 电场能量密度推导</h4><script type="math/tex; mode=display">
U=Ed, C = \frac{\varepsilon_0S}{d}\\
\Rightarrow W = \frac{1}{2}\varepsilon_0E^2Sd = \frac{1}{2}\varepsilon_0E^2V\\
\Rightarrow \omega = \frac{W}{V}=\frac{1}{2}\varepsilon_0E^2\tag{43}</script><h3 id="第九讲-电介质的极化-束缚电荷"><a href="#第九讲-电介质的极化-束缚电荷" class="headerlink" title="第九讲 电介质的极化 束缚电荷"></a>第九讲 电介质的极化 束缚电荷</h3><h4 id="9-1-电介质"><a href="#9-1-电介质" class="headerlink" title="9.1 电介质"></a>9.1 电介质</h4><script type="math/tex; mode=display">
C = \varepsilon_r C_0\tag{44}</script><p>其中，$\varepsilon_r$ 称为介质的相对介电常数（相对电容率），$C_0$ 表示真空中对应的电容；因此，除真空中 $\varepsilon_r=1$ 外，其余 $\varepsilon_r&gt;1$；    </p>
<h4 id="9-2-介质极化"><a href="#9-2-介质极化" class="headerlink" title="9.2 介质极化"></a>9.2 介质极化</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}有极分子\Rightarrow 取向极化\\
无极分子\Rightarrow 位移极化\end{array}\right.</script><h3 id="第十讲-电介质内的电场强度"><a href="#第十讲-电介质内的电场强度" class="headerlink" title="第十讲 电介质内的电场强度"></a>第十讲 电介质内的电场强度</h3><p>根据电介质极化原理推导：</p>
<script type="math/tex; mode=display">
\boldsymbol{E} = \boldsymbol{E}_0+\boldsymbol{E}'\\
E_0=\frac{\sigma_0}{\varepsilon_0},E'=\frac{\sigma'}{\varepsilon_0}\\
\Rightarrow E = \frac{\sigma_0}{\varepsilon_0}-\frac{\sigma'}{\varepsilon_0}\\E = \frac{E_0}{\varepsilon_r}\\
\Rightarrow \sigma'=(1-\frac{1}{\varepsilon_r})\sigma_0\tag{45}</script><h3 id="第十一讲-bigstar-电介质中的高斯定理"><a href="#第十一讲-bigstar-电介质中的高斯定理" class="headerlink" title="第十一讲 $\bigstar$电介质中的高斯定理"></a>第十一讲 $\bigstar$电介质中的高斯定理</h3><h4 id="11-1-电位移矢量"><a href="#11-1-电位移矢量" class="headerlink" title="11.1 电位移矢量"></a>11.1 电位移矢量</h4><p>推导：</p>
<script type="math/tex; mode=display">
\iint_S\boldsymbol{E}\cdot d\boldsymbol{S}=\frac{1}{\varepsilon_0}(\sigma_0-\sigma')S\\
式(45)\Rightarrow \frac{1}{\varepsilon_0}(\sigma_0-\sigma')=\frac{\sigma_0}{\varepsilon_0\varepsilon_r}\\
\Rightarrow \iint_S\varepsilon_0\varepsilon_r\boldsymbol{E}\cdot d\boldsymbol{S}=\varepsilon_0S=q_0\\
令\boldsymbol{D} = \varepsilon\boldsymbol{E} = \varepsilon_0\varepsilon_r\boldsymbol{E}\\
\Rightarrow \iint_S\boldsymbol{D}\cdot d\boldsymbol{S} = q_0\tag{46}</script><p>其中，$D$ 称为电位移矢量或电通密度，$\varepsilon = \varepsilon_0\varepsilon_r$ 称为电介质的介电常数；    </p>
<h4 id="11-2-电介质中的能量密度"><a href="#11-2-电介质中的能量密度" class="headerlink" title="11.2 电介质中的能量密度"></a>11.2 电介质中的能量密度</h4><script type="math/tex; mode=display">
\omega = \frac{1}{2}\boldsymbol{D}\cdot\boldsymbol{E}\\
\varepsilon_r = 1\Rightarrow \omega = \frac{1}{2}\varepsilon_0E^2(真空中)\tag{47}</script><h3 id="第十二讲-经典习题"><a href="#第十二讲-经典习题" class="headerlink" title="第十二讲 经典习题"></a>第十二讲 经典习题</h3><p><img src="https://s1.ax1x.com/2022/10/21/x6HOKS.md.png" alt="x6HOKS.md.png"><br><img src="https://s1.ax1x.com/2022/10/21/x6HxEj.md.png" alt="x6HxEj.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcDqsK.md.png" alt="xcDqsK.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcDLqO.md.png" alt="xcDLqO.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcrX60.md.png" alt="xcrX60.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcs8jP.md.png" alt="xcs8jP.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcyRqf.md.png" alt="xcyRqf.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcyhdS.md.png" alt="xcyhdS.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcy4Ig.md.png" alt="xcy4Ig.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcyTRs.png" alt="xcyTRs.png" style="zoom:141.3%;" /><br><img src="https://s1.ax1x.com/2022/10/22/xcybMq.png" alt="xcybMq.png" style="zoom:143%;" /></p>
<h2 id="第二章-恒定电流的磁场"><a href="#第二章-恒定电流的磁场" class="headerlink" title="第二章 恒定电流的磁场"></a>第二章 恒定电流的磁场</h2><p><img src="https://s1.ax1x.com/2022/10/22/xc6lOP.md.jpg" alt="xc6lOP.md.jpg" style="zoom:200%;" /></p>
<h3 id="第一讲-磁感应强度-B"><a href="#第一讲-磁感应强度-B" class="headerlink" title="第一讲 磁感应强度$B$"></a>第一讲 磁感应强度$B$</h3><p>电流元$Idl$所受磁场力：</p>
<script type="math/tex; mode=display">
d\boldsymbol{F} = Id\boldsymbol{l}\times\boldsymbol{B}\tag{1}</script><h3 id="第二讲-毕奥-萨伐尔定律"><a href="#第二讲-毕奥-萨伐尔定律" class="headerlink" title="第二讲 毕奥-萨伐尔定律"></a>第二讲 毕奥-萨伐尔定律</h3><h4 id="2-1-电流元的磁场"><a href="#2-1-电流元的磁场" class="headerlink" title="2.1 电流元的磁场"></a>2.1 电流元的磁场</h4><script type="math/tex; mode=display">
d\boldsymbol{B} = \frac{\mu_0}{4\pi}\frac{Id\boldsymbol{l}\times\boldsymbol{r}^0}{r^2}\tag{2}</script><p>其中，$\mu_0=4\pi\times10^{-7}N/A^2$称为真空磁导率，$\boldsymbol{r}_0$表示到$P$点的单位矢量，$r$表示到$P$点的距离；     </p>
<h4 id="2-2-运动电荷的磁场"><a href="#2-2-运动电荷的磁场" class="headerlink" title="2.2 运动电荷的磁场"></a>2.2 运动电荷的磁场</h4><script type="math/tex; mode=display">
\boldsymbol{B} = \frac{d\boldsymbol{B}}{dN}=\frac{\mu_0}{4\pi}\frac{q\boldsymbol{v}\times\boldsymbol{r}^0}{r^2}\tag{3}</script><h4 id="2-3-载流直导线的磁场"><a href="#2-3-载流直导线的磁场" class="headerlink" title="2.3 载流直导线的磁场"></a>2.3 载流直导线的磁场</h4><script type="math/tex; mode=display">
dB = \frac{\mu_0}{4\pi}\frac{Idlsin\theta}{r^2}\\
\Rightarrow B = \frac{\mu_0I}{4\pi r}\int_{\theta_1}^{\theta_2}sin\theta d\theta=\frac{\mu_0I}{4\pi r}(cos\theta_1-cos\theta_2)\\
\theta_1\approx 0,\theta_2\approx\pi\Rightarrow B = \frac{\mu_0I}{2\pi r}\tag{4}</script><p>式中，$r$表示到载流导线的距离；    </p>
<h4 id="2-4-载流圆环的磁场"><a href="#2-4-载流圆环的磁场" class="headerlink" title="2.4 载流圆环的磁场"></a>2.4 载流圆环的磁场</h4><script type="math/tex; mode=display">
B = \int dB_x = \int dBcos\theta = \frac{\mu_0}{4\pi}\int \frac{Idl}{r^2}cos\theta\\
cos\theta = \frac{R}{r}=\frac{R}{(R^2+x^2)^{1/2}}\\
\Rightarrow B = \frac{\mu_0IR^2}{2(R^2+x^2)^{3/2}}\tag{5}</script><p>【$N$匝线圈】</p>
<script type="math/tex; mode=display">
B = \frac{\mu_0IR^2N}{2(R^2+x^2)^{3/2}}\tag{6}</script><p>【圆弧磁场】</p>
<script type="math/tex; mode=display">
式(5) x = 0\Rightarrow B = \frac{\mu_0I}{2R}(圆心处)\\
\Rightarrow B =  \frac{\mu_0I}{2R}\cdot\frac{\varphi}{2\pi}=\frac{\mu_0I\varphi}{4\pi R}\tag{7}</script><h4 id="2-5-载流线圈的磁矩"><a href="#2-5-载流线圈的磁矩" class="headerlink" title="2.5 载流线圈的磁矩"></a>2.5 载流线圈的磁矩</h4><script type="math/tex; mode=display">
式(5)令x\gg R,(x^2+R^2)\approx x^2\\
\Rightarrow B\approx \frac{\mu_0IR^2}{2x^3} = \frac{\mu_0I\pi R^2}{2\pi x^3}=\frac{\mu_0 IS}{2\pi x^3}\\
\Rightarrow 定义:\ \ \ \ \boldsymbol{p}_m = IS\boldsymbol{n}\\
\boldsymbol{B} = \frac{\mu_0}{2\pi}\frac{\boldsymbol{p}_m}{x^3}\tag{8}</script><p>其中，$\boldsymbol{n}$表示线圈平面正法线方向上的单位矢量；<br>圆心处的磁感应强度：</p>
<script type="math/tex; mode=display">
\boldsymbol{B} = \frac{\mu_0}{2\pi}\frac{\boldsymbol{p}_m}{R^3}\tag{9}</script><h4 id="2-6-无限大均匀载流平面"><a href="#2-6-无限大均匀载流平面" class="headerlink" title="2.6 无限大均匀载流平面"></a>2.6 无限大均匀载流平面</h4><script type="math/tex; mode=display">
dB = \frac{\mu_0\alpha dx}{2\pi\sqrt{r^2+x^2}}\\
由对称性：B_x = \int dB_x, \ \ \ B_y = \int dB_y = 0\\
B = B_x = \int \frac{r}{\sqrt{r^2+x^2}}\cdot \frac{\mu_0 \alpha dx}{2\pi\sqrt{r^2+x^2}} =\int \frac{\mu_0 \alpha r dx}{2\pi (r^2+x^2)}\\
=\frac{\mu_0 \alpha r}{2\pi}\int_{-\infty}^{+\infty}\frac{1}{r^2+x^2}dx=\frac{\mu_0 \alpha}{2}\\
故\ \ \ B = \frac{1}{2}\mu_0\alpha\tag{10}</script><p>式中，$r$ 表示$P$点距到无限大载流平面的距离，$\alpha$ 表示流过单位长度的电流；    </p>
<h4 id="2-7-均匀密绕直螺线管"><a href="#2-7-均匀密绕直螺线管" class="headerlink" title="2.7 均匀密绕直螺线管"></a>2.7 均匀密绕直螺线管</h4><script type="math/tex; mode=display">
dB = \frac{\mu_0R^2dI'}{2(R^2+l^2)^{3/2}} = \frac{\mu_0R^2Indl}{2(R^2+l^2)^{3/2}}\\
l = Rcot\beta\ ,\ \ \ dl = -Rcsc^2\beta d\beta\ , \ \ \ \R^2+l^2 = R^2csc^2\beta\\
\Rightarrow dB= -\frac{\mu_0}{2}nIsin\beta d\beta\\
\Rightarrow B =\int_{\beta_1}^{\beta_2}-\frac{\mu_0}{2}nIsin\beta d\beta = \frac{\mu_0nI}{2}(cos\beta_2-cos\beta_1)\tag{11}</script><p>【无限长】</p>
<script type="math/tex; mode=display">
L\gg R,\ \ \beta_1\rightarrow\pi, \ \ \beta_2\rightarrow 0 \Rightarrow B = \mu_0nI\tag{12}</script><p>【半无限长】<br>端点处：</p>
<script type="math/tex; mode=display">
\beta_1 = \frac{\pi}{2}, \ \ \beta_2\rightarrow 0\ , 或 \ \ \beta_1\rightarrow \pi, \ \ \beta_2=\frac{\pi}{2}\Rightarrow B = \frac{\mu_0nI}{2}\tag{13}</script><p>式中，$n$表示单位长度上的线圈匝数；      </p>
<h3 id="第三讲-磁通量-磁场的高斯定理"><a href="#第三讲-磁通量-磁场的高斯定理" class="headerlink" title="第三讲 磁通量 磁场的高斯定理"></a>第三讲 磁通量 磁场的高斯定理</h3><h4 id="3-1-磁通量"><a href="#3-1-磁通量" class="headerlink" title="3.1 磁通量"></a>3.1 磁通量</h4><script type="math/tex; mode=display">
\Phi_m = \int_S \boldsymbol{B}\cdot d\boldsymbol{S}\tag{14}</script><h4 id="3-2-高斯定理-1"><a href="#3-2-高斯定理-1" class="headerlink" title="3.2 高斯定理"></a>3.2 高斯定理</h4><script type="math/tex; mode=display">
\oint_S \boldsymbol{B}\cdot d\boldsymbol{S}=0\tag{15}</script><h3 id="第四讲-bigstar-安培环路定理"><a href="#第四讲-bigstar-安培环路定理" class="headerlink" title="第四讲 $\bigstar$安培环路定理"></a>第四讲 $\bigstar$安培环路定理</h3><script type="math/tex; mode=display">
\oint_L\boldsymbol{B}\cdot d\boldsymbol{l}=\mu_0\sum_{(内)}I_i\tag{16}</script><p>式中，$I_i$ 的正（负）取决于电流方向与闭合路径 $L$ 绕行方向满足（不满足）右螺旋法则；$B$ 表示闭合路径 $L$ 内外所有电流产生的总磁感应强度；<br>【无限大载流平面】<br><img src="https://s1.ax1x.com/2022/10/22/xchO56.md.png" alt="xchO56.md.png"></p>
<script type="math/tex; mode=display">
\oint_L\boldsymbol{B}\cdot d\boldsymbol{l} = \int_{PQ}\boldsymbol{B}\cdot d\boldsymbol{l}+\int_{QR}\boldsymbol{B}\cdot d\boldsymbol{l}+\int_{RS}\boldsymbol{B}\cdot d\boldsymbol{l}+\int_{SP}\boldsymbol{B}\cdot d\boldsymbol{l}\\
=Bx+0+Bx+0 = 2Bx = \mu_0 \alpha x\\
\Rightarrow B = \frac{1}{2}\mu_0\alpha\tag{17}</script><h3 id="第五讲-磁场对电流作用"><a href="#第五讲-磁场对电流作用" class="headerlink" title="第五讲 磁场对电流作用"></a>第五讲 磁场对电流作用</h3><h4 id="5-1-载流导线"><a href="#5-1-载流导线" class="headerlink" title="5.1 载流导线"></a>5.1 载流导线</h4><p>所受安培力：</p>
<script type="math/tex; mode=display">
\boldsymbol{F} = \int_LId\boldsymbol{l}\times\boldsymbol{B}\tag{18}</script><h4 id="5-2-载流线圈"><a href="#5-2-载流线圈" class="headerlink" title="5.2 载流线圈"></a>5.2 载流线圈</h4><p>所受磁力矩：</p>
<script type="math/tex; mode=display">
M = F_{ab}l_1sin\varphi=BIl_1l_2sin\varphi=BISsin\varphi\\
\boldsymbol{p}_m = IS\boldsymbol{n}\\
\Rightarrow \boldsymbol{M}=\boldsymbol{p}_m\times\boldsymbol{B}\tag{19}</script><p>式中，$\boldsymbol{n}$ 的方向按电流方向用右螺旋法则确定；     </p>
<h4 id="5-3-磁力的功"><a href="#5-3-磁力的功" class="headerlink" title="5.3 磁力的功"></a>5.3 磁力的功</h4><script type="math/tex; mode=display">
A = F\overline{aa'} = BIl\overline{aa'}=BI\vartriangle S = I\vartriangle\Phi\\
\Rightarrow A = \int_{\Phi_1}^{\Phi_2}Id\Phi = I(\Phi_2-\Phi_1)=I\vartriangle\Phi\tag{20}</script><h4 id="5-4-磁偶极子势能"><a href="#5-4-磁偶极子势能" class="headerlink" title="5.4 磁偶极子势能"></a>5.4 磁偶极子势能</h4><p>载流线圈相当于磁偶极子，因此载流线圈同理；     </p>
<script type="math/tex; mode=display">
\varphi = \frac{\pi}{2}时,\  \ \ W = 0(零势能点)\\
W = -A = -\int_\varphi^{\pi/2}Md\varphi = -p_mB\int_\varphi^{\pi/2}sin\varphi d\varphi = -p_mBcos\varphi\\
\Rightarrow W = -\boldsymbol{p}_m\cdot \boldsymbol{B}\tag{21}</script><h3 id="第六讲-带电粒子在电场和磁场中的运动"><a href="#第六讲-带电粒子在电场和磁场中的运动" class="headerlink" title="第六讲 带电粒子在电场和磁场中的运动"></a>第六讲 带电粒子在电场和磁场中的运动</h3><h4 id="6-1-洛伦兹力"><a href="#6-1-洛伦兹力" class="headerlink" title="6.1 洛伦兹力"></a>6.1 洛伦兹力</h4><script type="math/tex; mode=display">
\boldsymbol{F} = q\boldsymbol{v}\times\boldsymbol{B}\tag{22}</script><h4 id="6-2-霍尔效应"><a href="#6-2-霍尔效应" class="headerlink" title="6.2 霍尔效应"></a>6.2 霍尔效应</h4><script type="math/tex; mode=display">
q\overline{v}B=qE\Rightarrow E = \overline{v}B\\
U = El = vBl\\
I = nqS\overline{v}\\
\Rightarrow U = \frac{IB}{nqd} = K\frac{IB}{d}\\
K = \frac{1}{nq}(霍尔系数)\tag{23}</script><p>式中，$d$ 和 $l$ 分别表示沿电流方向上导体截面的宽度和高度；$n$ 表示单位体积的载流子数；<br>【载流子种类】</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}p\ (positive)\ \ \ 型半导体\Rightarrow 空穴\Rightarrow 空穴导电\\n\ (negative)\ 型半导体\Rightarrow 电子\Rightarrow 电子导电\end{array}\right.</script><h3 id="第七讲-磁介质"><a href="#第七讲-磁介质" class="headerlink" title="第七讲 磁介质"></a>第七讲 磁介质</h3><h4 id="7-1-相对磁导率"><a href="#7-1-相对磁导率" class="headerlink" title="7.1 相对磁导率"></a>7.1 相对磁导率</h4><script type="math/tex; mode=display">
\mu_r = \frac{B}{B_0}\tag{24}</script><p>式中，$B_0$ 表示真空磁感应强度，$mu_r$ 表示磁介质的相对磁导率，$B$ 表示磁介质的磁感应强度；     </p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}\mu_r > 1\Rightarrow 顺磁质\ (弱/非磁性物质)\\ \mu_r<1\Rightarrow 抗磁质\ (弱/非磁性物质)
\\\mu_r\gg 1 \Rightarrow 铁磁质\ (强磁性物质)\end{array}\right.</script><h4 id="7-2-bigstar-磁介质的安培环路定理"><a href="#7-2-bigstar-磁介质的安培环路定理" class="headerlink" title="7.2 $\bigstar$ 磁介质的安培环路定理"></a>7.2 $\bigstar$ 磁介质的安培环路定理</h4><script type="math/tex; mode=display">
\oint_L\boldsymbol{B}\cdot d\boldsymbol{l} = \mu_0\mu_r\sum_{(内)}I\\
令\mu = \mu_0\mu_r\Rightarrow \oint_L \frac{\boldsymbol{B}}{\mu}\cdot d\boldsymbol{l}=\sum_{(内)}I\\
令\boldsymbol{H} = \frac{\boldsymbol{B}}{\mu}
\Rightarrow\oint_L\boldsymbol{H}\cdot d\boldsymbol{l}=\sum_{(内)}I\tag{25}</script><p>式中，$\mu$ 表示磁介质的磁导率，$\boldsymbol{H}$ 表示磁场强度，对有介质存在的环路定理的处理可以参考电位移矢量 $\boldsymbol{D}$；     </p>
<h2 id="第三章-电磁感应与电磁场"><a href="#第三章-电磁感应与电磁场" class="headerlink" title="第三章 电磁感应与电磁场"></a>第三章 电磁感应与电磁场</h2><p><img src="https://s1.ax1x.com/2022/10/22/xcHROS.md.jpg" alt="xcHROS.md.jpg" style="zoom:200%;" /></p>
<h3 id="第一讲-电磁感应的基本规律"><a href="#第一讲-电磁感应的基本规律" class="headerlink" title="第一讲 电磁感应的基本规律"></a>第一讲 电磁感应的基本规律</h3><h4 id="1-1-电动势"><a href="#1-1-电动势" class="headerlink" title="1.1 电动势"></a>1.1 电动势</h4><p>闭合回路上：</p>
<script type="math/tex; mode=display">
\xi = \oint\boldsymbol{E}_k\cdot d\boldsymbol{l}</script><p>对于一段电路$ab$：</p>
<script type="math/tex; mode=display">
\xi = \int_a^b\boldsymbol{E}_k\cdot d\boldsymbol{l}</script><p>其中，$\boldsymbol{E}_k$表示非静电性电场强度；    </p>
<h4 id="1-2-法拉第电磁感应定律"><a href="#1-2-法拉第电磁感应定律" class="headerlink" title="1.2 法拉第电磁感应定律"></a>1.2 法拉第电磁感应定律</h4><script type="math/tex; mode=display">
\xi_i=-\frac{d\Phi}{dt}</script><p>由楞次定律确定方向$\Rightarrow$方向相反；    </p>
<h4 id="1-3-多匝串联线圈"><a href="#1-3-多匝串联线圈" class="headerlink" title="1.3 多匝串联线圈"></a>1.3 多匝串联线圈</h4><script type="math/tex; mode=display">
\xi_i=-\frac{d}{dt}(\sum_{k=1}^N\Phi_k)=-\frac{d\Psi}{dt}</script><script type="math/tex; mode=display">
\xi_i=-\frac{d\Psi}{dt}=-N\frac{d\Phi}{dt}(\Phi_i=\Phi_j, 1 \leq i,j \leq N)</script><p>其中，$\Psi=\sum_{k=1}^N\Phi_k$表示穿过各线圈的总磁通量，称为磁通链数；     </p>
<h3 id="第二讲-动生电动势-感生电动势"><a href="#第二讲-动生电动势-感生电动势" class="headerlink" title="第二讲 动生电动势 感生电动势"></a>第二讲 动生电动势 感生电动势</h3><h4 id="2-1-动生电动势"><a href="#2-1-动生电动势" class="headerlink" title="2.1 动生电动势"></a>2.1 动生电动势</h4><p>导体棒$ab$产生的动生电动势：</p>
<script type="math/tex; mode=display">
\xi_i=\int_a^b\boldsymbol{E}_k\cdot d\boldsymbol{l}=\int_a^b(\boldsymbol{v}\times\boldsymbol{B})\cdot d\boldsymbol{l}</script><p>闭合回路产生的动生电动势：</p>
<script type="math/tex; mode=display">
\xi_i=\oint_Ld\xi_i=\oint_L(\boldsymbol{v}\times\boldsymbol{B})\cdot d\boldsymbol{l}</script><h4 id="2-2-感生电动势"><a href="#2-2-感生电动势" class="headerlink" title="2.2 感生电动势"></a>2.2 感生电动势</h4><p>感生电场假说$\Rightarrow$有旋电场<br>回路固定不动时：</p>
<script type="math/tex; mode=display">
\xi_i=\oint_L\boldsymbol{E}_V\cdot d\boldsymbol{l}=-\iint_S\frac{\partial \boldsymbol{B}}{\partial t}\cdot d\boldsymbol{S}</script>]]></content>
      <categories>
        <category>大学物理</category>
      </categories>
      <tags>
        <tag>大物</tag>
      </tags>
  </entry>
  <entry>
    <title>导数的综合应用</title>
    <url>/2022/10/20/%E5%AF%BC%E6%95%B0%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="第七讲、导数的综合应用"><a href="#第七讲、导数的综合应用" class="headerlink" title="第七讲、导数的综合应用"></a>第七讲、导数的综合应用</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210231137608.png" alt=""><br>注解：式中</p>
<script type="math/tex; mode=display">
\frac{\partial(F,G)}{\partial(y,z)}=\left|\begin{array}{c}F_y & F_z\\G_y & G_z \end{array}\right|</script><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210231146576.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210231151279.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210231426722.png" alt=""></p>
<h3 id="七、典型例题"><a href="#七、典型例题" class="headerlink" title="七、典型例题"></a>七、典型例题</h3><h4 id="7-1-方程实根的讨论"><a href="#7-1-方程实根的讨论" class="headerlink" title="7.1 方程实根的讨论"></a>7.1 方程实根的讨论</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210231444545.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210231445906.png" alt=""></p>
<h4 id="7-2-导数几何应用"><a href="#7-2-导数几何应用" class="headerlink" title="7.2 导数几何应用"></a>7.2 导数几何应用</h4>]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>微分中值定理</title>
    <url>/2022/10/16/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="第五讲、微分中值定理"><a href="#第五讲、微分中值定理" class="headerlink" title="第五讲、微分中值定理"></a>第五讲、微分中值定理</h2><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210161916050.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210161921095.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210161925822.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210161926024.png" alt=""></p>
<h3 id="五、典型例题"><a href="#五、典型例题" class="headerlink" title="五、典型例题"></a>五、典型例题</h3><h4 id="5-1-中值定理极限讨论"><a href="#5-1-中值定理极限讨论" class="headerlink" title="5.1 中值定理极限讨论"></a>5.1 中值定理极限讨论</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210161949559.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210162053502.png" alt=""></p>
<h4 id="5-2-含一个中值的等式证明"><a href="#5-2-含一个中值的等式证明" class="headerlink" title="5.2 含一个中值的等式证明"></a>5.2 含一个中值的等式证明</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181840565.png" alt=""><br>注解：<strong>【罗尔定理】</strong>怎样由待证明等式构造函数，寻找两个零点；以及原函数与二阶导数同时存在时怎样利用一阶导数构造函数；    </p>
<p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181854544.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181854337.png" alt=""></p>
<p><strong>【一道经典题目】</strong>    </p>
<p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181910099.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181911586.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181912493.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181927169.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181927558.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181928459.png" alt=""><br>注解：泰勒公式运用以及两端点泰勒展开式作差，最值定理以及介值定理；   </p>
<p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181935473.png" alt=""><br>注解：整体思路和上一道题目类似，特别注意<strong>积分上限函数</strong>的运用以及连续导数；    </p>
<p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181943530.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181943811.png" alt=""><br>注解：怎样由<strong>三角函数</strong>结合待证明等式构造辅助函数，寻找两个零点；   </p>
<h4 id="5-3-含多个中值的等式证明"><a href="#5-3-含多个中值的等式证明" class="headerlink" title="5.3 含多个中值的等式证明"></a>5.3 含多个中值的等式证明</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210181958654.png" alt=""><br>注解：$F(x)$怎样构造的，借助$f(a+b-x)$巧妙地利用条件$f(a)=0$构造$F(b)=0$，以及构造$m、n$作为函数指数；     </p>
<p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182015730.png" alt=""><br>注解：这道题目准备工作很重要，设定$c = a/(a+b)$以及介值定理$f(\mu)=c$；     </p>
<p><strong>【同型题目】</strong><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182021005.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182021741.png" alt=""></p>
<p><strong>柯西中值定理</strong><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182030140.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182031770.png" alt=""></p>
<h4 id="5-4-含中值不等式的证明"><a href="#5-4-含中值不等式的证明" class="headerlink" title="5.4 含中值不等式的证明"></a>5.4 含中值不等式的证明</h4><p><strong>极限保号性</strong><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182040859.png" alt=""><br>注解：这一类题目注重拉格朗日中值定理的应用，因为通过$Lagrange$中值定理可以判断取值范围；       </p>
<p><strong>反证法</strong><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182053243.png" alt=""><br>注解：构造$x^\alpha G(x)$特别好，从不等式（导函数）中构造原函数；以及最后再次构造原函数，这道题目连续多次构造处理；      </p>
<h4 id="5-5-利用中值定理证明函数性质"><a href="#5-5-利用中值定理证明函数性质" class="headerlink" title="5.5 利用中值定理证明函数性质"></a>5.5 利用中值定理证明函数性质</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182104382.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182104890.png" alt=""><br>注解：此道题目对$f(x+\theta h)$的二阶导函数再次泰勒展开，以及在区$h-&gt; 0$特别好；    </p>
<p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182111905.png" alt=""><br>注解：在处理$g^`(x)=0$时，设定$g(x)$极限为$L$或无穷大；之后假设证明：求极限问题；<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182147647.png" alt=""><br>注解：带绝对值类的题目，对不等式而言尽可能放缩，注意其中二阶导数放缩不大于函数值与一阶导数值之和；    </p>
<p><strong>【拓展】</strong><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182151889.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210182151370.png" alt=""><br>注解：怎样求$f(x)$的导数，以及注意$f(0)$的导数需单独求解，另外对原函数等价于导数的积分处理进一步放缩特别好；</p>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>导数与微分</title>
    <url>/2022/10/14/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="第四讲、导数与微分"><a href="#第四讲、导数与微分" class="headerlink" title="第四讲、导数与微分"></a>第四讲、导数与微分</h2><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210150947774.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210150948701.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210150949084.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210150950494.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210150954031.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210150957582.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151001182.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151005971.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151006420.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151009629.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151017716.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151018484.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151024755.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151025747.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151026169.png" alt=""></p>
<h3 id="隐函数存在定理"><a href="#隐函数存在定理" class="headerlink" title="隐函数存在定理"></a>隐函数存在定理</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151417363.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151417271.png" alt=""></p>
<h2 id="四、典型例题"><a href="#四、典型例题" class="headerlink" title="四、典型例题"></a>四、典型例题</h2><h3 id="4-1-由方程组求导数"><a href="#4-1-由方程组求导数" class="headerlink" title="4.1 由方程组求导数"></a>4.1 由方程组求导数</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151435749.png" alt=""></p>
<h3 id="4-2-等价展开式处理"><a href="#4-2-等价展开式处理" class="headerlink" title="4.2 等价展开式处理"></a>4.2 等价展开式处理</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151436893.png" alt=""></p>
<h3 id="4-3-Taylor-公式求导数"><a href="#4-3-Taylor-公式求导数" class="headerlink" title="4.3 $Taylor$公式求导数"></a>4.3 $Taylor$公式求导数</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151444390.png" alt=""></p>
<h3 id="4-4-Leibniz-公式运用"><a href="#4-4-Leibniz-公式运用" class="headerlink" title="4.4 $Leibniz$公式运用"></a>4.4 $Leibniz$公式运用</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151508577.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151509345.png" alt=""></p>
<h4 id="4-4-1-求高阶导数"><a href="#4-4-1-求高阶导数" class="headerlink" title="4.4.1 求高阶导数"></a>4.4.1 求高阶导数</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151514227.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151514273.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151515512.png" alt=""></p>
<h4 id="4-4-2-综合运用"><a href="#4-4-2-综合运用" class="headerlink" title="4.4.2 综合运用"></a>4.4.2 综合运用</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151519871.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151523339.png" alt=""></p>
<h3 id="4-5-单侧倒数与可导性"><a href="#4-5-单侧倒数与可导性" class="headerlink" title="4.5 单侧倒数与可导性"></a>4.5 单侧倒数与可导性</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151528587.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151614398.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210151614240.png" alt=""></p>
<h3 id="4-6-多元函数连续性与可导性"><a href="#4-6-多元函数连续性与可导性" class="headerlink" title="4.6 多元函数连续性与可导性"></a>4.6 多元函数连续性与可导性</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152011769.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152011451.png" alt=""></p>
<h3 id="4-7-偏导数与全微分"><a href="#4-7-偏导数与全微分" class="headerlink" title="4.7 偏导数与全微分"></a>4.7 偏导数与全微分</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152036350.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152040725.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152040468.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152045549.png" alt=""><br>注解：当函数$u=f(x,y,z)$对$\theta$偏导数等于零时，则说明函数与该变量无关（或不含有或为常量）；<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152050892.png" alt=""><br>注解：信息挖掘，$F(rcos\theta,rsin\theta)=h(r)$，根据$h(r)$不含有$theta$可得对$\theta$偏导数等于零，于是$F$对于$\theta$偏导数也等于零；        </p>
<h3 id="4-8-方向导数与梯度"><a href="#4-8-方向导数与梯度" class="headerlink" title="4.8 方向导数与梯度"></a>4.8 方向导数与梯度</h3><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152100015.png" alt=""><br>注解：注意坐标转换；<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152103825.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210152103222.png" alt=""></p>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数模C题</title>
    <url>/2022/05/13/%E6%95%B0%E6%A8%A1C%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数模C题总结"><a href="#数模C题总结" class="headerlink" title="数模C题总结"></a>数模C题总结</h2><h4 id="第一部分——问题分析"><a href="#第一部分——问题分析" class="headerlink" title="第一部分——问题分析"></a>第一部分——问题分析</h4><p>拆分问题，将各个问题进行拆分，尤其是效果分析类的</p>
<h4 id="第一部分——数据预处理"><a href="#第一部分——数据预处理" class="headerlink" title="第一部分——数据预处理"></a>第一部分——数据预处理</h4><p><strong>数据探索性分析</strong>      </p>
<pre><code>箱型图======&gt;探究是否有偏好情况=======&gt;决定了之后问题解决是否要考虑材料种类差异
对数直方图、洛伦兹图======&gt;探究数据是否存在数量级差异以及数据的均衡程度
散点图======&gt;探究数据的分布情况
</code></pre><h4 id="第二部分——评价类"><a href="#第二部分——评价类" class="headerlink" title="第二部分——评价类"></a>第二部分——评价类</h4><p><strong>熵权法-TOPSIS</strong>    </p>
<pre><code>叙述:
熵权法通过计算指标的信息熵，根据其相对变化程度对系统的整体影响来决定权重，避免了
层次分析法等主观赋权法的弊端，获取权重的客观性较强。在得到权重后， 利用 TOPSIS
方法将它们综合， TOPSIS 法通过构建评价问题的正理想解和负理想解，计算每个方案到理
想方案的相对贴近度来对方案进行排序，最终求解出最优方案。
</code></pre><h4 id="第三部分——横纵向分析"><a href="#第三部分——横纵向分析" class="headerlink" title="第三部分——横纵向分析"></a>第三部分——横纵向分析</h4><pre><code>模型构建分析时，直接显著点出横向角度和纵向角度（一般有时间）来分析
核密度曲线
季节性分解
</code></pre><p>_机会约束叙述：_<br><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172332648-38102188.png" alt="">     </p>
<pre><code>蒙特卡洛法
针状图====&gt;检验有效数据的完整性      
</code></pre><h4 id="第四部分——方案实施效果分析"><a href="#第四部分——方案实施效果分析" class="headerlink" title="第四部分——方案实施效果分析"></a>第四部分——方案实施效果分析</h4><pre><code>绘制数据结果图=====&gt;结合图像说明或解释
变化面积图
置信因子α灵敏度分析:
分别取置信因子α=0.85， 0.9， 0.95对约束进行松弛，可以得到丌同的决策集合。
随着置信度𝛼的上升，随机变量𝜉的少数极端抖动造成约束条件难以满足， 迫使企
业需要增大订单量来对冲风险，亍是表现为总订单额的升高。
类似的，对亍转运损失率，随着置信度𝛼的上升，转运损失率也在违约率高的周
内相应明显升高，这也进一步印证了前文关亍损失率和违约率的机理猜测。    
</code></pre><h4 id="第五部分——惩罚因子"><a href="#第五部分——惩罚因子" class="headerlink" title="第五部分——惩罚因子"></a>第五部分——惩罚因子</h4><pre><code>问题三只在问题二的基础上改变了一点要求，即尽量多地采购A 类和尽量少地采购C类原材料，
可以考虑为每立方米 A、 B、 C 三种材料分别赋予惩罚因子为 1、 5、10，以惩罚函数最小为目标，约束同问题二，建立右图所示的觃划模型。转运方案制定不方案实施效果分析同问题二。
</code></pre>]]></content>
      <tags>
        <tag>数模</tag>
      </tags>
  </entry>
  <entry>
    <title>栈进阶数据结构</title>
    <url>/2022/10/08/%E6%A0%88%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<h3 id="一、栈维护最值"><a href="#一、栈维护最值" class="headerlink" title="一、栈维护最值"></a>一、栈维护最值</h3><p>时间复杂度<code>O(1)</code>；设置三个栈<code>A、B、C</code>，其中<code>A</code>栈存储原始数据，<code>B、C</code>栈分别维护栈中最小值和最大值:<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 进栈操作</span><br>A.<span class="hljs-built_in">push</span>(x);<br>B.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(B.<span class="hljs-built_in">top</span>(),x));<br>C.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">max</span>(C.<span class="hljs-built_in">top</span>(),x));<br><span class="hljs-comment">// 出栈操作</span><br>A.<span class="hljs-built_in">pop</span>();<br>B.<span class="hljs-built_in">pop</span>();<br>C.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure></p>
<h3 id="二、对顶栈"><a href="#二、对顶栈" class="headerlink" title="二、对顶栈"></a>二、对顶栈</h3><p>应用思想：始终在序列中间某个指定位置进行修改；<br>建立两个栈，<code>A</code>栈存储从序列开头到当前位置的这一段子序列，栈<code>B</code>存储当前位置到序列结尾处的这一段子序列，二者都以当前位置那一端作为栈顶。<br>栈求  <strong>_最大前缀和_</strong>  时，用一个数组<code>f</code>维护栈<code>A</code>的最大前缀和；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A的栈顶位置下标pA，使用数组模拟栈</span><br><span class="hljs-comment">// sum是A的前缀和数组</span><br>A.<span class="hljs-built_in">push</span>(x);<br>sum[pA]=sum[pA<span class="hljs-number">-1</span>]+A[pA];<br>f[pA] = <span class="hljs-built_in">max</span>(f[pA<span class="hljs-number">-1</span>],sum[pA]);<br></code></pre></td></tr></table></figure>
<h3 id="三、单调栈"><a href="#三、单调栈" class="headerlink" title="三、单调栈"></a>三、单调栈</h3><p>单调栈算法：时间复杂度<code>O(N)</code>，处理问题思想在于 <strong>_及时排除不可能的选项，保持策略集合的高度有效性和秩序性_</strong><br>应用：需要维护一个单调的序列并且可以不断从一端插入或删除<br>典例：<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081928282.png" alt=""><br>思路分析:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081937079.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 数组模拟栈：往往更快一些</span><br>a[n+<span class="hljs-number">1</span>] = p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// p为栈顶位置，初始为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<br>&#123;<br>	<span class="hljs-keyword">if</span>(a[i] &gt; s[p])&#123; <span class="hljs-comment">// 矩形高度大于栈顶高度时直接进栈</span><br>		s[++p] = a[i];<br>		w[p] = <span class="hljs-number">1</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// 否则依次比较、寻找不高于当前矩形的位置</span><br>		<span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(s[p] &gt; a[i])&#123;<br>			width += w[p];<span class="hljs-comment">// 宽度叠加</span><br>			<span class="hljs-comment">// 这里s[p]是当前栈顶的高度值，ans记录最终的最大值</span><br>			ans = <span class="hljs-built_in">max</span>(ans, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)width*s[p]); <br>			p--;<br>		&#125;<br>		<span class="hljs-comment">// 更新栈，基于当前栈顶位置</span><br>		s[++p] = a[i],w[p] = width + <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵转置</title>
    <url>/2022/10/10/%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="稀疏矩阵转置"><a href="#稀疏矩阵转置" class="headerlink" title="稀疏矩阵转置"></a>稀疏矩阵转置</h3><p>本文采用顺序存储结构的三元组表压缩存储稀疏矩阵，并基于此数据结构对稀疏矩阵进行转置，介绍两种转置处理方法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//---------------稀疏矩阵的三元组顺序表存储表示-------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 500</span><br><span class="hljs-comment">// 抽象数据类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    ElemType value;<br>&#125;Triple;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Triple data[MAXSIZE + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> rows, cols, nums;  <span class="hljs-comment">// 行列和非零元数 </span><br>&#125;TSMatrix;<br><br><br><span class="hljs-function">Status <span class="hljs-title">TransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; T)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">FastTransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; FT)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixRead</span><span class="hljs-params">(TSMatrix&amp; M)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixPrint</span><span class="hljs-params">(TSMatrix M)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TSMatrix M, T, FT;<br>    <span class="hljs-built_in">TSMatrixRead</span>(M);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before Transpose Matrix:\n&quot;</span>;<br>    <span class="hljs-built_in">TSMatrixPrint</span>(M);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After Transpose Matrix:\n&quot;</span>;<br>    <span class="hljs-built_in">TransposeMatrix</span>(M, T);<br>    <span class="hljs-built_in">TSMatrixPrint</span>(T);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After FastTranspose Matrix:\n&quot;</span>;<br>    <span class="hljs-built_in">FastTransposeMatrix</span>(M, FT);<br>    <span class="hljs-built_in">TSMatrixPrint</span>(FT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">TransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br>    T.rows = M.cols; T.cols = M.rows; T.nums = M.nums;<br>    <span class="hljs-keyword">if</span> (T.nums) &#123;    <span class="hljs-comment">// 如果矩阵非空</span><br>        <span class="hljs-type">int</span> q = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">1</span>; col &lt;= M.cols; col++) &#123;  <span class="hljs-comment">// 指定循环M列序保证T矩阵的行主序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= M.nums; p++) &#123;  <span class="hljs-comment">// 搜寻M中当前列元素</span><br>                <span class="hljs-comment">// M又是按照行主序存储的，所以M每一列的列序即是T中每一行的行序</span><br>                <span class="hljs-keyword">if</span> (M.data[p].j == col) &#123;<br>                    T.data[q].i = M.data[p].j;<br>                    T.data[q].j = M.data[p].i;<br>                    T.data[q].value = M.data[p].value;<br>                    q++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">FastTransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; FT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 快速转置算法</span><br>    <span class="hljs-comment">// 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br>    FT.rows = M.cols; FT.cols = M.rows; FT.nums = M.nums;<br>    <span class="hljs-keyword">if</span> (FT.nums) &#123;  <span class="hljs-comment">// 矩阵非空</span><br>        <span class="hljs-type">int</span>* num = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[M.cols + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>* cpot = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[M.cols + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 记录矩阵M中每一列的元素个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">1</span>; col &lt;= M.cols; col++) num[col] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= M.nums; ++t) ++num[M.data[t].j];<br>        <span class="hljs-comment">// 记录矩阵M中，每一列的首非零元在三元组表中的下标位置</span><br>        cpot[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 默认第一个元素从首位置开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">2</span>; col &lt;= M.cols; col++) cpot[col] = cpot[col - <span class="hljs-number">1</span>] + num[col - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 累加定位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= M.nums; p++) &#123;<br>            <span class="hljs-type">int</span> col = M.data[p].j;<br>            <span class="hljs-type">int</span> q = cpot[col];  <span class="hljs-comment">// 提取位置编号</span><br>            <span class="hljs-comment">// 元素放置</span><br>            FT.data[q].i = M.data[p].j;<br>            FT.data[q].j = M.data[p].i;<br>            FT.data[q].value = M.data[p].value;<br>            <span class="hljs-comment">// 后移控制=====&gt;填充三元组表</span><br>            cpot[col]++;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixRead</span><span class="hljs-params">(TSMatrix&amp; M)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix rows, cols and nums:\n&quot;</span>;<br>    cin &gt;&gt; M.rows &gt;&gt; M.cols &gt;&gt; M.nums;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix elements:\n&quot;</span>;<br>    <span class="hljs-comment">// 这里默认输入是行主序的</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M.nums; i++) &#123;<br>        cin &gt;&gt; M.data[i].i &gt;&gt; M.data[i].j &gt;&gt; M.data[i].value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixPrint</span><span class="hljs-params">(TSMatrix M)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 由三元组表输出标准矩阵</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M.rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= M.cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (M.data[cnt].i == i &amp;&amp; M.data[cnt].j == j)<br>                cout &lt;&lt; M.data[cnt++].value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里给出一个演示算例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input Matrix rows, cols and nums:</span><br><span class="hljs-comment">3 4 4</span><br><span class="hljs-comment">Input Matrix elements:</span><br><span class="hljs-comment">1 1 3</span><br><span class="hljs-comment">1 4 5</span><br><span class="hljs-comment">2 2 -1</span><br><span class="hljs-comment">3 1 2</span><br><span class="hljs-comment">Before Transpose Matrix:</span><br><span class="hljs-comment">3 0 0 5</span><br><span class="hljs-comment">0 -1 0 0</span><br><span class="hljs-comment">2 0 0 0</span><br><span class="hljs-comment">After Transpose Matrix:</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">0 -1 0</span><br><span class="hljs-comment">0 0 0</span><br><span class="hljs-comment">5 0 0</span><br><span class="hljs-comment">After FastTranspose Matrix:</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">0 -1 0</span><br><span class="hljs-comment">0 0 0</span><br><span class="hljs-comment">5 0 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛——概述</title>
    <url>/2022/04/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="算法竞赛"><a href="#算法竞赛" class="headerlink" title="算法竞赛"></a>算法竞赛</h2><hr>
<h3 id="卡常技巧"><a href="#卡常技巧" class="headerlink" title="卡常技巧"></a>卡常技巧</h3><p><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929165652647-2103037728.png" alt="">            </p>
<p>注：最终的取模操作或者是在中间过程取模，使得不出现负数的余数</p>
<h3 id="rand（）函数生成随机数时一定要考虑RAND-MAX的值"><a href="#rand（）函数生成随机数时一定要考虑RAND-MAX的值" class="headerlink" title="rand（）函数生成随机数时一定要考虑RAND_MAX的值"></a>rand（）函数生成随机数时一定要考虑RAND_MAX的值</h3><h3 id="函数调用时，对其参数求值的顺序就是未指定的。"><a href="#函数调用时，对其参数求值的顺序就是未指定的。" class="headerlink" title="函数调用时，对其参数求值的顺序就是未指定的。"></a>函数调用时，对其参数求值的顺序就是未指定的。</h3><h3 id="评测系统返回的错误信息："><a href="#评测系统返回的错误信息：" class="headerlink" title="评测系统返回的错误信息："></a>评测系统返回的错误信息：</h3><pre><code>* CE(compiler error): 无法编译成可执行文件（不算罚时)
* TL(TIMELIMIT):时间超限
* RE(RUN-ERROR):
    ○ return返回值非0，未正常退出
    ○ 也可能是内存超限
    ○ 内存开得过大也可能报错
* OL(OUTPUT-LIMIT):输出超限
    ○ 可能陷入了带输出的死循环
    ○ 忘记删除调试输出
    ○ 有时只是WA的一种表现形式
* WA(WRONG-ANSWER):
    ○ 空白字符(行末空格和文末回车），因此每行应以&quot;\n&quot;结束
</code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><pre><code>Ø 栈溢出主要表现：
    ○ RUN-ERROR
    ○ 段错误
    ○ segmentation fault (core dumped)
Ø 预防排查
    ○    避免死递归
    ○ 热身赛可以测试评测系统是否调整了栈空间
    ○ 全局变量：
    不要将巨大的数组或结构体声明为自动局部变量或按值传递的参数，可以开全局或者静态变量，通过指针/引用传递
</code></pre><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>   未定义行为：<br>    § 带符号整数算术运算溢出<br>    § 移位位数超过整数位数<br>    § 使用 scanf 读取数字时，输入超过格式化字符串指定的表示范围<br>    § 浮点数转化为整数时，其值超过了整数类型能表示的范围<br>  以下行为可能导致出人意料的结果：<br>    § 无符号整数算术运算溢出 (丢弃高位)<br>    § 使用 cin 读取数字时，输入超过变量的表示范围 (读入错误的值，并设定 failbit)<br>    § 整数类型互相转化时高位被丢弃<br>    § 浮点数转化为整数时小数部分被截断<br>    § 浮点数精度问题导致负0的出现</p>
<h3 id="常见错误的预防和排查"><a href="#常见错误的预防和排查" class="headerlink" title="常见错误的预防和排查"></a>常见错误的预防和排查</h3><pre><code>I 开始编码前预先考虑好输入、中间结果、最终结果的可能范围 
I 该取模的模（指中间过程就开始取模运算，因为结果直接取模一般没必要） 
I 该开 64 位和 128 位整数的开 
I 该转型的转：1ll * a * b（转换成long long型的避免运算时结果溢出）
I 该换语言的换（指python方便处理时用）
I 该写高精度的写（不能用python时，必要就写） 
I 打开编译器相关警告选项（辅助） 
I 编造数据测试是否有溢出 
I 如果测试过程中发现溢出，打开运行时检查工具 
I 如果确实需要溢出，使用无符号整数 
I 反对盲目蛮干
</code></pre><h3 id="无效指针"><a href="#无效指针" class="headerlink" title="无效指针"></a>无效指针</h3><pre><code>Ø 未初始化的指针使用就是未定义行为 
Ø 越出数组界限的指针 
    ○ 对不指向数组中元素的指针进行偏移运算是未定义的 
    ○ 对指向数组中元素的指针进行偏移运算，越出数组范围 (结果不指向同一数组中的元素，或该数组最后一个元素“之后的一个元素”)，行为是未定义的
Ø 预防和排查
    ○ 数组开得尽量大
    ○ 对指针和数组下标进行必要检查
    ○ 打开运行时检查进行检查
</code></pre><h3 id="无效迭代器"><a href="#无效迭代器" class="headerlink" title="无效迭代器"></a>无效迭代器</h3><p>在一些 (可能意想不到的) 情况下，迭代器会失效变成非法的<br>    Ø 迭代器不能越界<br>    Ø 例1：<br>    预防与排查：<br>        ○ 不要滥用迭代器<br>        ○ 在range-based for循环中，不要对迭代的容器进行插入或删除操作<br>        ○ 在 set、map、multiset、multimap、list 等中进行删除操作时，可以使用 c.erase(it++) 的写法<br>        对于 C++11 以上，还支持 it = c.erase(it) 的写法<br>        ○ 如果怀疑使用了无效迭代器，可以打开 C++ 标准库的运行时检查</p>
<h3 id="超时的分析"><a href="#超时的分析" class="headerlink" title="超时的分析"></a>超时的分析</h3><pre><code>Ø 算法的选择不合适
Ø 算法合适，但某个细节未考虑，导致高次时间复杂度
举例：

&lt;1&gt;循环多次调用strlen(s)，时间复杂度 O(n2)
&lt;2&gt;对大的数组，如果每组数据用的数组内存较少而数据组数较多时，多次memset会做很多无用功，导致时间复杂度较高 O(mn)
Ø 常数太大
I 典型代表：endl 或者忘了用 cin.tie(0)、valarray
预防和排查：
</code></pre>]]></content>
  </entry>
  <entry>
    <title>链表与邻接表</title>
    <url>/2022/10/13/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h3><p><strong>数组模拟双向链表</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-type">int</span> value;<br>	<span class="hljs-type">int</span> prev, next;<br>&#125;node[SIZE];<br><span class="hljs-type">int</span> head, tail, tot;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	tot = <span class="hljs-number">2</span>;    <span class="hljs-comment">//控制节点存储位置</span><br>	head = <span class="hljs-number">1</span>,tail = <span class="hljs-number">2</span>;<br>	node[head].next = tail;<br>	node[tail].prev = head;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 在p点后向链表中插入一个节点</span><br>	q = ++tot;  <span class="hljs-comment">// 向节点数组中申请空间</span><br>	node[q].value = val;<br>	<span class="hljs-comment">// 交接</span><br>	node[node[p].next].prev = q;  <br>	node[q].next = node[p].next;<br>	node[p].next = q;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 移除p节点</span><br>	node[node[p].prev].next = node[p].next;<br>	node[node[p].next].prev = node[p].prev;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(node, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(node));<br>	head = tail = tot = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="二、二叉平衡树"><a href="#二、二叉平衡树" class="headerlink" title="二、二叉平衡树"></a>二、二叉平衡树</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<h3 id="三、邻接表"><a href="#三、邻接表" class="headerlink" title="三、邻接表"></a>三、邻接表</h3><ul>
<li>邻接表：带有索引数组的多个数据链表构成的结构集合；</li>
<li>在这样的结构中存储的数据被分成若干类，每一类的数据构成一个链表；</li>
<li>每一类数据有一个代表元素，成为该类数据对应链表的“表头”；</li>
<li>所有“表头”构成一个表头数组，作为一个可以随机访问的索引；<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210132241493.png" alt=""><br>如上图所示，在插入新节点时，通过表头数组直接索引到对应数据类的链表处，并在链表表头处插入数据。    <h4 id="图论应用"><a href="#图论应用" class="headerlink" title="图论应用"></a>图论应用</h4><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210132244755.png" alt=""><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>队列进阶数据结构</title>
    <url>/2022/10/13/%E9%98%9F%E5%88%97%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一、基本队列"><a href="#一、基本队列" class="headerlink" title="一、基本队列"></a>一、基本队列</h3><h4 id="相对等效"><a href="#相对等效" class="headerlink" title="相对等效"></a>相对等效</h4><p>对于给定的一个序列，如果每次操作都需要改变大部分数据，数学运算一个相同的算子，而只有少部分数据不需要改变；则可以通过逆向改变少部分数据，赋予一个逆算子，进行相应运算化简，记录相对差量，最终换算为数据结果。  </p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210111444054.png" alt=""><br>分析思路：<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210111444904.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210111445005.png" alt=""><br>其中应当证明在依次选取 $x_1, x_2$ 时，对应的第一秒后 $[px_1], x_1-[px_1], x_2+q$，在 $x_2$ 的一秒后 $[px_1]+q, x_1-[px_1]+q, [p(x_2+q)], (x_2+q)-[p(x_2+q)]$，则易证 $[px_1]+q &gt; [p(x_2+q)]$， $x_1-[px_1]+q &gt; (x_2+q)-[p(x_2+q)]$，进而推广到任意两段满足 $x_1 &gt;= x_2$ 时，只要 $x_1$ 在 $x_2$ 之前被取出，不论之后是否接着取 $x_2$，还是直接取 $x_1$ 分出的两端，或是其他段，都等效于最开始的 $x_2$。</p>
<h3 id="二、单调队列——基于双端队列"><a href="#二、单调队列——基于双端队列" class="headerlink" title="二、单调队列——基于双端队列"></a>二、单调队列——基于双端队列</h3><p>单调队列是指队列中元素之间的关系始终保持单调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。（注意是始终保持）<br>单调队列功能：在每次加入或者删除元素时都保持序列里的元素有序，即队首元素始终是最小值或者最大值。   </p>
<h4 id="最大子序和——单调队列算法"><a href="#最大子序和——单调队列算法" class="headerlink" title="最大子序和——单调队列算法"></a>最大子序和——单调队列算法</h4><p><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210111848537.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210111849219.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210111849692.png" alt=""><br>最优策略集合：下标位置递增、对应的前缀和<code>S</code>的值也递增<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;  <span class="hljs-comment">// l指向队头，r指向队尾</span><br>q[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 保存决策的基于数组的模拟队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 枚举最右端节点i</span><br>	<span class="hljs-comment">// Step 1:</span><br>	<span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; (i - q[l]) &gt; m) l++; <span class="hljs-comment">// 边界判断，最多只能选m个数，否则队首出队</span><br>	<span class="hljs-comment">// Step 2:</span><br>	ans = <span class="hljs-built_in">max</span>(ans, sum[i]-sum[q[l]]); <span class="hljs-comment">// 寻找最大值，sum[]表示数组前缀和</span><br>	<span class="hljs-comment">// Step 3:</span><br>	<span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; sum[q[r]] &gt;= sum[i]) r--;  <span class="hljs-comment">//更新，删除不小于i结点对应的队列元素</span><br>	q[++r] = i;<br>&#125;<br></code></pre></td></tr></table></figure><br>时间复杂度：$O(N)$<br>注解：</p>
<ul>
<li>$Step   1$：检查队首，如果队首指向的下标小于等于 $i-m$，即相对于 $i$ 而言，队首的元素已经跑出区间 $[i-m+1, i]$，子序列长度超过了 $m$，那么弹出队首元素，对应操作 $l++$；对最大连续子序列和问题而言，在上一轮中队首元素对应的最长子序列的和已经计算并比较存入 $ans$ 中，此时进入新元素后，队首元素已经属于无效元素，所以直接出队；</li>
<li>$Step   2$：相对于右端点 $i$ 而言，队首元素 $q[l]$ 对应的便是最优左端点 $j$；</li>
<li>$Step   3$：检查队尾，如果队尾元素大于或等于要添加的值，则弹出队尾元素，对应操作 $r-  -$，目的就是保持队首元素一直是最小值，且队列单调；</li>
<li>$Step   4$：更新队尾，$q[++r]=i$，首先 $++r$ 为新元素腾出位置，加入元素的下标；<br>解释： <ul>
<li>根据前面分析的结论，以相对于右端点 $i$ 来看，如果 $sum[q[r]] &gt;= sum[i]$，最大连续子序列和一定不会是 $q[r]$ 对应的元素节点,因为此时 $sum[q[l]] &lt;= sum[q[r]]$，比较而言 $q[l]$ 更优；</li>
<li>如果不弹出 $q[r]$,那么当 $q[l]==q[r]$ 时，此时会出现 $sum(q[l]) &gt;= sum(q[l+1])$,很明显在这种条件下，决策 $q[l+1]$ 优于决策 $q[l]$，因为相对于右端点  $i$ 选 $q[l+1]$ 可以获得不劣于 $q[l]$ 的最大连续和，因此没有必要保留 $q[r]$;</li>
<li>$q[i]$ 替换 $q[r]$ 机制，当需要弹出队尾元素 $q[r]$ 时，$r- -$ 之后 $Step   4$ 再次更新序列对应元素处在队列中的决策下标为新元素节点 $q[i]$，当下一轮 $l==r$ 时，$q[l]=q[i]$ 直接索引下一元素的下标；</li>
</ul>
</li>
</ul>
<p>单调队列思想：在决策集合（队列）中及时排除一定不是最优解的选择。<br>单调队列模板：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> data[N+<span class="hljs-number">1</span>];    <span class="hljs-comment">// 原始数据序列集合</span><br><span class="hljs-type">int</span> q[N];       <span class="hljs-comment">// 用于模拟单调队列的数组</span><br><span class="hljs-type">int</span> k = Nnum;    <span class="hljs-comment">// 支持的最大区间长度</span><br><span class="hljs-type">int</span> head = <span class="hljs-number">1</span>,tail = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 初始队列没有元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>	<span class="hljs-keyword">while</span>(head &lt;= tail <span class="hljs-keyword">and</span> q[head] &lt;= i - k) head++; <span class="hljs-comment">//队首检查：保证队列长度合法</span><br>	<span class="hljs-keyword">while</span>(head &lt;= tail <span class="hljs-keyword">and</span> data[q[tail]] &gt;= data[i]) tail--; <span class="hljs-comment">// 队尾检查：保证队列单调性</span><br>	q[++tail] = i; <span class="hljs-comment">//插入新元素</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序栈</title>
    <url>/2022/10/03/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈的顺序存储表示"><a href="#栈的顺序存储表示" class="headerlink" title="栈的顺序存储表示"></a>栈的顺序存储表示</h2><hr>
<h3 id="1、顺序存储结构"><a href="#1、顺序存储结构" class="headerlink" title="1、顺序存储结构"></a>1、顺序存储结构</h3><p>利用一组地址连续的存储单元<br><strong>顺序栈定义</strong>：   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;Sqstack;<br></code></pre></td></tr></table></figure>
<p>_注：当用数组作为存储结构时，可以用下标代替指针_      </p>
<h3 id="2、基本操作算法描述"><a href="#2、基本操作算法描述" class="headerlink" title="2、基本操作算法描述"></a>2、基本操作算法描述</h3><p>对栈的常用操作做简要描述：      </p>
<ul>
<li><p>栈的初始化     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以初始化容量申请一块连续的内存，<code>S.top=S.base</code>保证<code>top=base</code>时栈空。    </p>
</li>
<li><p>返回栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == S.base)  <span class="hljs-keyword">return</span> ERROR;<br>    e = *(S.base<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>压栈操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>出栈操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>判断栈空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>清空栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用栈空标志进行清空</span><br>    S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>释放栈空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">free</span>(S.base);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3、栈的应用举例"><a href="#3、栈的应用举例" class="headerlink" title="3、栈的应用举例"></a>3、栈的应用举例</h3><h4 id="3-1-数制转换"><a href="#3-1-数制转换" class="headerlink" title="3.1 数制转换"></a>3.1 数制转换</h4><p>十进制数与其他d进制数转换时，一个简单算法原理：<br><code>N = (N div d) X d + N mod d</code>,其中<code>div</code>表示整除操作，<code>mod</code>表示求余操作     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Conversion</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType data;<br>    <span class="hljs-type">int</span> Obj = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; data &gt;&gt; Obj;<br>    <span class="hljs-keyword">while</span>(data)&#123;<br>        <span class="hljs-built_in">Push</span>(S,data % Obj);<br>        data = data/Obj;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">StackEmpty</span>(S))<br>    &#123;<br>        SElemType e;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Pop</span>(S,e)) <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; e;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对于输入的十进制数和目标进制，打印输出目标进制数</span><br>    <span class="hljs-built_in">Conversion</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-行编辑程序"><a href="#3-2-行编辑程序" class="headerlink" title="3.2 行编辑程序"></a>3.2 行编辑程序</h4><p>将用户从键盘输入的符号存入一个输入缓冲区，然后逐行存入用户数据区；这个过程允许用户删除字符，删除整行字符<br>基本操作规则：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 退格符<br>@ 退行符<br>^ 结束符<br></code></pre></td></tr></table></figure>
<p>程序实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackPrint</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    SElemType *mp = S.base;<br>    <span class="hljs-keyword">while</span>(mp != S.top)&#123;<br>        <span class="hljs-built_in">putchar</span>(*mp);<br>        mp++;<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用栈空标志进行清空</span><br>    S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">free</span>(S.base);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-function">Status <span class="hljs-title">LineEdit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构造字符栈</span><br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType ch;<br>    ch = <span class="hljs-built_in">getchar</span>();  <span class="hljs-comment">//从终端接受一个字符</span><br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span>)&#123;<br>        <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            <span class="hljs-keyword">switch</span>(ch)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-built_in">Pop</span>(S,ch);  <span class="hljs-comment">//退字符</span><br>                         <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>:<span class="hljs-built_in">ClearStack</span>(S); <span class="hljs-comment">//退行</span><br>                         <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<span class="hljs-built_in">Push</span>(S,ch); <span class="hljs-comment">//字符入栈</span><br>            &#125;<br>            ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//从终端接受下一个字符</span><br>        &#125;<br>        <span class="hljs-comment">//对缓冲区的一行字符存入数据区，这里只是打印输出</span><br>        <span class="hljs-built_in">StackPrint</span>(S);<br>        <span class="hljs-built_in">ClearStack</span>(S);<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-built_in">DestroyStack</span>(S);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LineEdit</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-3-括号匹配问题"><a href="#3-3-括号匹配问题" class="headerlink" title="3.3 括号匹配问题"></a>3.3 括号匹配问题</h4><p>给定一个包含各种括号的表达式，判断是否满足括号匹配<br>利用栈操作，可在线性时间内检查出是否匹配，具体实现如下：   </p>
</li>
<li><p>利用<code>STL</code>模板库</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">paren</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> exp[])</span> </span>&#123; <span class="hljs-comment">//表达式括号匹配检查，可兼顾三种括号</span><br>    Stack&lt;<span class="hljs-type">char</span>&gt; S; <span class="hljs-comment">//使用栈记录已出现但尚未匹配的左括号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; exp[i]; i++) <span class="hljs-comment">/* 逐一检查当前字符 */</span><br>        <span class="hljs-keyword">switch</span> (exp[i]) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: S.<span class="hljs-built_in">push</span>(exp[i]); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;(&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;[&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;&#123;&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>自定义栈操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;    <span class="hljs-comment">//栈元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">SElemType <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">return</span> *--S.top;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">paren</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//构造字符栈</span><br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType ch;<br>    ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>        <span class="hljs-keyword">switch</span> (ch) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-built_in">Push</span>(S, ch); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;(&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;[&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;&#123;&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>        &#125;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">StackEmpty</span>(S);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">paren</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-4-表达式求值"><a href="#3-4-表达式求值" class="headerlink" title="3.4 表达式求值"></a>3.4 表达式求值</h4><hr>
<p><strong>_延迟缓冲_</strong><br>    在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算<br>往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后,才能作出判断并实施计算。在这类场合，栈结构则可以扮演数据缓冲区的角色。</p>
<hr>
<p>表达式求值<br>    关于运算符执行次序的规则(即运算优先级)，一部分决定于事先约定的惯例(比如乘除优先于加减)，另一部分则决定于括号。也就是说，仅根据表达式的某一前缀，并不能完全确定其中各运算符可否执行以及执行的次序；只有在已获得足够多后续信息之后，才能确定其中哪些运算符可以执行。<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081906581.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081907925.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081909380.png" alt=""><br>    由于栈基本结构较为简单，常用操作内容上文已经介绍，因此本代码在此处调用<code>STL</code>中<code>stack</code>模板直接进行相关操作。       </p>
<ul>
<li>定义优先级表      </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_OPTR 9 <span class="hljs-comment">//运算符总数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Opr 100  <span class="hljs-comment">//表达式最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE&#125; Operator; <span class="hljs-comment">//运算符集合</span><br> <span class="hljs-comment">//加、减、乘、除、乘斱、阶乘、左括号、右括号、起始符不终止符</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> pri[N_OPTR][N_OPTR] = &#123; <span class="hljs-comment">//运算符优先等级 [栈顶] [弼前]</span><br><span class="hljs-comment">/* |-------------- 当前运算符 --------------| */</span><br><span class="hljs-comment">/* + - * / ^ ! ( ) \0 */</span><br><span class="hljs-comment">/* -- + */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* | - */</span>  <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 栈 * */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 顶 / */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 运 ^ */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 算 ! */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 符 ( */</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>,<br><span class="hljs-comment">/* | ) */</span>  <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>,<br><span class="hljs-comment">/* -- \0*/</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; p, stack&lt;<span class="hljs-type">float</span>&gt;&amp; stk)</span> </span>&#123; <span class="hljs-comment">//将起始于p癿子串解析为数值，并存入操作数栈</span><br>    stk.<span class="hljs-built_in">push</span>((<span class="hljs-type">float</span>)(*p - <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//当前数位对应的数值进栈</span><br>    <span class="hljs-comment">// 处理多位整数情况</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(*(++p)))&#123;<br>        <span class="hljs-type">float</span> temp = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">push</span>(temp * <span class="hljs-number">10</span> + (*p - <span class="hljs-string">&#x27;0&#x27;</span>));   <span class="hljs-comment">//弹出原操作数，转换新数值重新入栈</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;.&#x27;</span> != *p) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">//此后非小数点，则意味着当前操作数解析完成</span><br><br>    <span class="hljs-comment">//处理小数部分  fraction设置挺关键</span><br>    <span class="hljs-type">float</span> fraction = <span class="hljs-number">1</span>; <span class="hljs-comment">//否则，意味着还有小数部分 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(*(++p)))&#123; <span class="hljs-comment">//逐位加入</span><br>        <span class="hljs-type">float</span> temp = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">push</span>(temp + (*p - <span class="hljs-string">&#x27;0&#x27;</span>)*(fraction /= <span class="hljs-number">10</span>)); <span class="hljs-comment">//小数部分</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function">Operator <span class="hljs-title">optr2rank</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123; <span class="hljs-comment">//由运算符转译出编号</span><br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-keyword">return</span> ADD; <span class="hljs-comment">//加</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-keyword">return</span> SUB; <span class="hljs-comment">//减</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> : <span class="hljs-keyword">return</span> MUL; <span class="hljs-comment">//乘</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> : <span class="hljs-keyword">return</span> DIV; <span class="hljs-comment">//除</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span> : <span class="hljs-keyword">return</span> POW; <span class="hljs-comment">//乘斱</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span> : <span class="hljs-keyword">return</span> FAC; <span class="hljs-comment">//阶乘</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span> : <span class="hljs-keyword">return</span> L_P; <span class="hljs-comment">//左括号</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span> : <span class="hljs-keyword">return</span> R_P; <span class="hljs-comment">//右括号</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>: <span class="hljs-keyword">return</span> EOE; <span class="hljs-comment">//起始符与终止符</span><br>        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">//未知运算符</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">orderBetween</span><span class="hljs-params">(<span class="hljs-type">char</span> op1, <span class="hljs-type">char</span> op2)</span> <span class="hljs-comment">//比较两个运算符之间的优先级</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> pri[<span class="hljs-built_in">optr2rank</span>(op1)][<span class="hljs-built_in">optr2rank</span>(op2)]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; rpn, <span class="hljs-type">float</span> opnd)</span> </span>&#123; <span class="hljs-comment">//将操作数接至RPN末尾</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//分数值类型进行压栈</span><br>    <span class="hljs-keyword">if</span> (opnd != (<span class="hljs-type">float</span>)(<span class="hljs-type">int</span>)opnd) <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%.2f \0&quot;</span>, opnd); <span class="hljs-comment">//浮点格式，或</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%d \0&quot;</span>, (<span class="hljs-type">int</span>)opnd); <span class="hljs-comment">//整数格式</span><br><br>    <span class="hljs-keyword">if</span>(rpn==<span class="hljs-literal">NULL</span>)&#123;<br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (<span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">strcpy</span>(rpn,buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(rpn); <span class="hljs-comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span><br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">realloc</span>(rpn, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (n + <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>)); <span class="hljs-comment">//扩展空间</span><br>        <span class="hljs-built_in">strcat</span>(rpn, buf); <span class="hljs-comment">//RPN加长</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; rpn, <span class="hljs-type">char</span> optr)</span> </span>&#123; <span class="hljs-comment">//将运算符接至RPN末尾</span><br>    <span class="hljs-keyword">if</span>(rpn == <span class="hljs-literal">NULL</span>)&#123;<br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (<span class="hljs-number">3</span>));<br>        <span class="hljs-built_in">sprintf</span>(rpn, <span class="hljs-string">&quot;%c &quot;</span>, optr); rpn[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//接入指定癿运算符</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(rpn); <span class="hljs-comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span><br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">realloc</span>(rpn, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (n + <span class="hljs-number">3</span>)); <span class="hljs-comment">//扩展空间</span><br>        <span class="hljs-built_in">sprintf</span>(rpn + n, <span class="hljs-string">&quot;%c &quot;</span>, optr); rpn[n + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//接入指定癿运算符</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">char</span> op, <span class="hljs-type">float</span> data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 一元计算</span><br>    <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)data == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum_data = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(<span class="hljs-type">int</span>)data;i++) sum_data *= i;<br>    <span class="hljs-keyword">return</span> sum_data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">float</span> opd1,<span class="hljs-type">char</span> op, <span class="hljs-type">float</span> opd2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//前后操作数</span><br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> opd1+opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> opd1-opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> opd1*opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> opd1/opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(opd1,opd2);<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                  <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-type">char</span>* S, <span class="hljs-type">char</span>*&amp; RPN, <span class="hljs-type">float</span> &amp;result)</span> </span>&#123; <span class="hljs-comment">//对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN</span><br>    stack&lt;<span class="hljs-type">float</span>&gt; opnd; stack&lt;<span class="hljs-type">char</span>&gt; optr; <span class="hljs-comment">//运算数栈、运算符栈</span><br>    optr.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;\0&#x27;</span>); <span class="hljs-comment">//尾哨兵&#x27;\0&#x27;也作为头哨兵首先入栈，主要为了判断计算结束退出</span><br>    <span class="hljs-keyword">while</span> (!optr.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">//在运算符栈非空之前，逐个处理表达式中各字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(*S)) &#123; <span class="hljs-comment">//若当前字符为操作数，则</span><br>            <span class="hljs-built_in">readNumber</span>(S, opnd);   <span class="hljs-comment">// 读入操作数</span><br>            <span class="hljs-built_in">append</span>(RPN, opnd.<span class="hljs-built_in">top</span>()); <span class="hljs-comment">//并将其接至RPN末尾</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//若当前字符为运算符，则</span><br>            <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">orderBetween</span>(optr.<span class="hljs-built_in">top</span>(), *S)) &#123; <span class="hljs-comment">//视其与栈顶运算符之间优先级高低分别处理</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-comment">//栈顶运算符优先级更低时</span><br>                    optr.<span class="hljs-built_in">push</span>(*S); S++; <span class="hljs-comment">//计算推迟，当前运算符入栈</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>: <span class="hljs-comment">//优先级相等（当前运算符为右括号或者尾部哨兵&#x27;\0&#x27;）时</span><br>                    optr.<span class="hljs-built_in">pop</span>(); S++; <span class="hljs-comment">//脱括号并接收下一个字符</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>: &#123; <span class="hljs-comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span><br>                    <span class="hljs-type">char</span> op = optr.<span class="hljs-built_in">top</span>();<br>                    optr.<span class="hljs-built_in">pop</span>(); <br>                    <span class="hljs-built_in">append</span>(RPN, op); <span class="hljs-comment">//栈顶运算符出栈并续接至RPN末尾</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;!&#x27;</span> == op) &#123; <span class="hljs-comment">//若属于一元运算符</span><br>                        <span class="hljs-type">float</span> pOpnd = opnd.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//叧需取出一个操作数，并</span><br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        opnd.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calcu</span>(op, pOpnd)); <span class="hljs-comment">//实施一元计算，结果入栈</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//对于其它（二元）运算符</span><br>                        <span class="hljs-type">float</span> pOpnd2 = opnd.<span class="hljs-built_in">top</span>();<br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> pOpnd1 = opnd.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//取出后、前操作数</span><br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        opnd.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calcu</span>(pOpnd1, op, pOpnd2)); <span class="hljs-comment">//实施二元计算，结果入栈</span><br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//逢语法错误，并做处理直接退出</span><br>            &#125;<span class="hljs-comment">//switch</span><br>    &#125;<span class="hljs-comment">//while</span><br>    result = opnd.<span class="hljs-built_in">top</span>();<br>    opnd.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//弹出并返回最后的计算结果</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>* RPN = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> S[Opr] = &#123;<span class="hljs-number">0</span>&#125;;<br>    cin &gt;&gt; S;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">evaluate</span>(S,RPN,ans))<br>        cout &lt;&lt; <span class="hljs-string">&quot;Ans = &quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Reverse Polish Notation:\n&quot;</span>;<br>    cout &lt;&lt; RPN;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>算法计算示例:<br>计算给定表达式<code>(0!+1)*2^(3!+4)-(5!-67-(8+9))</code>的值<br>运行结果   <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Result">Ans = 988<br>Reverse Polish Notation:<br>0 ! 1 + 2 3 ! 4 + ^ * 5 ! 67 - 8 9 + - -<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
