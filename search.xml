<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Latex基本操作</title>
    <url>/2022/10/04/Latex%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Latex学习一————基本结构"><a href="#Latex学习一————基本结构" class="headerlink" title="Latex学习一————基本结构"></a>Latex学习一————基本结构</h3><h4 id="1-1-主体结构"><a href="#1-1-主体结构" class="headerlink" title="1.1 主体结构"></a>1.1 主体结构</h4><p>源程序分为导言区和正文区，其中导言区设置文章的一些性质或自定义命令，选定文档类命令为<code>\documentclass&#123;article&#125;</code>，设置文章属性可以加入命令<code>\title&#123;&#125;</code>,<code>\auther&#123;&#125;</code>,<code>\date&#123;&#125;</code><br>正文区又称文稿区，设置文档环境命令<code>\begin&#123;document&#125;</code>,<code>\end&#123;document&#125;</code>,一篇文档有且只能设置一个文档环境。       </p>
<h4 id="1-2-部分命令"><a href="#1-2-部分命令" class="headerlink" title="1.2 部分命令"></a>1.2 部分命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\maketitle</span> <span class="hljs-comment">% 生成标题，用在`book/report/article`类的正文区中，而`letter`类在正文区并没有此命令。                    </span><br><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span>  <span class="hljs-comment">% 单`$`命令主要用于行内公式书写     </span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-comment">% 而双`$$`命令用于行间公式    </span><br><span class="hljs-keyword">\tableofcontents</span>  <span class="hljs-comment">% 输出文章目录       </span><br><span class="hljs-keyword">\bibliographystyle</span>   <span class="hljs-comment">% 声明参考文献的格式     </span><br><span class="hljs-keyword">\footnote</span>&#123;&#125;   <span class="hljs-comment">% 在正文后面设置脚注，花括号内的部分是命令的参数，即脚注的内容。   </span><br><span class="hljs-keyword">\emph</span>&#123;&#125;  <span class="hljs-comment">% 改变字体形状，表示强调(emphasis)的内容     </span><br><span class="hljs-keyword">\begin</span>&#123;quote&#125;<br><span class="hljs-comment">% 将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。</span><br><span class="hljs-comment">% 同时设置引用的字体</span><br><span class="hljs-keyword">\zihao</span>&#123;-5&#125;<span class="hljs-keyword">\kaishu</span>   <span class="hljs-comment">% 设置字号和字体命令  会影响后面所有文字(环境内)</span><br><span class="hljs-comment">% 注：\zihao&#123;&#125;有参数，-5即小五号</span><br><span class="hljs-keyword">\end</span>&#123;quote&#125;<br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>文章摘要环境，在<span class="hljs-keyword">\maketitle</span>之后设置<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br></code></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 导言区</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;    <span class="hljs-comment">% book,report,letter</span><br><br><span class="hljs-keyword">\title</span>&#123;My First Document&#125;<br><span class="hljs-keyword">\author</span>&#123;MarkStiff&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-comment">% 正文区(文稿区)</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>	<span class="hljs-keyword">\maketitle</span><br>	Hello World!<br>	<br>	<span class="hljs-comment">% here is my big formula</span><br>	Let <span class="hljs-built_in">$</span>f(x)<span class="hljs-built_in">$</span> be defined by the formula <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>f(x)=3x<span class="hljs-built_in">^</span>2+x-1<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> which is a polynomial of degree 2.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
<p>生成效果图:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/1.png" alt=""></p>
<h3 id="Latex学习二————中文文档设置"><a href="#Latex学习二————中文文档设置" class="headerlink" title="Latex学习二————中文文档设置"></a>Latex学习二————中文文档设置</h3><h4 id="2-1-文档整体设置"><a href="#2-1-文档整体设置" class="headerlink" title="2.1 文档整体设置"></a>2.1 文档整体设置</h4><ul>
<li>可以加入<code>\usepackage&#123;ctex&#125;</code>命令使用扩展包；</li>
<li>直接设置整体文档类<code>\documentclass[UTF8]&#123;ctexart&#125;</code>,此外还有<code>ctexbook ctexrep</code>    </li>
</ul>
<p>可选参数表明中文文档的编码，主要有<code>GBK和UTF8</code>，不同<code>Latex</code>编辑器默认编码方式不同。      </p>
<h4 id="2-2-equation环境"><a href="#2-2-equation环境" class="headerlink" title="2.2 equation环境"></a>2.2 <code>equation</code>环境</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2.<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
<p>此环境命令主要是用于产生带编号的行间公式。</p>
<h4 id="2-4-章节设置"><a href="#2-4-章节设置" class="headerlink" title="2.4 章节设置"></a>2.4 章节设置</h4><p><code>\section&#123;章节标题&#125;</code>生成一节的标题   </p>
<h4 id="2-3-中文字体设置"><a href="#2-3-中文字体设置" class="headerlink" title="2.3 中文字体设置"></a>2.3 中文字体设置</h4><h5 id="字体族设置"><a href="#字体族设置" class="headerlink" title="字体族设置"></a>字体族设置</h5><p>——罗马字体、无衬线字体、打字机字体</p>
<ul>
<li>字体命令<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\textrm</span>&#123;文本&#125; <span class="hljs-comment">% 设置字体族为罗马字体</span><br><span class="hljs-keyword">\textsf</span>&#123;文本&#125;  <span class="hljs-comment">% 无衬线字体</span><br><span class="hljs-keyword">\texttt</span>&#123;文本&#125;  <span class="hljs-comment">% 打字机字体</span><br></code></pre></td></tr></table></figure></li>
<li>字体声明命令<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\rmfamily</span> 文本    <span class="hljs-comment">% 声明以后的字体使用罗马字体</span><br><span class="hljs-keyword">\sffamily</span> 文本 <span class="hljs-comment">% 无衬线字体</span><br><span class="hljs-keyword">\ttfamily</span> 文本  <span class="hljs-comment">% 打字机字体</span><br>&#123;<span class="hljs-keyword">\rmfamily</span> 文本&#125;  <span class="hljs-comment">% 使用括号限定字体声明范围</span><br></code></pre></td></tr></table></figure>
<h5 id="字体系列设置"><a href="#字体系列设置" class="headerlink" title="字体系列设置"></a>字体系列设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Pass<br></code></pre></td></tr></table></figure>
<h3 id="Latex学习三————-杂谈"><a href="#Latex学习三————-杂谈" class="headerlink" title="Latex学习三———— 杂谈"></a>Latex学习三———— 杂谈</h3><h4 id="3-1-定理环境"><a href="#3-1-定理环境" class="headerlink" title="3.1 定理环境"></a>3.1 定理环境</h4>文章定理之类的是用一类定理环境输出的，在使用之前需要在导言区做定义:<br><code>\newtheorem&#123;thm&#125;&#123;定理&#125;</code><br>定理环境有一个指定定理名字的可选参数，示例:      <figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;thm&#125;[勾股定理]<br>直角三角形斜边的平方等于两腰的平方和。<br><br>可以用符号语言表述为······<br>起源于6--7年份  <span class="hljs-comment">% 表示数字范围时可以用两个减号来输出Latex中的短横线</span><br><span class="hljs-keyword">\end</span>&#123;thm&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-数学公式"><a href="#3-2-数学公式" class="headerlink" title="3.2 数学公式"></a>3.2 数学公式</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 行间公式 行内公式 pass</span><br><span class="hljs-keyword">\angle</span> ACB = <span class="hljs-keyword">\pi</span>/2    <span class="hljs-comment">% 角符号以及使用pi命令</span><br>f<span class="hljs-built_in">_</span>pump   <span class="hljs-comment">% &#x27;_&#x27; 命令下标设置</span><br>f<span class="hljs-built_in">^</span>2      <span class="hljs-comment">% &#x27;^&#x27; 命令上标设置</span><br><span class="hljs-comment">% 注：如果上下标不止一个符号则需要用花括号进行分组</span><br>90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span>   <span class="hljs-comment">% 设置角度上标</span><br></code></pre></td></tr></table></figure>
实际效果如图:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/20221006213148.png" alt=""></li>
</ul>
<h4 id="3-3-使用图表"><a href="#3-3-使用图表" class="headerlink" title="3.3 使用图表"></a>3.3 使用图表</h4><ul>
<li><p>插图功能<br>插图功能由<code>graphicx</code>宏包提供，需要在导言区进行设置<br><code>\usepackage&#123;graphicx&#125;</code><br>具体的插图命令为：<br><code>\includegraphics[width=3cm]&#123;xiantu.pdf&#125;</code><br>其中可选参数设置图片在文档中的宽度，第二个参数是图形的文件名（放在源文件所在目录）<br>使用xelatex命令编译时，支持的图形格式包括PDF、PNG、JPG、FPS等<br><strong>_图形放置_</strong><br>通常将图像放置在一个浮动体中，处于一个可以变动相对位置的环境中    </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;figure&#125;[ht]    <span class="hljs-comment">% 设置浮动体环境</span><br>	<span class="hljs-keyword">\centering</span>   <span class="hljs-comment">% 表示后面的内容居中</span><br>	<span class="hljs-keyword">\includegraphics</span>[scale=0.6]&#123;cover.jpg&#125;<br>	<span class="hljs-keyword">\caption</span>&#123;博客封面设计图&#125; <span class="hljs-comment">% 给插图加自动编号和标题</span><br>	<span class="hljs-keyword">\label</span>&#123;fig:封面图&#125;  <span class="hljs-comment">% 设置插图标签</span><br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br></code></pre></td></tr></table></figure>
<p>注：可选参数<code>ht</code>表示浮动体可以出现在环境周围的文本所在处(<code>here</code>)和一页的底部(<code>top</code>)<br>具体效果图如下：<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210071411539.png" alt=""></p>
</li>
<li><p>制作表格<br>设置表格环境<code>tabular</code>：    </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|rrr|&#125;<br>	<span class="hljs-keyword">\hline</span><br>	直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边  <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>		3 <span class="hljs-built_in">&amp;</span>   4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>		5 <span class="hljs-built_in">&amp;</span>   12 <span class="hljs-built_in">&amp;</span>   13<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure>
<p>注：</p>
</li>
<li><p>可选参数<code>|rrr|</code>表示表格有三列，都是右对齐，行与行之间用<code>\\</code>隔开，列于列之间用<code>&amp;</code>隔开，表格中的横线用<code>\hline</code>绘制    </p>
</li>
<li>表格环境设置，一般表格也放置在浮动体中，即<code>table</code>环境<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\usepackage</span>&#123;float&#125;<br><span class="hljs-keyword">\begin</span>&#123;table&#125;[H] <span class="hljs-comment">% 使用H参数表示设置表格不浮动，需要在导言区添加float宏包</span><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|lll|&#125;<br>	<span class="hljs-keyword">\hline</span><br>	直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边  <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>	3 <span class="hljs-built_in">&amp;</span>   4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>	5 <span class="hljs-built_in">&amp;</span>   12 <span class="hljs-built_in">&amp;</span>   13<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<span class="hljs-comment">%</span><br><span class="hljs-keyword">\qquad</span>  <span class="hljs-comment">% 此命令可以产生两个M宽度的空格</span><br>(<span class="hljs-built_in">$</span>a<span class="hljs-built_in">^</span>2 + b<span class="hljs-built_in">^</span>2 = c<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span>)<br><span class="hljs-keyword">\end</span>&#123;table&#125;   <br></code></pre></td></tr></table></figure>
效果图:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210071412672.png" alt=""></li>
</ul>
<h4 id="3-4-图表引用"><a href="#3-4-图表引用" class="headerlink" title="3.4 图表引用"></a>3.4 图表引用</h4><ul>
<li>图片引用<br>根据上文插图设置的标签属性可以很容易引用图片一个示例：<code>图\ref&#123;fig:xiantu&#125;是我国古代对勾股定理的一种证明</code>。        </li>
<li>公式引用<br>公式添加标签示例:<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<span class="hljs-keyword">\label</span>&#123;eq:gougu&#125;   <span class="hljs-comment">% 设定公式标签名</span><br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
在正文中引用示例: <code>(\ref&#123;eq:gougu&#125;)</code>注意公式引用的括号要手动添加<br>另解，使用宏包<code>amsmath</code>,在导言区添加宏包，之后通过命令<code>\eqref&#123;eq:gougu&#125;</code>引用，并能自动产生括号 </li>
</ul>
<h4 id="3-5-设计文章格式"><a href="#3-5-设计文章格式" class="headerlink" title="3.5 设计文章格式"></a>3.5 设计文章格式</h4><p>一般设置文章整体格式可以借用宏包直接进行处理，现列举较为常用的文章格式宏包:<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\usepackage</span>&#123;gemetry&#125;   <span class="hljs-comment">% 设计页面尺寸宏包</span><br><span class="hljs-keyword">\geometry</span>&#123;a4paper,centering,scale=0.8&#125;  <span class="hljs-comment">% 定义A4纸大小，版心居中，宽0.8倍</span><br><br><span class="hljs-keyword">\usepackage</span>[format=hang,font=small,texfont=it]&#123;caption&#125;   <span class="hljs-comment">% 改变图表标题格式</span><br><span class="hljs-comment">% 设定图表标题悬挂对齐，整体用小字号，标题文本使用斜体（对汉字而言是楷书）</span><br><span class="hljs-keyword">\usepackage</span>[nottoc]&#123;tocbibind&#125;  <span class="hljs-comment">% 增加目录的项目</span><br><span class="hljs-comment">% 宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身</span><br></code></pre></td></tr></table></figure><br><strong>_自定义环境_</strong><br>如果需要设置特定的段落环境，可以利用已有的环境在导言区构造新的环境，以达到增加格式控制的目的<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 这里对引用(quote)环境重新设置，增加更多格式控制命令</span><br><span class="hljs-keyword">\newenvironment</span>&#123;myquote&#125;<br>	&#123;<span class="hljs-keyword">\begin</span>&#123;quote&#125;<span class="hljs-keyword">\kaishu</span><span class="hljs-keyword">\zihao</span>&#123;-5&#125;&#125;<br>	&#123;<span class="hljs-keyword">\end</span>&#123;quote&#125;&#125;<br><span class="hljs-comment">% 这里新环境由环境名字、环境开始代码和环境末尾代码三个参数，这样在导言区定义可以重复使用</span><br><span class="hljs-comment">% 使用</span><br><span class="hljs-keyword">\begin</span>&#123;myquote&#125;<br>text······<br><span class="hljs-keyword">\end</span>&#123;myquote&#125;<br></code></pre></td></tr></table></figure><br><strong>_自定义命令_</strong><br>在一些需要的地方，<code>Latex</code>给我们提供了自定义新的命令的代码，这极大地拓展了不同背景和领域使用的便利性。   </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 这里以角度上标为例</span><br><span class="hljs-keyword">\newcommand</span><span class="hljs-keyword">\degree</span>&#123;<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span>&#125;      <span class="hljs-comment">% 在导言区定义</span><br><span class="hljs-built_in">$</span>90<span class="hljs-keyword">\degree</span><span class="hljs-built_in">$</span> = <span class="hljs-built_in">$</span>90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span><span class="hljs-built_in">$</span>  <br></code></pre></td></tr></table></figure>
<p>插图版式调整后效果:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210071440767.png" alt=""></p>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex篇章结构</title>
    <url>/2022/10/16/Latex%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一、构建小节"><a href="#一、构建小节" class="headerlink" title="一、构建小节"></a>一、构建小节</h3><ul>
<li>小节<code>\section&#123;&#125;</code></li>
<li>子小节<code>\subsection&#123;&#125;</code></li>
<li>子子小节<code>\subsubsection&#123;&#125;</code></li>
<li>生成目录<code>\tableofcontents</code></li>
<li>换行<code>\\</code>或者<code>\par</code>:产生新的段落<br>具体效果如下图：<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210162213125.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210162214021.png" alt=""><h3 id="二、章节大纲"><a href="#二、章节大纲" class="headerlink" title="二、章节大纲"></a>二、章节大纲</h3>命令<code>\chapter&#123;&#125;</code><br>在使用之前需要更换文本类型，设置<code>\documentclass&#123;ctexbook&#125;</code><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture202211021151912.png" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex组织文本</title>
    <url>/2022/10/07/Latex%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%84%E7%BB%87%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="一、标点符号"><a href="#一、标点符号" class="headerlink" title="一、标点符号"></a>一、标点符号</h3><h4 id="1-1-引号"><a href="#1-1-引号" class="headerlink" title="1.1 引号"></a>1.1 引号</h4><p><code>Latex</code>使用<code>‘’</code>来表示引号，如果遇到连续使用单引号和双引号的情形，则需要使用<code>\,</code>命令隔开，会产生很小的间距</p>
<h4 id="1-2-符号"><a href="#1-2-符号" class="headerlink" title="1.2 符号-"></a>1.2 符号<code>-</code></h4><ul>
<li>数学减号</li>
<li>单独使用时表示连字符</li>
<li>两个连用时，是<code>en dash</code>，表示数字范围</li>
<li>三个连用时，是<code>em dash</code>，即破折号</li>
</ul>
<p><code>~</code>符号命令：数学模式<code>$\sim$</code>    </p>
<h4 id="1-3-省略号"><a href="#1-3-省略号" class="headerlink" title="1.3 省略号"></a>1.3 省略号</h4><p>西文省略号: <code>\ldots</code>或者<code>\dots</code>，在句中使用时直接命令，而在句末使用时要把省略号放进数学模式中。<br>中文写作使用全角标点，一般由<code>xsCJK</code>宏包控制，可以使用<code>\punctstyle&#123;&#125;</code>命令修改，<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202211021153026.png" alt=""></p>
<h4 id="1-4-空格"><a href="#1-4-空格" class="headerlink" title="1.4 空格"></a>1.4 空格</h4><p>以字母命名的宏后面空格会被自动忽略掉，此时可以使用<code>\</code>命令添加<br>或者添加一个空分组<code>&#123;&#125;</code>分隔，或者<code>&#123;\TeX&#125;</code>包裹进来<br><strong>不可打断的空格(带子)</strong><br>用<code>~</code>表示，<code>function ~$f(x)$</code><br>西方文体中，句末标点和缩写标点问题<br><code>Latex</code>默认在大写字母的点看作缩写标记，小写字母后面的点看作句子结束而设置不同的点间隔；但当特殊情况时需要明确指定具体用法，示例:<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">Tinker et al.<span class="hljs-keyword">\ </span>made the double play.  <span class="hljs-comment">% &#x27;\空格&#x27;命令放在&#x27;.&#x27;后直接分隔单词</span><br><br>Tinker et al,made the double play. <span class="hljs-comment">% 一般情况下标点后需加空格</span><br><br><span class="hljs-keyword">\frenchspacing</span>  <span class="hljs-comment">% 禁止标点后的额外间距</span><br>Roman number XII<span class="hljs-keyword">\@</span>. Yes.  <span class="hljs-comment">% &#x27;\@&#x27;命令放在&#x27;.&#x27;前面只处理&#x27;.&#x27;是句子结束点，之后再添加空格表示正常的句号标点</span><br></code></pre></td></tr></table></figure></p>
<h4 id="1-5-幻影空格"><a href="#1-5-幻影空格" class="headerlink" title="1.5 幻影空格"></a>1.5 幻影空格</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 幻影空格实际上起到占位作用，接受一个参数，生成与参数内容大小一样的空盒子</span><br><span class="hljs-comment">% 类似的还有\hphantom和\vphantom表示水平竖直方向上的幻影</span><br>MarkStiff<span class="hljs-keyword">\phantom</span>&#123;神奇&#125;速速隐形<br><br>MarkStiff神奇速速显形<br></code></pre></td></tr></table></figure>
<h4 id="1-6-换行"><a href="#1-6-换行" class="headerlink" title="1.6 换行"></a>1.6 换行</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\\</span>[2cm]  <span class="hljs-comment">% 命令直接另起一行，上一行保持原样,可选参数设置换行后增加的额外垂直距离</span><br><span class="hljs-keyword">\linebreak</span> <span class="hljs-comment">% 命令指定一行的断点，上一行仍按完整一行散开对齐</span><br></code></pre></td></tr></table></figure>
<h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><h4 id="2-1-字体族格式命令"><a href="#2-1-字体族格式命令" class="headerlink" title="2.1 字体族格式命令"></a>2.1 字体族格式命令</h4><p>带参数命令主要用于少量字体的更换，三种字体族对应的带参数命令，而声明命令主要用偶遇分组或环境中字体的整体更换.<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textrm</span>&#123;Roman font family&#125;<br>	<span class="hljs-keyword">\textsf</span>&#123;Sans serif font family&#125;<br>	<span class="hljs-keyword">\texttt</span>&#123;Typewriter font family&#125;<br>	<br>声明命令<br>	&#123;<span class="hljs-keyword">\rmfamily</span> Roman font family&#125;<br>	&#123;<span class="hljs-keyword">\sffamily</span> Sans serif font family&#125;<br>	&#123;<span class="hljs-keyword">\ttfamily</span> Typewriter font family&#125;<br></code></pre></td></tr></table></figure><br>效果图:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210071651052.png" alt=""></p>
<h4 id="2-2-字体形状命令"><a href="#2-2-字体形状命令" class="headerlink" title="2.2 字体形状命令"></a>2.2 字体形状命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textup</span>&#123;Upright shape&#125;  <span class="hljs-comment">% 直立形状</span><br>	<span class="hljs-keyword">\textit</span>&#123;Italic shape&#125; <span class="hljs-comment">% 意大利形状</span><br>	<span class="hljs-keyword">\textsl</span>&#123;Slanted shape&#125; <span class="hljs-comment">% 倾斜形状</span><br>	<span class="hljs-keyword">\textsc</span>&#123;SMALL CAPITALS SHAPE&#125; <span class="hljs-comment">% 小型大写形状</span><br><br>声明命令<br>	&#123;<span class="hljs-keyword">\upshape</span> Upright shape&#125;<br>	&#123;<span class="hljs-keyword">\itshape</span> Italic shape&#125;<br>	&#123;<span class="hljs-keyword">\slshape</span> Slanted shape&#125;<br>	&#123;<span class="hljs-keyword">\scshape</span> SMALL CAPITALS SHAPE&#125;<br></code></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210071650619.png" alt=""><br>倾斜形状一般是对符号直接倾斜产生的，而通常的“斜体”往往指意大利形状，数学公式的字体一般就使用意大利形状</p>
<h4 id="2-3-字体系列命令"><a href="#2-3-字体系列命令" class="headerlink" title="2.3 字体系列命令"></a>2.3 字体系列命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textmd</span>&#123;Medium series&#125; <span class="hljs-comment">% 中等字体，正文默认使用此系列</span><br>	<span class="hljs-keyword">\textbf</span>&#123;Bold extended series&#125; <span class="hljs-comment">% 加宽加粗</span><br>	<br>声明命令<br>	&#123;<span class="hljs-keyword">\mdseries</span> Medium series&#125; 	<br>	&#123;<span class="hljs-keyword">\bfseries</span> Bold extended series&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-字体坐标"><a href="#2-4-字体坐标" class="headerlink" title="2.4 字体坐标"></a>2.4 字体坐标</h4><p>经上文介绍了字体的三个特征，综合起来构成了确定一种字体的三维坐标：族、形状、系列，不同组合会产生不同的字体效果。<br>具体组合效果图:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210071702667.png" alt=""><br><strong>_恢复普通字体_</strong><br>在复杂的字体环境中，恢复普通字体就显得十分重要了。<br><code>\textnormal&#123;文字&#125; % 带参数命令</code><br><code>&#123;\normalfont 文字&#125; % 声明命令</code><br><strong>_斜体校正_</strong><br>在使用斜体声明<code>\itshape、\slshape</code>时，最后一个倾斜的字体会超过右边界，使得间距过近；<br>而用带参数命令<code>\textit、\textsl</code>时，可以自动修正这个距离，也可以手工使用<code>\/</code>命令进行校正。<br><strong>_禁止校正_</strong><br>有时对于倾斜校正是不必要的，则应关闭带参数倾斜命令的自动校正功能:<br><code>\textit&#123;M\nocorr&#125;M</code> 通过添加命令<code>\nocorr</code>命令来关闭自动校正    </p>
<h4 id="2-5-中文字体族"><a href="#2-5-中文字体族" class="headerlink" title="2.5 中文字体族"></a>2.5 中文字体族</h4><p>对于中文字体，一般只使用不同的字体族进行区分，选择中文字体族使用<code>\CJKfamily</code>命令<br>在<code>ctex</code>宏包及文档下有一些预定义，默认情况下配置了四种字体族：<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">&#123;<span class="hljs-keyword">\heiti</span> 这是黑体&#125;<br>&#123;<span class="hljs-keyword">\songti</span> 这是宋体&#125;<br>&#123;<span class="hljs-keyword">\kaishu</span> 这是楷书&#125;<br>&#123;<span class="hljs-keyword">\fangsong</span> 这是仿宋&#125;<br></code></pre></td></tr></table></figure><br><strong>_组合字体_</strong><br><code>ctex</code>宏包及文档类也定义了一些组合字体，可以让中文也具备使用粗体和意大利体功能，并且重定义<code>\rmfamily</code>使它同时对中文起作用<br>默认的中文字体是<code>rm</code>，正常字体是宋体，粗体是黑体，意大利体是楷体 </p>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>不等式</title>
    <url>/2022/10/20/%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第六讲、不等式"><a href="#第六讲、不等式" class="headerlink" title="第六讲、不等式"></a>第六讲、不等式</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210201907542.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210201908392.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210201908435.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210201909712.png" alt=""></p>
<h3 id="六、典型例题"><a href="#六、典型例题" class="headerlink" title="六、典型例题"></a>六、典型例题</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/10/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树（Binary-Tree-三种遍历算法"><a href="#二叉树（Binary-Tree-三种遍历算法" class="headerlink" title="二叉树（Binary Tree)三种遍历算法"></a>二叉树（Binary Tree)三种遍历算法</h3><p>基于链表结构实现的二叉树又称二叉链表，本文主要介绍二叉树的存储以及先序遍历、中序遍历和后序遍历三种遍历方式的递归和非递归算法：    </p>
<h4 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h4><p>二叉树抽象数据类型定义—— <strong>基于链表实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//----------二叉树的二叉链表存储表示--------------</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> TElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><span class="hljs-comment">// 树节点定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>* lchild, * rchild;<br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><br>二叉树递归构造： 通过指定按照满二叉树的节点输入顺序进行输入，对空树以 ‘.’ 表示<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*---------------------二叉树创建函数------------------*/</span><br><span class="hljs-function">Status <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree&amp; T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归读入二叉树的各元素，因此最开始的T还是指向根节点</span><br>    TElemType ch;<br>    cin &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(T = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        T-&gt;data = ch;          <span class="hljs-comment">// 生成根节点</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);   <span class="hljs-comment">// 递归构造左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);   <span class="hljs-comment">// 递归构造右子树</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="二叉树操作算子"><a href="#二叉树操作算子" class="headerlink" title="二叉树操作算子"></a>二叉树操作算子</h4><p>对二叉树的遍历往往是一个广泛的概念，遍历是对二叉树的每一个节点做一系列操作，其中最简单的就是输出节点数据域，这里只是以输出函数为例说明问题。<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">TreeTransOperator</span><span class="hljs-params">(TElemType e)</span>    <span class="hljs-comment">// 二叉树遍历算子</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对数据元素操作的应用函数</span><br>    cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>总体而言，递归算法较为简单，只需更换二叉树节点三部分的顺序即可，但需要注意的是左子树始终在右子树之前遍历； </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//--------------------递归遍历算法-------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTranRecursion</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*---------------先序遍历二叉树的递归算法-------------------*/</span><br>    <span class="hljs-comment">// 采用二叉链表存储结构，Visit是对数据元素操作应用的函数</span><br>    <span class="hljs-comment">// 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层</span><br>    <span class="hljs-keyword">if</span> (T) &#123;   <span class="hljs-comment">// T所指节点非空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Visit</span>(T-&gt;data)) &#123;      <span class="hljs-comment">// 调用操作函数，Visit采用函数指针，指向操作函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PreOrderTranRecursion</span>(T-&gt;lchild, Visit)) &#123;    <span class="hljs-comment">// 递归调用：Visit所指函数也进行递归</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PreOrderTranRecursion</span>(T-&gt;rchild, Visit))  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">InOrderTranRecursion</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*---------------中序遍历二叉树的递归算法-------------------*/</span><br>    <span class="hljs-comment">// 采用二叉链表存储结构，Visit是对数据元素操作应用的函数</span><br>    <span class="hljs-comment">// 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层</span><br>    <span class="hljs-keyword">if</span> (T) &#123;   <span class="hljs-comment">// T所指节点非空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">InOrderTranRecursion</span>(T-&gt;lchild, Visit)) &#123;      <span class="hljs-comment">// 调用操作函数，Visit采用函数指针，指向操作函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Visit</span>(T-&gt;data)) &#123;    <span class="hljs-comment">// 递归调用：Visit所指函数也进行递归</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">InOrderTranRecursion</span>(T-&gt;rchild, Visit))  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">PostOrderTranRecursion</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*---------------后序遍历二叉树的递归算法-------------------*/</span><br>    <span class="hljs-comment">// 采用二叉链表存储结构，Visit是对数据元素操作应用的函数</span><br>    <span class="hljs-comment">// 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层</span><br>    <span class="hljs-keyword">if</span> (T) &#123;   <span class="hljs-comment">// T所指节点非空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PostOrderTranRecursion</span>(T-&gt;lchild, Visit)) &#123;      <span class="hljs-comment">// 调用操作函数，Visit采用函数指针，指向操作函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PostOrderTranRecursion</span>(T-&gt;rchild, Visit)) &#123;    <span class="hljs-comment">// 递归调用：Visit所指函数也进行递归</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Visit</span>(T-&gt;data))  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//--------------------递归遍历算法-------------------------//  </span><br></code></pre></td></tr></table></figure>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><p>对于递归算法而言，当数据量比较大时，程序的时间复杂度往往较高，不易于直接使用；一个好的处理方式是，将递归函数转换为循环结构进行求解，而通过栈来模拟递归机理；<br>这里给出一个自定义栈模板类的程序，作为非递归算法的数据存储结构：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-comment">//-----------------------自定义栈模板类--------------</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-comment">// 抽象数据类型定义</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TElemType</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span> *next, *pre;    <span class="hljs-comment">// 基于双向链表模拟栈</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TElemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mystack</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&lt;TElemType&gt; *base,*top;   <span class="hljs-comment">// 栈底和栈顶指针</span><br>        <span class="hljs-function">Status <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(!(base = (<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            top = base;    <span class="hljs-comment">// 判断栈空标志</span><br>            base-&gt;data = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 栈顶结点数据域记录栈中元素数</span><br>            base-&gt;next = <span class="hljs-literal">NULL</span>;<br>            base-&gt;pre = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(TElemType e)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&lt;TElemType&gt; *stemp;<br>            <span class="hljs-keyword">if</span>(!(stemp=(<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SqNode&lt;TElemType&gt;)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            top-&gt;next = stemp;<br>            stemp-&gt;data = e;<br>            stemp-&gt;pre = top;<br>            stemp-&gt;next = <span class="hljs-literal">NULL</span>;<br>            top = top-&gt;next; <span class="hljs-comment">// 移动top指针始终位于栈顶</span><br><br>            base-&gt;data++;      <span class="hljs-comment">// 栈元素计数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(TElemType &amp;e)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(top == base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 栈空</span><br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqNode</span>&lt;TElemType&gt; *stemp = top;<br>            top = top-&gt;pre;<br>            top-&gt;next = <span class="hljs-literal">NULL</span>;<br>            e = stemp-&gt;data;<br>            <span class="hljs-built_in">free</span>(stemp);<br><br>            base-&gt;data--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function">Status <span class="hljs-title">Top</span><span class="hljs-params">(TElemType &amp;p)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(top == base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = top-&gt;data;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-function">Status <span class="hljs-title">Empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(top == base) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> base-&gt;data;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><br>有了遍历所依赖的数据栈结构，那么便可以通过模拟递归的机理来进行处理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//--------------------非递归遍历算法-------------------------//</span><br><span class="hljs-comment">//---------------------先序遍历二叉树------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTranverse_1</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先序遍历二叉树T的非递归算法一</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建并初始化遍历二叉链表所需要的栈</span><br>    S.<span class="hljs-built_in">Push</span>(T);    <span class="hljs-comment">// 根指针进栈</span><br>    BiTree p;     <span class="hljs-comment">// 创建二叉树游标指针</span><br>    <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">Top</span>(p) &amp;&amp; p) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            S.<span class="hljs-built_in">Push</span>(p-&gt;lchild);<br>        &#125;<br>        S.<span class="hljs-built_in">Pop</span>(p);    <span class="hljs-comment">// 将向左尽头的空指针弹出</span><br>        <span class="hljs-keyword">if</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>            S.<span class="hljs-built_in">Pop</span>(p);   <span class="hljs-comment">// 根节点出栈</span><br>            S.<span class="hljs-built_in">Push</span>(p-&gt;rchild);   <span class="hljs-comment">// 遍历后转向</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">PreOrderTranverse_2</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先序遍历二叉树T非递归算法二</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建遍历二叉链表所需要的栈</span><br>    BiTree p = T;<br>    <span class="hljs-keyword">while</span> (p || !S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            S.<span class="hljs-built_in">Push</span>(p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 遍历左子树,当p=NULL时未进栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S.<span class="hljs-built_in">Pop</span>(p);<br>            p = p-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//---------------------中序遍历二叉树------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">InOrderTranverse_1</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 中序遍历二叉树T的非递归算法一</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建并初始化遍历二叉链表所需要的栈</span><br>    S.<span class="hljs-built_in">Push</span>(T);    <span class="hljs-comment">// 根指针进栈</span><br>    BiTree p;     <span class="hljs-comment">// 创建二叉树游标指针</span><br>    <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">Top</span>(p) &amp;&amp; p) S.<span class="hljs-built_in">Push</span>(p-&gt;lchild);   <span class="hljs-comment">// 向左走到尽头</span><br>        S.<span class="hljs-built_in">Pop</span>(p);    <span class="hljs-comment">// 将向左尽头的空指针弹出</span><br>        <span class="hljs-keyword">if</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;    <br>            S.<span class="hljs-built_in">Pop</span>(p);   <span class="hljs-comment">// 根节点出栈</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//遍历</span><br>            S.<span class="hljs-built_in">Push</span>(p-&gt;rchild);   <span class="hljs-comment">// 遍历后转向</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InOrderTranverse_2</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 中序遍历二叉树T非递归算法二</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建遍历二叉链表所需要的栈</span><br>    BiTree p = T;<br>    <span class="hljs-keyword">while</span> (p || !S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            S.<span class="hljs-built_in">Push</span>(p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 遍历左子树</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S.<span class="hljs-built_in">Pop</span>(p);<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//---------------------后序遍历二叉树------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTranverse_1</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 后序遍历二叉树T的非递归算法一</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建并初始化遍历二叉链表所需要的栈</span><br>    S.<span class="hljs-built_in">Push</span>(T);    <span class="hljs-comment">// 根指针进栈</span><br>    BiTree p,lastp = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// 创建二叉树游标指针</span><br>    <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">Top</span>(p) &amp;&amp; p) S.<span class="hljs-built_in">Push</span>(p-&gt;lchild);   <span class="hljs-comment">// 向左走到尽头</span><br>        S.<span class="hljs-built_in">Pop</span>(p);    <span class="hljs-comment">// 将向左尽头的空指针弹出</span><br>        <span class="hljs-keyword">if</span> (!S.<span class="hljs-built_in">Empty</span>()) &#123;<br>            S.<span class="hljs-built_in">Top</span>(p);   <span class="hljs-comment">// 获取根节点 </span><br>            <span class="hljs-keyword">if</span> (p-&gt;rchild == <span class="hljs-literal">NULL</span>||p-&gt;rchild == lastp) &#123;   <span class="hljs-comment">// 节点信息无用时直接出栈</span><br>                S.<span class="hljs-built_in">Pop</span>(p);  <span class="hljs-comment">// 此时结点才可出栈</span><br>                lastp = p;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//遍历</span><br>                S.<span class="hljs-built_in">Push</span>(<span class="hljs-literal">NULL</span>);       <span class="hljs-comment">//保证返回上层结点而不是下一轮继续向左走</span><br>            &#125;<span class="hljs-keyword">else</span> S.<span class="hljs-built_in">Push</span>(p-&gt;rchild);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">PostOrderTranverse_2</span><span class="hljs-params">(BiTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 后序遍历二叉树T非递归算法二</span><br>    mystack&lt;BiTree&gt; S; S.<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//创建遍历二叉链表所需要的栈</span><br>    BiTree p = T,lastp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p || !S.<span class="hljs-built_in">Empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            S.<span class="hljs-built_in">Push</span>(p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 遍历左子树,当p=NULL时未进栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S.<span class="hljs-built_in">Top</span>(p);<br>            <span class="hljs-keyword">if</span> (p-&gt;rchild == <span class="hljs-literal">NULL</span> || p-&gt;rchild == lastp) &#123;<br>                S.<span class="hljs-built_in">Pop</span>(p);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                lastp = p;<br>                p = <span class="hljs-literal">NULL</span>;          <span class="hljs-comment">// 往回溯，置于NULL</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> p = p-&gt;rchild;        <span class="hljs-comment">// 控制右移转向</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="主函数设定"><a href="#主函数设定" class="headerlink" title="主函数设定"></a>主函数设定</h4><p>为了直观的观察遍历结果，主函数设定一些输出参数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree T;    <span class="hljs-comment">// 构造一棵二叉树</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input binary tree elements in order: (note: &#x27;.&#x27; means empty tree)\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateBiTree</span>(T)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Space allocate error!\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;------------------Binary Recursion Traverse----------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Binary Tree First Order Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">PreOrderTranRecursion</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Middle Order Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">InOrderTranRecursion</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Post Order Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">PostOrderTranRecursion</span>(T, TreeTransOperator);<br><br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;------------------Binary NonRecursion Traverse-------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Binary Tree First Order Traverse 1:\n&quot;</span>;<br>    <span class="hljs-built_in">PreOrderTranverse_1</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree First Order Traverse 2:\n&quot;</span>;<br>    <span class="hljs-built_in">PreOrderTranverse_2</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Middle Order Traverse 1:\n&quot;</span>;<br>    <span class="hljs-built_in">InOrderTranverse_1</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Middle Order Traverse 2:\n&quot;</span>;<br>    <span class="hljs-built_in">InOrderTranverse_2</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Post Order Traverse 1:\n&quot;</span>;<br>    <span class="hljs-built_in">PostOrderTranverse_1</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Binary Tree Post Order Traverse 2:\n&quot;</span>;<br>    <span class="hljs-built_in">PostOrderTranverse_2</span>(T, TreeTransOperator);<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">One Example:</span><br><span class="hljs-comment">Input binary tree elements in order: (note: &#x27;.&#x27; means empty tree)</span><br><span class="hljs-comment">A B C . . D E . G . . F . . .</span><br><span class="hljs-comment">------------------Binary Recursion Traverse----------------------</span><br><span class="hljs-comment">Binary Tree First Order Traverse:</span><br><span class="hljs-comment">A B C D E G F</span><br><span class="hljs-comment">Binary Tree Middle Order Traverse:</span><br><span class="hljs-comment">C B E G D F A</span><br><span class="hljs-comment">Binary Tree Post Order Traverse:</span><br><span class="hljs-comment">C G E F D B A</span><br><span class="hljs-comment">------------------Binary NonRecursion Traverse-------------------</span><br><span class="hljs-comment">Binary Tree First Order Traverse 1:</span><br><span class="hljs-comment">A B C D E G F</span><br><span class="hljs-comment">Binary Tree First Order Traverse 2:</span><br><span class="hljs-comment">A B C D E G F</span><br><span class="hljs-comment">Binary Tree Middle Order Traverse 1:</span><br><span class="hljs-comment">C B E G D F A</span><br><span class="hljs-comment">Binary Tree Middle Order Traverse 2:</span><br><span class="hljs-comment">C B E G D F A</span><br><span class="hljs-comment">Binary Tree Post Order Traverse 1:</span><br><span class="hljs-comment">C G E F D B A</span><br><span class="hljs-comment">Binary Tree Post Order Traverse 2:</span><br><span class="hljs-comment">C G E F D B A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十字链表</title>
    <url>/2022/10/10/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="稀疏矩阵的十字链表表示"><a href="#稀疏矩阵的十字链表表示" class="headerlink" title="稀疏矩阵的十字链表表示"></a>稀疏矩阵的十字链表表示</h3><p>本文对矩阵采用链式存储结构实现三元组的线性表，整个存储结构称作十字链表，并基于此数据结构实现矩阵运算<code>A+B</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//-----------稀疏矩阵的十字链表表示法-----</span><br><span class="hljs-comment">// 抽象数据类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-comment">// 非零元结点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OLNode</span> &#123;<br>    <span class="hljs-type">int</span> i, j;      <span class="hljs-comment">// 非零元的行列下标</span><br>    ElemType value;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OLNode</span>* right, * down;   <span class="hljs-comment">// 非零元所在的行表和列表的后继元</span><br>&#125;OLNode, * OLink;<br><span class="hljs-comment">// 十字链表结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    OLink* rhead, * chead; <span class="hljs-comment">// row_head and column_head 头节点指针向量</span><br>    <span class="hljs-type">int</span> cols, rows, nums;<br>&#125;CrossList;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateCrossList</span><span class="hljs-params">(CrossList&amp; M)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CrossListPrint</span><span class="hljs-params">(CrossList M)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">MatrixAdd</span><span class="hljs-params">(CrossList&amp; A, CrossList B)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">DestroyCrossList</span><span class="hljs-params">(CrossList B)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CrossList A, B;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateCrossList</span>(A) || !<span class="hljs-built_in">CreateCrossList</span>(B)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Space allocate error!\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;After addiction:\n&quot;</span>;<br>    <span class="hljs-built_in">MatrixAdd</span>(A, B);<br>    <span class="hljs-built_in">DestroyCrossList</span>(B);<br>    <span class="hljs-built_in">CrossListPrint</span>(A);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateCrossList</span><span class="hljs-params">(CrossList&amp; M)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix rows, cols and nums:\n&quot;</span>;<br>    cin &gt;&gt; M.rows &gt;&gt; M.cols &gt;&gt; M.nums;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix elements:(x, y, value)\n&quot;</span>;<br><br>    <span class="hljs-comment">// 为行表和列表指针申请空间，注意rhead,chead为指向指针的指针</span><br>    <span class="hljs-keyword">if</span> (!(M.rhead = (OLink*)<span class="hljs-built_in">malloc</span>(M.rows * <span class="hljs-built_in">sizeof</span>(OLink))))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!(M.chead = (OLink*)<span class="hljs-built_in">malloc</span>(M.cols * <span class="hljs-built_in">sizeof</span>(OLink))))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 初始化行列头指针向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M.rows; i++) M.rhead[i] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M.cols; i++) M.chead[i] = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-type">int</span> temp_i, temp_j, temp_value;<br>    <span class="hljs-keyword">for</span> (cin &gt;&gt; temp_i &gt;&gt; temp_j &gt;&gt; temp_value; temp_i != <span class="hljs-number">0</span>; cin &gt;&gt; temp_i &gt;&gt; temp_j &gt;&gt; temp_value) &#123;<br>        <span class="hljs-comment">// 假定输入以“0 0 0”结束</span><br>        OLink p;<br>        <span class="hljs-keyword">if</span> (!(p = (OLink)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(OLNode)))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 生成结点</span><br>        p-&gt;i = temp_i; p-&gt;j = temp_j;<br>        p-&gt;value = temp_value;<br><br>        <span class="hljs-comment">/*-----------处理行插入情况------------*/</span><br>        <span class="hljs-keyword">if</span> (M.rhead[temp_i - <span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span> || M.rhead[temp_i - <span class="hljs-number">1</span>]-&gt;j &gt; temp_j) &#123;  <span class="hljs-comment">// 判断是否在首节点插入</span><br>            p-&gt;right = M.rhead[temp_i - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 这个地方一定保证了下面搜寻情况时最后一个结点的right域始终是NULL</span><br>            M.rhead[temp_i - <span class="hljs-number">1</span>] = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则需要遍历在行表中的插入位置</span><br>            <span class="hljs-comment">// 最先就比较当前行的第二个元素q-&gt;right，这种情况无法探查首结点，也是为何需要特判首结点</span><br>            <span class="hljs-comment">// 试探性的比较主要由单向链表结构决定的，只能巡查next，不能回溯</span><br>            OLink q = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">for</span> (q = M.rhead[temp_i - <span class="hljs-number">1</span>]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j &lt; temp_j; q = q-&gt;right);<br>            <span class="hljs-comment">// 最终停在待插入节点位置的前一个位置上</span><br>            p-&gt;right = q-&gt;right; q-&gt;right = p;<br>        &#125;<br><br>        <span class="hljs-comment">/*-----------处理列插入情况------------*/</span><br>        <span class="hljs-comment">// 列插入情况与行插入类似</span><br>        <span class="hljs-keyword">if</span> (M.chead[temp_j - <span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span> || M.chead[temp_j - <span class="hljs-number">1</span>]-&gt;i &gt; temp_i) &#123;<br>            p-&gt;down = M.chead[temp_j - <span class="hljs-number">1</span>];<br>            M.chead[temp_j - <span class="hljs-number">1</span>] = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            OLink q = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">for</span> (q = M.chead[temp_j - <span class="hljs-number">1</span>]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i &lt; temp_i; q = q-&gt;down);<br>            p-&gt;down = q-&gt;down; q-&gt;down = p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">MatrixAdd</span><span class="hljs-params">(CrossList &amp;A, CrossList B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 实现十字链表表示的矩阵加法</span><br>    <span class="hljs-comment">// 判断矩阵同型</span><br>    <span class="hljs-keyword">if</span> (A.rows != B.rows || A.cols != B.cols) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 构造矩阵A每一列的游标</span><br>    OLink colptr[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.cols; i++) colptr[i] = A.chead[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; A.rows; k++) &#123;<br>        <span class="hljs-comment">// pre指向矩阵A中pa前一节点</span><br>        OLink pa = A.rhead[k], pb = B.rhead[k], pre = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">while</span> (pb) &#123;    <span class="hljs-comment">// 处理B矩阵每一行元素</span><br>            <span class="hljs-comment">// A+B情况分类处理</span><br>            <span class="hljs-comment">// &lt;1&gt; 直接复制B结点到A矩阵中(可以直接移动但考虑最后释放B矩阵的开销，不如直接复制再释放)</span><br>            <span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span> || pa-&gt;j &gt; pb-&gt;j) &#123;<br>                <span class="hljs-comment">// 复制结点</span><br>                OLink p = (OLink)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(OLNode));<br>                <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                p-&gt;i = pb-&gt;i; p-&gt;j = pb-&gt;j; p-&gt;value = pb-&gt;value;  <span class="hljs-comment">//新节点值域更新</span><br><br>                <span class="hljs-comment">// 行表更改——归属于哪一行</span><br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) A.rhead[pb-&gt;i - <span class="hljs-number">1</span>] = p;<br>                <span class="hljs-keyword">else</span> pre-&gt;right = p;<br>                p-&gt;right = pa;       <span class="hljs-comment">// 新节点right域更新</span><br>                pre = p;<br><br>                <span class="hljs-comment">//列表更改——归属于哪一列</span><br>                <span class="hljs-keyword">if</span> (!A.chead[p-&gt;j - <span class="hljs-number">1</span>] || A.chead[p-&gt;j - <span class="hljs-number">1</span>]-&gt;i &gt; p-&gt;i)<br>                &#123;<br>                    p-&gt;down = A.chead[p-&gt;j - <span class="hljs-number">1</span>];  <span class="hljs-comment">//新节点down域更新</span><br>                    A.chead[p-&gt;j - <span class="hljs-number">1</span>] = p;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    p-&gt;down = colptr[p-&gt;j - <span class="hljs-number">1</span>]-&gt;down;<br>                    colptr[p-&gt;j - <span class="hljs-number">1</span>]-&gt;down = p;<br>                &#125;<br>                colptr[p-&gt;j - <span class="hljs-number">1</span>] = p;<br>                pb = pb-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">NULL</span> &amp;&amp; pa-&gt;j &lt; pb-&gt;j) &#123;<br>                <span class="hljs-comment">// &lt;2&gt; A矩阵同行元素位置在前时直接指针后移</span><br>                pre = pa;<br>                pa = pa-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;j == pb-&gt;j) &#123;<br>                <span class="hljs-comment">// &lt;3&gt; 执行加法运算</span><br>                pa-&gt;value += pb-&gt;value;<br>                <span class="hljs-keyword">if</span> (pa-&gt;value == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 特判和为零时从矩阵A中删除节点</span><br>                    <span class="hljs-comment">// 行表</span><br>                    <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) A.rhead[pa-&gt;i - <span class="hljs-number">1</span>] = pa-&gt;right;<br>                    <span class="hljs-keyword">else</span> pre-&gt;right = pa-&gt;right;<br>                    OLink p = pa;<br>                    pa = pa-&gt;right;   <span class="hljs-comment">// 后移继续下一运算</span><br>                    <span class="hljs-comment">// 列表</span><br>                    <span class="hljs-keyword">if</span> (A.chead[p-&gt;j - <span class="hljs-number">1</span>] == p) A.chead[p-&gt;j - <span class="hljs-number">1</span>] = colptr[p-&gt;j - <span class="hljs-number">1</span>] = p-&gt;down;<br>                    <span class="hljs-keyword">else</span> colptr[p-&gt;j - <span class="hljs-number">1</span>]-&gt;down = p-&gt;down;<br>                    <span class="hljs-built_in">free</span>(p);<br>                &#125;<br>                pb = pb-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.cols; i++)<br>            <span class="hljs-keyword">if</span> (colptr[i] &amp;&amp; colptr[i]-&gt;down &amp;&amp; colptr[i]-&gt;down-&gt;j &lt; k + <span class="hljs-number">2</span>) colptr[i] = colptr[i]-&gt;down;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CrossListPrint</span><span class="hljs-params">(CrossList M)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Output Matrix:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M.rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M.cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (M.rhead[i] &amp;&amp; M.rhead[i]-&gt;j == (j + <span class="hljs-number">1</span>)) &#123;<br>                cout &lt;&lt; M.rhead[i]-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                M.rhead[i] = M.rhead[i]-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DestroyCrossList</span><span class="hljs-params">(CrossList B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; B.rows; i++) &#123;<br>        OLink p = B.rhead[i];<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            OLink q = p;<br>            p = p-&gt;right;<br>            <span class="hljs-built_in">free</span>(q);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(B.rhead); <span class="hljs-built_in">free</span>(B.chead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个具体实现算例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*------One Example:</span><br><span class="hljs-comment">Input Matrix rows, cols and nums:</span><br><span class="hljs-comment">4 3 12</span><br><span class="hljs-comment">Input Matrix elements:(x, y, value)</span><br><span class="hljs-comment">1 1 -1</span><br><span class="hljs-comment">1 3 2</span><br><span class="hljs-comment">2 3 -1</span><br><span class="hljs-comment">3 1 2</span><br><span class="hljs-comment">0 0 0           // End_Input_Sign</span><br><span class="hljs-comment">Input Matrix rows, cols and nums:</span><br><span class="hljs-comment">4 3 12</span><br><span class="hljs-comment">Input Matrix elements:(x, y, value)</span><br><span class="hljs-comment">2 1 3</span><br><span class="hljs-comment">2 3 1</span><br><span class="hljs-comment">3 2 4</span><br><span class="hljs-comment">4 1 2</span><br><span class="hljs-comment">0 0 0           // End_Input_Sign</span><br><span class="hljs-comment">After addiction:</span><br><span class="hljs-comment">Output Matrix:</span><br><span class="hljs-comment">-1 0 2</span><br><span class="hljs-comment">3 0 0</span><br><span class="hljs-comment">2 4 0</span><br><span class="hljs-comment">2 0 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储结构</title>
    <url>/2022/10/28/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="一、图的邻接矩阵表示——（Adjacency-Matrix"><a href="#一、图的邻接矩阵表示——（Adjacency-Matrix" class="headerlink" title="一、图的邻接矩阵表示——（Adjacency Matrix)"></a>一、图的邻接矩阵表示——（Adjacency Matrix)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;limits.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//----------------自定义邻接矩阵模板类-----------------//</span><br><br><span class="hljs-comment">//-------------图的数组（邻接矩阵存储）表示-----------//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_Vertex_Num 20 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dep(i,x,y) for(i=x;i&gt;=y;i--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY INT_MAX</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123; DG, DN, UDG, UDN &#125;GraphKind;    <span class="hljs-comment">//&#123;有向图，有向网，无向图，无向网&#125;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> VRType;<br><span class="hljs-keyword">typedef</span> string InfoType;<br><span class="hljs-keyword">typedef</span> string VertexType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcCell</span> &#123;<br>    VRType adj;   <span class="hljs-comment">// 顶点关系类型，无权图，用1或0表相邻否；有权图为权值</span><br>    InfoType info;   <span class="hljs-comment">//弧相关信息指针</span><br>&#125;ArcCell, AdjMatrix[Max_Vertex_Num][Max_Vertex_Num];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    VertexType vexs[Max_Vertex_Num];  <span class="hljs-comment">// 顶点向量</span><br>    AdjMatrix arcs;   <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 图的当前顶点数和弧数</span><br>    GraphKind kind;     <span class="hljs-comment">// 图种类标志 </span><br>&#125;MGraph;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(MGraph G, VertexType v)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateDG</span><span class="hljs-params">(MGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateDN</span><span class="hljs-params">(MGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(MGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(MGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(MGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(MGraph G)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MGraph G;<br>    <span class="hljs-built_in">CreateGraph</span>(G);<br>    <span class="hljs-built_in">GraphPrint</span>(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(MGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接矩阵表示法，构造图G</span><br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):\n&quot;</span>;<br>    cin &gt;&gt; sign;<br>    <span class="hljs-keyword">switch</span> (sign) &#123;<br>    <span class="hljs-keyword">case</span> DG:<br>        G.kind = DG;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateDG</span>(G);  <span class="hljs-comment">// diagraph</span><br>    <span class="hljs-keyword">case</span> DN:<br>        G.kind = DN;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateDN</span>(G);  <span class="hljs-comment">// dianetwork</span><br>    <span class="hljs-keyword">case</span> UDG:<br>        G.kind = UDG;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDG</span>(G);  <span class="hljs-comment">//undiagraph</span><br>    <span class="hljs-keyword">case</span> UDN:<br>        G.kind = UDN;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDN</span>(G);  <span class="hljs-comment">//undianetwork</span><br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(MGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用数组（邻接矩阵）表示法构造无向网G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.vexs[i];   <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化邻接矩阵</span><br>        <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) G.arcs[i][j] = &#123; INFINITY, <span class="hljs-string">&quot;&quot;</span> &#125;; <span class="hljs-comment">//&#123;adj,info&#125;</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices and weight of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点和权值</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        G.arcs[p1][p2].adj = w;    <span class="hljs-comment">// 弧&lt;v1,v2&gt;的权值w</span><br>        <span class="hljs-keyword">if</span> (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info;     <span class="hljs-comment">// 如果弧有信息则输入</span><br>        G.arcs[p2][p1] = G.arcs[p1][p2];     <span class="hljs-comment">// 无向图</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(MGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用数组（邻接矩阵）表示法构造无向图G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.vexs[i];   <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化邻接矩阵</span><br>        <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) G.arcs[i][j] = &#123; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span> &#125;; <span class="hljs-comment">//&#123;adj,info&#125;</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        G.arcs[p1][p2].adj = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 弧&lt;v1,v2&gt;的权值w</span><br>        <span class="hljs-keyword">if</span> (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info;     <span class="hljs-comment">// 如果弧有信息则输入</span><br>        G.arcs[p2][p1] = G.arcs[p1][p2];     <span class="hljs-comment">// 无向图</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateDG</span><span class="hljs-params">(MGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用数组（邻接矩阵）表示法构造无向图G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.vexs[i];   <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化邻接矩阵</span><br>        <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) G.arcs[i][j] = &#123; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span> &#125;; <span class="hljs-comment">//&#123;adj,info&#125;</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        G.arcs[p1][p2].adj = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 弧&lt;v1,v2&gt;的权值w</span><br>        <span class="hljs-keyword">if</span> (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info;     <span class="hljs-comment">// 如果弧有信息则输入</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateDN</span><span class="hljs-params">(MGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用数组（邻接矩阵）表示法构造无向图G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.vexs[i];   <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>)  <span class="hljs-comment">// 初始化邻接矩阵</span><br>        <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) G.arcs[i][j] = &#123; INFINITY, <span class="hljs-string">&quot;&quot;</span> &#125;; <span class="hljs-comment">//&#123;adj,info&#125;</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices and weight of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点和权值</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        G.arcs[p1][p2].adj = w;    <span class="hljs-comment">// 弧&lt;v1,v2&gt;的权值w</span><br>        <span class="hljs-keyword">if</span> (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info;     <span class="hljs-comment">// 如果弧有信息则输入</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(MGraph G, VertexType v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (G.vexs[i] == v)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(MGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Output Graph Information:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Graph Kind: &quot;</span>;<br>    <span class="hljs-keyword">switch</span> (G.kind) &#123;<br>    <span class="hljs-keyword">case</span> DG:cout &lt;&lt; <span class="hljs-string">&quot;directed graph\n&quot;</span>;  <span class="hljs-comment">// diagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DN:cout &lt;&lt; <span class="hljs-string">&quot;directed nets\n&quot;</span>;  <span class="hljs-comment">// dianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDG:cout &lt;&lt; <span class="hljs-string">&quot;undirected graph\n&quot;</span>;  <span class="hljs-comment">//undiagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDN:cout &lt;&lt; <span class="hljs-string">&quot;undirected nets\n&quot;</span>;  <span class="hljs-comment">//undianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vextices number: &quot;</span> &lt;&lt; G.vexnum &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; <span class="hljs-string">&quot;Arcs number: &quot;</span> &lt;&lt; G.arcnum &lt;&lt; endl;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vextices Vector Information:\n&quot;</span>;<br>    <span class="hljs-type">int</span> sign = (G.kind == DG || G.kind == UDG) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   <span class="hljs-comment">// 图标记</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> Outdegree = <span class="hljs-number">0</span>, Indegree = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (G.arcs[i][j].adj != INFINITY &amp;&amp; (!sign || (sign &amp;&amp; G.arcs[i][j].adj != <span class="hljs-number">0</span>))) &#123;<br>                Outdegree++;<br>                cout &lt;&lt; G.vexs[i] &lt;&lt; <span class="hljs-string">&quot;-&lt;&quot;</span> &lt;&lt; G.arcs[i][j].adj &lt;&lt; <span class="hljs-string">&quot;&gt;-&quot;</span> &lt;&lt; G.vexs[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (G.arcs[j][i].adj != INFINITY &amp;&amp; (!sign || (sign &amp;&amp; G.arcs[j][i].adj != <span class="hljs-number">0</span>))) Indegree++;<br>        &#125;<br>        cout &lt;&lt; endl &lt;&lt; G.vexs[i];<br>        <span class="hljs-keyword">if</span> (G.kind == DG || G.kind == DN)<br>            cout &lt;&lt; <span class="hljs-string">&quot;  Vextice Degree: &quot;</span> &lt;&lt; Outdegree + Indegree &lt;&lt; <span class="hljs-string">&quot;  Outdegree: &quot;</span> &lt;&lt; Outdegree<br>            &lt;&lt; <span class="hljs-string">&quot;  Indegree: &quot;</span> &lt;&lt; Indegree &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;  Vextice Degree: &quot;</span> &lt;&lt; Outdegree &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*-------------Here is a demo------------</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">6 10 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">v1 v2 v3 v4 v5 v6</span><br><span class="hljs-comment">Input two vertices and weight of the edges:</span><br><span class="hljs-comment">v1 v2 5</span><br><span class="hljs-comment">v1 v4 7</span><br><span class="hljs-comment">v2 v3 4</span><br><span class="hljs-comment">v3 v1 8</span><br><span class="hljs-comment">v3 v6 9</span><br><span class="hljs-comment">v4 v3 5</span><br><span class="hljs-comment">v4 v6 6</span><br><span class="hljs-comment">v5 v4 5</span><br><span class="hljs-comment">v6 v1 3</span><br><span class="hljs-comment">v6 v5 1</span><br><span class="hljs-comment">Output Graph Information:</span><br><span class="hljs-comment">Graph Kind: directed nets</span><br><span class="hljs-comment">Vextices number: 6   Arcs number: 10</span><br><span class="hljs-comment">Vextices Vector Information:</span><br><span class="hljs-comment">v1-&lt;5&gt;-v2 v1-&lt;7&gt;-v4</span><br><span class="hljs-comment">v1  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment">v2-&lt;4&gt;-v3</span><br><span class="hljs-comment">v2  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment">v3-&lt;8&gt;-v1 v3-&lt;9&gt;-v6</span><br><span class="hljs-comment">v3  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment">v4-&lt;5&gt;-v3 v4-&lt;6&gt;-v6</span><br><span class="hljs-comment">v4  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment">v5-&lt;5&gt;-v4</span><br><span class="hljs-comment">v5  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment">v6-&lt;3&gt;-v1 v6-&lt;1&gt;-v5</span><br><span class="hljs-comment">v6  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
<h3 id="二、图的邻接表表示——（Adjacency-List"><a href="#二、图的邻接表表示——（Adjacency-List" class="headerlink" title="二、图的邻接表表示——（Adjacency List)"></a>二、图的邻接表表示——（Adjacency List)</h3><p>本节基于邻接表和逆邻接表表示图，以及求解图的度数；<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//---------------------图的邻接表存储表示-----------------//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dep(i,x,y) for(i=x;i&gt;=y;i--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_Vertex_Num 20</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123; DG, DN, UDG, UDN &#125;GraphKind;    <span class="hljs-comment">//&#123;有向图，有向网，无向图，无向网&#125;</span><br><span class="hljs-keyword">typedef</span> string InfoType;<br><span class="hljs-keyword">typedef</span> string VertexType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><span class="hljs-comment">//----------弧节点结构-------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;   <span class="hljs-comment">// 该弧所指向的顶点位置</span><br>    <span class="hljs-type">int</span> weight;   <span class="hljs-comment">// 弧的权值</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;    <span class="hljs-comment">// 指向下一条弧指针</span><br>    InfoType info;       <span class="hljs-comment">// 该弧相关信息</span><br>    <span class="hljs-built_in">ArcNode</span>()<br>    &#123;<br>        adjvex = weight = <span class="hljs-number">0</span>;<br>        nextarc = <span class="hljs-literal">NULL</span>;<br>        info = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;ArcNode;<br><span class="hljs-comment">//----------头节点结构---------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span> &#123;<br>    VertexType data;   <span class="hljs-comment">// 顶点信息</span><br>    <span class="hljs-type">int</span> Outdegree;     <span class="hljs-comment">// 节点对应的出度</span><br>    ArcNode* firstarc;   <span class="hljs-comment">// 指向第一条依附该顶点的弧的指针</span><br>    <span class="hljs-built_in">VNode</span>()<br>    &#123;<br>        data = <span class="hljs-string">&quot;&quot;</span>;<br>        Outdegree = <span class="hljs-number">0</span>;<br>        firstarc = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;VNode, AdjList[Max_Vertex_Num];<br><span class="hljs-comment">//----------图结构定义---------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList Vextices;<br>    <span class="hljs-type">int</span> vexnum, arcnum;    <span class="hljs-comment">// 图的顶点数和弧数</span><br>    <span class="hljs-type">int</span> kind;       <span class="hljs-comment">// 图的种类标志</span><br>&#125;ALGraph;<br><br><span class="hljs-comment">//--------------头节点定位函数---------------------//</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(ALGraph G, VertexType v)</span></span>;<br><span class="hljs-comment">//-------------------构建节点函数------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">GraphAddNode</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> IncInfo)</span></span>;<br><span class="hljs-comment">//-------------------图创建函数--------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">CreateDG</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateDN</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span>;<br><br><span class="hljs-comment">//------------------图输出函数---------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(ALGraph G, ALGraph GR)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ALGraph G, GR;   <span class="hljs-comment">// G:邻接表，GR:逆邻接表</span><br>    <span class="hljs-built_in">CreateGraph</span>(G, GR);<br>    <span class="hljs-built_in">GraphPrint</span>(G, GR);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):\n&quot;</span>;<br>    cin &gt;&gt; G.kind;      <span class="hljs-comment">// 种类标识</span><br>    GR.kind = G.kind;<br>    <span class="hljs-keyword">switch</span> (G.kind) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateDG</span>(G, GR);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateDN</span>(G, GR);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDG</span>(G, GR);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDN</span>(G, GR);<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateDG</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接表表示法构造有向图G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br>    GR.vexnum = G.vexnum; GR.arcnum = G.arcnum;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        cin &gt;&gt; G.Vextices[i].data;   <span class="hljs-comment">// 节点数据</span><br>        GR.Vextices[i].data = G.Vextices[i].data;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, <span class="hljs-number">1</span>, IncInfo);   <span class="hljs-comment">// 邻接表中p1-&gt;p2 ==&gt; p1的出度</span><br>        <span class="hljs-built_in">GraphAddNode</span>(GR, p2, p1, <span class="hljs-number">1</span>, IncInfo);   <span class="hljs-comment">// 逆邻接表中p1-&gt;p2 ==&gt; p2的入度</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateDN</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接表表示法构造有向网G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br>    GR.vexnum = G.vexnum; GR.arcnum = G.arcnum;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        cin &gt;&gt; G.Vextices[i].data;   <span class="hljs-comment">// 节点数据</span><br>        GR.Vextices[i].data = G.Vextices[i].data;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices and weight of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, w, IncInfo);   <span class="hljs-comment">// 邻接表中p1-&gt;p2 ==&gt; p1的出度</span><br>        <span class="hljs-built_in">GraphAddNode</span>(GR, p2, p1, w, IncInfo);  <span class="hljs-comment">// 逆邻接表中p1-&gt;p2 ==&gt; p2的入度</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接表表示法构造无向图G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br>    GR.vexnum = G.vexnum; GR.arcnum = G.arcnum;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        cin &gt;&gt; G.Vextices[i].data;   <span class="hljs-comment">// 节点数据</span><br>        GR.Vextices[i].data = G.Vextices[i].data;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 对无向图而言，逆邻接表作用不是很显著，实际使用中可删除</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, <span class="hljs-number">1</span>, IncInfo);   <span class="hljs-comment">// p2挂在p1链表上</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p2, p1, <span class="hljs-number">1</span>, IncInfo);   <span class="hljs-comment">// p1挂在p2链表上</span><br>        <span class="hljs-built_in">GraphAddNode</span>(GR, p1, p2, <span class="hljs-number">1</span>, IncInfo);<br>        <span class="hljs-built_in">GraphAddNode</span>(GR, p2, p1, <span class="hljs-number">1</span>, IncInfo);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(ALGraph&amp; G, ALGraph&amp; GR)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接表表示法构造无向网G</span><br>    <span class="hljs-type">int</span> IncInfo = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo;   <span class="hljs-comment">// IncInfo为0则各弧不含其他信息</span><br>    GR.vexnum = G.vexnum; GR.arcnum = G.arcnum;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        cin &gt;&gt; G.Vextices[i].data;   <span class="hljs-comment">// 节点数据</span><br>        GR.Vextices[i].data = G.Vextices[i].data;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices and weight of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;<br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, w, IncInfo);    <span class="hljs-comment">// 附权值w</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p2, p1, w, IncInfo);<br>        <span class="hljs-built_in">GraphAddNode</span>(GR, p1, p2, w, IncInfo);<br>        <span class="hljs-built_in">GraphAddNode</span>(GR, p2, p1, w, IncInfo);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">GraphAddNode</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> IncInfo)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将弧的头节点p2挂在尾节点p1的链表上</span><br>    ArcNode* p = G.Vextices[p1].firstarc;<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123; <br>        <span class="hljs-keyword">if</span> (p-&gt;adjvex == p2) &#123;     <span class="hljs-comment">//如果已经存在</span><br>            sign = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (IncInfo) cin &gt;&gt; p-&gt;info;     <span class="hljs-comment">// 如果弧有信息则输入</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!p-&gt;nextarc) <span class="hljs-keyword">break</span>;<br>        p = p-&gt;nextarc;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!sign) &#123;<br>        <span class="hljs-keyword">if</span> (!p) &#123;<br>            p = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcNode));<br>            G.Vextices[p1].firstarc = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p-&gt;nextarc = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcNode));<br>            p = p-&gt;nextarc;<br>        &#125;<br><br>        p-&gt;adjvex = p2;<br>        p-&gt;weight = w;    <span class="hljs-comment">// 弧&lt;v1,v2&gt;的权值w   </span><br>        p-&gt;nextarc = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (IncInfo) cin &gt;&gt; p-&gt;info;     <span class="hljs-comment">// 如果弧有信息则输入</span><br>        G.Vextices[p1].Outdegree++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(ALGraph G, VertexType v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (G.Vextices[i].data == v)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(ALGraph G, ALGraph GR)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----------------Output Graph Information-----------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Graph Kind: &quot;</span>;<br>    <span class="hljs-keyword">switch</span> (G.kind) &#123;<br>    <span class="hljs-keyword">case</span> DG:cout &lt;&lt; <span class="hljs-string">&quot;directed graph\n&quot;</span>;  <span class="hljs-comment">// diagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DN:cout &lt;&lt; <span class="hljs-string">&quot;directed nets\n&quot;</span>;  <span class="hljs-comment">// dianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDG:cout &lt;&lt; <span class="hljs-string">&quot;undirected graph\n&quot;</span>;  <span class="hljs-comment">//undiagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDN:cout &lt;&lt; <span class="hljs-string">&quot;undirected nets\n&quot;</span>;  <span class="hljs-comment">//undianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vextices number: &quot;</span> &lt;&lt; G.vexnum &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; <span class="hljs-string">&quot;Arcs number: &quot;</span> &lt;&lt; G.arcnum &lt;&lt; endl;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;----------------Vextices Vector Information----------------\n&quot;</span>;<br>    <span class="hljs-type">int</span> sign = (G.kind == DG || G.kind == DN) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   <span class="hljs-comment">// 图标记</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;The Nodes Path:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        ArcNode* p = G.Vextices[i].firstarc;<br>        ArcNode* q = GR.Vextices[i].firstarc;<br>        <span class="hljs-keyword">if</span> (sign) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Out path: &quot;</span>;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                cout &lt;&lt; G.Vextices[i].data &lt;&lt; <span class="hljs-string">&quot;-[&quot;</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="hljs-string">&quot;]-&gt;&quot;</span> &lt;&lt; G.Vextices[p-&gt;adjvex].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>                p = p-&gt;nextarc;<br>            &#125;<br>            cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;In path: &quot;</span>;<br>            <span class="hljs-keyword">while</span> (q) &#123;<br>                cout &lt;&lt; GR.Vextices[q-&gt;adjvex].data &lt;&lt; <span class="hljs-string">&quot;-[&quot;</span> &lt;&lt; q-&gt;weight &lt;&lt; <span class="hljs-string">&quot;]-&gt;-&quot;</span> &lt;&lt; GR.Vextices[i].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>                q = q-&gt;nextarc;<br>            &#125;<br>            cout &lt;&lt; endl &lt;&lt; G.Vextices[i].data;<br>            cout &lt;&lt; <span class="hljs-string">&quot;  Vextice Degree: &quot;</span> &lt;&lt; G.Vextices[i].Outdegree + GR.Vextices[i].Outdegree &lt;&lt; <span class="hljs-string">&quot;  Outdegree: &quot;</span> &lt;&lt; G.Vextices[i].Outdegree<br>                &lt;&lt; <span class="hljs-string">&quot;  Indegree: &quot;</span> &lt;&lt; GR.Vextices[i].Outdegree &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Out path: &quot;</span>;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                cout &lt;&lt; G.Vextices[i].data &lt;&lt; <span class="hljs-string">&quot;-&lt;-[&quot;</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="hljs-string">&quot;]-&gt;-&quot;</span> &lt;&lt; G.Vextices[p-&gt;adjvex].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>                p = p-&gt;nextarc;<br>            &#125;<br>            cout &lt;&lt; endl &lt;&lt; G.Vextices[i].data;<br>            cout &lt;&lt; <span class="hljs-string">&quot;  Vextice Degree: &quot;</span> &lt;&lt; G.Vextices[i].Outdegree &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//---------- Here is a drected graph demo -------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">4 7 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">V1 V2 V3 V4</span><br><span class="hljs-comment">Input two vertices of the edges:</span><br><span class="hljs-comment">V1 V2</span><br><span class="hljs-comment">V3 V1</span><br><span class="hljs-comment">V1 V3</span><br><span class="hljs-comment">V4 V1</span><br><span class="hljs-comment">V3 V4</span><br><span class="hljs-comment">V4 V3</span><br><span class="hljs-comment">V4 V2</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: directed graph</span><br><span class="hljs-comment">Vextices number: 4   Arcs number: 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: V1-[1]-&gt;V2  V1-[1]-&gt;V3</span><br><span class="hljs-comment">In path: V3-[1]-&gt;-V1  V4-[1]-&gt;-V1</span><br><span class="hljs-comment">V1  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path:</span><br><span class="hljs-comment">In path: V1-[1]-&gt;-V2  V4-[1]-&gt;-V2</span><br><span class="hljs-comment">V2  Vextice Degree: 2  Outdegree: 0  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V3-[1]-&gt;V1  V3-[1]-&gt;V4</span><br><span class="hljs-comment">In path: V1-[1]-&gt;-V3  V4-[1]-&gt;-V3</span><br><span class="hljs-comment">V3  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V4-[1]-&gt;V1  V4-[1]-&gt;V3  V4-[1]-&gt;V2</span><br><span class="hljs-comment">In path: V3-[1]-&gt;-V4</span><br><span class="hljs-comment">V4  Vextice Degree: 4  Outdegree: 3  Indegree: 1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//---------- Here is a undrected graph demo -------//</span><br><span class="hljs-comment">/*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">4 7 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">V1 V2 V3 V4</span><br><span class="hljs-comment">Input two vertices of the edges:</span><br><span class="hljs-comment">V1 V2</span><br><span class="hljs-comment">V3 V1</span><br><span class="hljs-comment">V1 V3</span><br><span class="hljs-comment">V4 V1</span><br><span class="hljs-comment">V3 V4</span><br><span class="hljs-comment">V4 V3</span><br><span class="hljs-comment">V4 V2</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: undirected graph</span><br><span class="hljs-comment">Vextices number: 4   Arcs number: 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: V1-&lt;-[1]-&gt;-V2  V1-&lt;-[1]-&gt;-V3  V1-&lt;-[1]-&gt;-V4</span><br><span class="hljs-comment">V1  Vextice Degree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V2-&lt;-[1]-&gt;-V1  V2-&lt;-[1]-&gt;-V4</span><br><span class="hljs-comment">V2  Vextice Degree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V3-&lt;-[1]-&gt;-V1  V3-&lt;-[1]-&gt;-V4</span><br><span class="hljs-comment">V3  Vextice Degree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V4-&lt;-[1]-&gt;-V1  V4-&lt;-[1]-&gt;-V3  V4-&lt;-[1]-&gt;-V2</span><br><span class="hljs-comment">V4  Vextice Degree: 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
<h3 id="三、图的十字链表表示——（Orthogonal-List）"><a href="#三、图的十字链表表示——（Orthogonal-List）" class="headerlink" title="三、图的十字链表表示——（Orthogonal List）"></a>三、图的十字链表表示——（Orthogonal List）</h3><p>本节实现对图的十字链表表示（主要用于有向图的存储），其中对无向图/网没有实现判重的功能，即不允许无向图/网先后输入同一条弧；<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//----------------有向图的十字链表存储表示------------------//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_Vertex_Num 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_Length_Info 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dep(i,x,y) for(i=x;i&gt;=y;i--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InfoType char*</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VertexType string</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Status bool</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123; DG, DN, UDG, UDN &#125;GraphKind;    <span class="hljs-comment">//&#123;有向图，有向网，无向图，无向网&#125;</span><br><br><span class="hljs-comment">//---------------图的弧结构表示------------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcBox</span> &#123;<br>    <span class="hljs-type">int</span> tailvex, headvex, weight;  <span class="hljs-comment">// 该弧的尾和头顶点的位置==&gt;指向顺序存储结构中的编号</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcBox</span>* hlink, * tlink; <span class="hljs-comment">// 分别为弧头相同和弧尾相同的弧的链域</span><br>    <span class="hljs-comment">// 对每一个节点而言，弧头相同的节点和弧尾相同的节点指向两个链表构成十字链表分别表示入度和出度</span><br>    InfoType info;        <span class="hljs-comment">// 弧信息</span><br>&#125;ArcBox;<br><span class="hljs-comment">//---------------图的顶点结构表示-----------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VexNode</span> &#123;<br>    VertexType data;<br>    ArcBox* firstin, * firstout;  <span class="hljs-comment">// 分别指向该顶点第一条入弧和出弧</span><br>    <span class="hljs-built_in">VexNode</span>()<br>    &#123;<br>        data = <span class="hljs-string">&quot;&quot;</span>;<br>        firstin = firstout = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;VexNode, Xlist[Max_Vertex_Num];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Xlist Vextices;    <span class="hljs-comment">// 表头向量</span><br>    <span class="hljs-type">int</span> kind, vexnum, arcnum, IncInfo;          <span class="hljs-comment">//图种类表识，节点数和弧数，弧有无信息</span><br>&#125;OLGraph;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(OLGraph G, VertexType v)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">GraphAddNode</span><span class="hljs-params">(OLGraph&amp; G, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> w)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateDG</span><span class="hljs-params">(OLGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateDN</span><span class="hljs-params">(OLGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(OLGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(OLGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(OLGraph&amp; G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(OLGraph G)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    OLGraph G;<br>    <span class="hljs-built_in">CreateGraph</span>(G);<br>    <span class="hljs-built_in">GraphPrint</span>(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(OLGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):\n&quot;</span>;<br>    cin &gt;&gt; G.kind;      <span class="hljs-comment">// 种类标识</span><br>    <span class="hljs-keyword">switch</span> (G.kind) &#123;<br>    <span class="hljs-keyword">case</span> DG:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateDG</span>(G);<br>    <span class="hljs-keyword">case</span> DN:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateDN</span>(G);<br>    <span class="hljs-keyword">case</span> UDG:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDG</span>(G);<br>    <span class="hljs-keyword">case</span> UDN:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDN</span>(G);<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateDG</span><span class="hljs-params">(OLGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用十字链表存储表示，构造有向图G(G.kind=DG)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.Vextices[i].data;      <span class="hljs-comment">// 节点顶点值 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 输入各弧并构造十字链表</span><br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, <span class="hljs-number">1</span>);   <span class="hljs-comment">// p1-&gt;p2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateDN</span><span class="hljs-params">(OLGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用十字链表存储表示，构造有向网G(G.kind=DN)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.Vextices[i].data;      <span class="hljs-comment">// 节点顶点值 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices and weight of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 输入各弧并构造十字链表</span><br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, w);   <span class="hljs-comment">// p1-&gt;p2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(OLGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用十字链表存储表示，构造无向图G(G.kind=UDG)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.Vextices[i].data;      <span class="hljs-comment">// 节点顶点值 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 输入各弧并构造十字链表</span><br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, <span class="hljs-number">1</span>);   <span class="hljs-comment">// p1-&gt;p2</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p2, p1, <span class="hljs-number">1</span>);   <span class="hljs-comment">// p2-&gt;p1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(OLGraph&amp; G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用十字链表存储表示，构造无向网G(G.kind=UDN)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.Vextices[i].data;      <span class="hljs-comment">// 节点顶点值 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices and weight of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 输入各弧并构造十字链表</span><br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, w);   <span class="hljs-comment">// p1-&gt;p2</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p2, p1, w);   <span class="hljs-comment">// p2-&gt;p1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">GraphAddNode</span><span class="hljs-params">(OLGraph&amp; G, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    ArcBox* p = (ArcBox*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcBox));  <span class="hljs-comment">// 创建弧单元</span><br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//十字链表——涉及两个链表的交接==&gt;最终first指针会指向最后输入的一组数据</span><br>    *p = &#123; p1, p2, w, G.Vextices[p2].firstin, G.Vextices[p1].firstout, <span class="hljs-literal">NULL</span> &#125;;  <span class="hljs-comment">// 对弧节点赋值</span><br>    G.Vextices[p2].firstin = G.Vextices[p1].firstout = p;  <span class="hljs-comment">// 完成在入弧和出弧链头的插入</span><br>    <span class="hljs-keyword">if</span> (G.IncInfo) &#123;<br>        p-&gt;info = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(MAX_Length_Info*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        cout &lt;&lt; <span class="hljs-string">&quot;Input the arc information: &quot;</span>;<br>        cin &gt;&gt; p-&gt;info;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(OLGraph G, VertexType v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (G.Vextices[i].data == v)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(OLGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----------------Output Graph Information-----------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Graph Kind: &quot;</span>;<br>    <span class="hljs-keyword">switch</span> (G.kind) &#123;<br>    <span class="hljs-keyword">case</span> DG:cout &lt;&lt; <span class="hljs-string">&quot;directed graph\n&quot;</span>;  <span class="hljs-comment">// diagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DN:cout &lt;&lt; <span class="hljs-string">&quot;directed nets\n&quot;</span>;  <span class="hljs-comment">// dianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDG:cout &lt;&lt; <span class="hljs-string">&quot;undirected graph\n&quot;</span>;  <span class="hljs-comment">//undiagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDN:cout &lt;&lt; <span class="hljs-string">&quot;undirected nets\n&quot;</span>;  <span class="hljs-comment">//undianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vextices number: &quot;</span> &lt;&lt; G.vexnum &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; <span class="hljs-string">&quot;Arcs number: &quot;</span> &lt;&lt; G.arcnum &lt;&lt; endl;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;----------------Vextices Vector Information----------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The Nodes Path:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        ArcBox* p = G.Vextices[i].firstout;<br>        ArcBox* q = G.Vextices[i].firstin;<br>        <span class="hljs-type">int</span> Outdegree = <span class="hljs-number">0</span>, Indegree = <span class="hljs-number">0</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Out path: &quot;</span>;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            cout &lt;&lt; G.Vextices[p-&gt;tailvex].data &lt;&lt; <span class="hljs-string">&quot;-[&quot;</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="hljs-string">&quot;]-&gt;&quot;</span> &lt;&lt; G.Vextices[p-&gt;headvex].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>            p = p-&gt;tlink;<br>            Outdegree++;<br>        &#125;<br>        cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;In path: &quot;</span>;<br>        <span class="hljs-keyword">while</span> (q) &#123;<br>            cout &lt;&lt; G.Vextices[q-&gt;tailvex].data &lt;&lt; <span class="hljs-string">&quot;-[&quot;</span> &lt;&lt; q-&gt;weight &lt;&lt; <span class="hljs-string">&quot;]-&gt;&quot;</span> &lt;&lt; G.Vextices[q-&gt;headvex].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>            q = q-&gt;hlink;<br>            Indegree++;<br>        &#125;<br><br>        cout &lt;&lt; endl &lt;&lt; G.Vextices[i].data;<br>        cout &lt;&lt; <span class="hljs-string">&quot;  Vextice Degree: &quot;</span> &lt;&lt; Outdegree + Indegree &lt;&lt; <span class="hljs-string">&quot;  Outdegree: &quot;</span> &lt;&lt; Outdegree<br>            &lt;&lt; <span class="hljs-string">&quot;  Indegree: &quot;</span> &lt;&lt; Indegree &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//---------------Here is a directed graph demo-----------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):</span><br><span class="hljs-comment">4 7 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">V1 V2 V3 V4</span><br><span class="hljs-comment">Input two vertices of the edges:</span><br><span class="hljs-comment">V1 V2</span><br><span class="hljs-comment">V3 V1</span><br><span class="hljs-comment">V1 V3</span><br><span class="hljs-comment">V4 V1</span><br><span class="hljs-comment">V3 V4</span><br><span class="hljs-comment">V4 V3</span><br><span class="hljs-comment">V4 V2</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: directed graph</span><br><span class="hljs-comment">Vextices number: 4   Arcs number: 7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: V1-[1]-&gt;V3  V1-[1]-&gt;V2</span><br><span class="hljs-comment">In path: V4-[1]-&gt;V1  V3-[1]-&gt;V1</span><br><span class="hljs-comment">V1  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path:</span><br><span class="hljs-comment">In path: V4-[1]-&gt;V2  V1-[1]-&gt;V2</span><br><span class="hljs-comment">V2  Vextice Degree: 2  Outdegree: 0  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V3-[1]-&gt;V4  V3-[1]-&gt;V1</span><br><span class="hljs-comment">In path: V4-[1]-&gt;V3  V1-[1]-&gt;V3</span><br><span class="hljs-comment">V3  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V4-[1]-&gt;V2  V4-[1]-&gt;V3  V4-[1]-&gt;V1</span><br><span class="hljs-comment">In path: V3-[1]-&gt;V4</span><br><span class="hljs-comment">V4  Vextice Degree: 4  Outdegree: 3  Indegree: 1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//-------------------Here is a directed net demo--------------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):</span><br><span class="hljs-comment">6 10 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">v1 v2 v3 v4 v5 v6</span><br><span class="hljs-comment">Input two vertices and weight of the edges:</span><br><span class="hljs-comment">v1 v2 5</span><br><span class="hljs-comment">v1 v4 7</span><br><span class="hljs-comment">v2 v3 4</span><br><span class="hljs-comment">v3 v1 8</span><br><span class="hljs-comment">v3 v6 9</span><br><span class="hljs-comment">v4 v3 5</span><br><span class="hljs-comment">v4 v6 6</span><br><span class="hljs-comment">v5 v4 5</span><br><span class="hljs-comment">v6 v1 3</span><br><span class="hljs-comment">v6 v5 1</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: directed nets</span><br><span class="hljs-comment">Vextices number: 6   Arcs number: 10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: v1-[7]-&gt;v4  v1-[5]-&gt;v2</span><br><span class="hljs-comment">In path: v6-[3]-&gt;v1  v3-[8]-&gt;v1</span><br><span class="hljs-comment">v1  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: v2-[4]-&gt;v3</span><br><span class="hljs-comment">In path: v1-[5]-&gt;v2</span><br><span class="hljs-comment">v2  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: v3-[9]-&gt;v6  v3-[8]-&gt;v1</span><br><span class="hljs-comment">In path: v4-[5]-&gt;v3  v2-[4]-&gt;v3</span><br><span class="hljs-comment">v3  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: v4-[6]-&gt;v6  v4-[5]-&gt;v3</span><br><span class="hljs-comment">In path: v5-[5]-&gt;v4  v1-[7]-&gt;v4</span><br><span class="hljs-comment">v4  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: v5-[5]-&gt;v4</span><br><span class="hljs-comment">In path: v6-[1]-&gt;v5</span><br><span class="hljs-comment">v5  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: v6-[1]-&gt;v5  v6-[3]-&gt;v1</span><br><span class="hljs-comment">In path: v4-[6]-&gt;v6  v3-[9]-&gt;v6</span><br><span class="hljs-comment">v6  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//---------------Here is a undirected graph demo-----------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):</span><br><span class="hljs-comment">7 6 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">A B C D E F G</span><br><span class="hljs-comment">Input two vertices of the edges:</span><br><span class="hljs-comment">A C</span><br><span class="hljs-comment">A F</span><br><span class="hljs-comment">A D</span><br><span class="hljs-comment">B E</span><br><span class="hljs-comment">G E</span><br><span class="hljs-comment">E D</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: undirected graph</span><br><span class="hljs-comment">Vextices number: 7   Arcs number: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: A-[1]-&gt;D  A-[1]-&gt;F  A-[1]-&gt;C</span><br><span class="hljs-comment">In path: D-[1]-&gt;A  F-[1]-&gt;A  C-[1]-&gt;A</span><br><span class="hljs-comment">A  Vextice Degree: 6  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: B-[1]-&gt;E</span><br><span class="hljs-comment">In path: E-[1]-&gt;B</span><br><span class="hljs-comment">B  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: C-[1]-&gt;A</span><br><span class="hljs-comment">In path: A-[1]-&gt;C</span><br><span class="hljs-comment">C  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: D-[1]-&gt;E  D-[1]-&gt;A</span><br><span class="hljs-comment">In path: E-[1]-&gt;D  A-[1]-&gt;D</span><br><span class="hljs-comment">D  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: E-[1]-&gt;D  E-[1]-&gt;G  E-[1]-&gt;B</span><br><span class="hljs-comment">In path: D-[1]-&gt;E  G-[1]-&gt;E  B-[1]-&gt;E</span><br><span class="hljs-comment">E  Vextice Degree: 6  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: F-[1]-&gt;A</span><br><span class="hljs-comment">In path: A-[1]-&gt;F</span><br><span class="hljs-comment">F  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: G-[1]-&gt;E</span><br><span class="hljs-comment">In path: E-[1]-&gt;G</span><br><span class="hljs-comment">G  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
<h3 id="四、无向图的邻接多重表表示——（-Adjacency-Multilist"><a href="#四、无向图的邻接多重表表示——（-Adjacency-Multilist" class="headerlink" title="四、无向图的邻接多重表表示——（_Adjacency   Multilist_)"></a>四、无向图的邻接多重表表示——（_Adjacency   Multilist_)</h3><p>本节介绍无向图的另一种链式存储结构——邻接多重表，这类存储结构对已被搜索过的边做记号或删除一条表尤为方便；<br>由于采用将边存储为一个节点，以边的两个端点是否依附于该条边作为存储关系，故对有向图而言忽略了边的方向，不过结构与十字链表类似，因此此结构主要用于无向图；<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//--------------------无向图的邻接多重表存储表示-----------------//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_Vertex_Num 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_Length_Info 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InfoType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VertexType string</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Status bool</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;unvisited, visited&#125;VisitIf;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;UDG, UDN &#125;GraphKind;    <span class="hljs-comment">//&#123;无向图，无向网&#125;</span><br><span class="hljs-comment">//------------------边结构定义--------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">EBox</span>&#123;<br>    VisitIf mark;     <span class="hljs-comment">// 访问标记</span><br>    <span class="hljs-type">int</span> ivex, jvex, weight;     <span class="hljs-comment">// 该边依附的两个顶点位置</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">EBox</span> *ilink, *jlink;   <span class="hljs-comment">// 分别指向依附这两个顶点的下一条边</span><br>    InfoType *info;    <span class="hljs-comment">// 该边信息指针  </span><br>&#125;EBox;<br><span class="hljs-comment">//------------------顶点结构定义--------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VexBox</span>&#123;<br>    VertexType data;     <span class="hljs-comment">// 节点数据域</span><br>    EBox *firstedge;  <span class="hljs-comment">//指向第一条依附该顶点的边</span><br>    <span class="hljs-built_in">VexBox</span>()<br>    &#123;<br>        data = <span class="hljs-string">&quot;&quot;</span>;<br>        firstedge = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;VexBox, AMList[Max_Vertex_Num];<br><span class="hljs-comment">//-------------------图结构定义---------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    AMList adjmulist;<br>    <span class="hljs-type">int</span> vexnum, arcnum, kind, IncInfo;     <span class="hljs-comment">// 无向图的顶点数和边数</span><br>&#125;AMLGraph;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(AMLGraph G, VertexType v)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">GraphAddNode</span><span class="hljs-params">(AMLGraph&amp; G, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> w)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(AMLGraph &amp;G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(AMLGraph &amp;G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMLGraph &amp;G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(AMLGraph G)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    AMLGraph G;<br>    <span class="hljs-built_in">CreateGraph</span>(G);<br>    <span class="hljs-built_in">GraphPrint</span>(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateGraph</span><span class="hljs-params">(AMLGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the type of graph(0:UDG,1:UDN):\n&quot;</span>;<br>    cin &gt;&gt; G.kind;      <span class="hljs-comment">// 种类标识</span><br>    <span class="hljs-keyword">switch</span>(G.kind)&#123;<br>        <span class="hljs-keyword">case</span> UDG:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDG</span>(G);<br>        <span class="hljs-keyword">case</span> UDN:<span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateUDN</span>(G);<br>        <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(AMLGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接多重表存储表示，构造无向图G(G.kind=UDG)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.adjmulist[i].data;      <span class="hljs-comment">// 节点顶点值 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 输入各弧并构造十字链表</span><br>        VertexType v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 由于以边为单元，对两个节点的firstedge都做修改因此只需一次添加即可</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, <span class="hljs-number">1</span>);   <span class="hljs-comment">// p1&lt;-&gt;p2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMLGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接多重表存储表示，构造无向网G(G.kind=UDN)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\n&quot;</span>;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Graph Node Sign:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) cin &gt;&gt; G.adjmulist[i].data;      <span class="hljs-comment">// 节点顶点值 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Input two vertices of the edges:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.arcnum - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 输入各弧并构造十字链表</span><br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;     <span class="hljs-comment">// 输入一条边的顶点</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">LocateVex</span>(G, v1), p2 = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> || p2 == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 由于以边为单元，对两个节点的firstedge都做修改因此只需一次添加即可</span><br>        <span class="hljs-built_in">GraphAddNode</span>(G, p1, p2, w);   <span class="hljs-comment">// p1&lt;-&gt;p2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(AMLGraph G, VertexType v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (G.adjmulist[i].data == v)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">GraphAddNode</span><span class="hljs-params">(AMLGraph&amp; G, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    EBox* p = (EBox*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(EBox));  <span class="hljs-comment">// 创建边单元</span><br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//邻接多重表——涉及两个链表的交接==&gt;最终firstedge指针会指向最后输入的一组数据</span><br>    *p = &#123;unvisited, p1, p2, w, G.adjmulist[p1].firstedge, G.adjmulist[p2].firstedge, <span class="hljs-literal">NULL</span> &#125;;  <span class="hljs-comment">// 对弧节点赋值</span><br>         <span class="hljs-comment">//&#123;mark, ivex, jvex, weight, *ilink, *jlink, *info&#125;</span><br>    G.adjmulist[p1].firstedge = G.adjmulist[p2].firstedge = p; <span class="hljs-comment">// 完成在入弧和出弧链头的插入</span><br>    <span class="hljs-keyword">if</span> (G.IncInfo) &#123;<br>        p-&gt;info = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(MAX_Length_Info*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        cout &lt;&lt; <span class="hljs-string">&quot;Input the arc information: &quot;</span>;<br>        cin &gt;&gt; p-&gt;info;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">GraphPrint</span><span class="hljs-params">(AMLGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----------------Output Graph Information-----------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Graph Kind: &quot;</span>;<br>    <span class="hljs-keyword">switch</span> (G.kind) &#123;<br>    <span class="hljs-keyword">case</span> UDG:cout &lt;&lt; <span class="hljs-string">&quot;undirected graph\n&quot;</span>;  <span class="hljs-comment">//undiagraph</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> UDN:cout &lt;&lt; <span class="hljs-string">&quot;undirected nets\n&quot;</span>;  <span class="hljs-comment">//undianetwork</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vextices number: &quot;</span> &lt;&lt; G.vexnum &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; <span class="hljs-string">&quot;Arcs number: &quot;</span> &lt;&lt; G.arcnum &lt;&lt; endl;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;----------------Vextices Vector Information----------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The Nodes Path:\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum - <span class="hljs-number">1</span>) &#123;<br>        EBox* p = G.adjmulist[i].firstedge;<br>        <span class="hljs-type">int</span> Degree = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Paths: &quot;</span>;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            pos = (p-&gt;ivex == i)?p-&gt;jvex:p-&gt;ivex;<br>            <span class="hljs-keyword">if</span>(G.IncInfo)<br>                cout &lt;&lt; G.adjmulist[i].data &lt;&lt; p-&gt;info &lt;&lt; <span class="hljs-string">&quot;-&lt;&quot;</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="hljs-string">&quot;&gt;-&quot;</span> &lt;&lt; G.adjmulist[pos].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="hljs-string">&quot;-&lt;&quot;</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="hljs-string">&quot;&gt;-&quot;</span> &lt;&lt; G.adjmulist[pos].data &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>            p = (p-&gt;ivex == i)?p-&gt;ilink:p-&gt;jlink;<br>            Degree++;<br>        &#125;<br>        cout &lt;&lt; endl &lt;&lt; G.adjmulist[i].data;<br>        cout &lt;&lt; <span class="hljs-string">&quot;  Vextice Degree: &quot;</span> &lt;&lt; Degree &lt;&lt; <span class="hljs-string">&quot;  Outdegree: &quot;</span> &lt;&lt; Degree&lt;&lt; <span class="hljs-string">&quot;  Indegree: &quot;</span> &lt;&lt; Degree &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//----------------Here is a undirected graph demo--------------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:UDG,1:UDN):</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):</span><br><span class="hljs-comment">7 6 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">A B C D E F G             </span><br><span class="hljs-comment">Input two vertices of the edges:</span><br><span class="hljs-comment">A C</span><br><span class="hljs-comment">A F</span><br><span class="hljs-comment">A D</span><br><span class="hljs-comment">B E</span><br><span class="hljs-comment">G E</span><br><span class="hljs-comment">E D</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: undirected graph</span><br><span class="hljs-comment">Vextices number: 7   Arcs number: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Paths: A-&lt;1&gt;-D  A-&lt;1&gt;-F  A-&lt;1&gt;-C</span><br><span class="hljs-comment">A  Vextice Degree: 3  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: B-&lt;1&gt;-E</span><br><span class="hljs-comment">B  Vextice Degree: 1  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: C-&lt;1&gt;-A</span><br><span class="hljs-comment">C  Vextice Degree: 1  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: D-&lt;1&gt;-E  D-&lt;1&gt;-A</span><br><span class="hljs-comment">D  Vextice Degree: 2  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: E-&lt;1&gt;-D  E-&lt;1&gt;-G  E-&lt;1&gt;-B</span><br><span class="hljs-comment">E  Vextice Degree: 3  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: F-&lt;1&gt;-A</span><br><span class="hljs-comment">F  Vextice Degree: 1  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: G-&lt;1&gt;-E</span><br><span class="hljs-comment">G  Vextice Degree: 1  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//----------------Here is a undrected net demo-----------------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:UDG,1:UDN):</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):</span><br><span class="hljs-comment">7 8 0     </span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">A B C D E F G</span><br><span class="hljs-comment">Input two vertices and weight of the edges:</span><br><span class="hljs-comment">A C 4</span><br><span class="hljs-comment">A F -2</span><br><span class="hljs-comment">A D 4</span><br><span class="hljs-comment">B E -9</span><br><span class="hljs-comment">G E 7</span><br><span class="hljs-comment">E D 3</span><br><span class="hljs-comment">D B 1</span><br><span class="hljs-comment">G F 2</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: undirected nets</span><br><span class="hljs-comment">Vextices number: 7   Arcs number: 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Paths: A-&lt;4&gt;-D  A-&lt;-2&gt;-F  A-&lt;4&gt;-C</span><br><span class="hljs-comment">A  Vextice Degree: 3  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: B-&lt;1&gt;-D  B-&lt;-9&gt;-E</span><br><span class="hljs-comment">B  Vextice Degree: 2  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: C-&lt;4&gt;-A</span><br><span class="hljs-comment">C  Vextice Degree: 1  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: D-&lt;1&gt;-B  D-&lt;3&gt;-E  D-&lt;4&gt;-A</span><br><span class="hljs-comment">D  Vextice Degree: 3  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: E-&lt;3&gt;-D  E-&lt;7&gt;-G  E-&lt;-9&gt;-B</span><br><span class="hljs-comment">E  Vextice Degree: 3  Outdegree: 3  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: F-&lt;2&gt;-G  F-&lt;-2&gt;-A</span><br><span class="hljs-comment">F  Vextice Degree: 2  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Paths: G-&lt;2&gt;-F  G-&lt;7&gt;-E</span><br><span class="hljs-comment">G  Vextice Degree: 2  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2022/02/12/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、基本操作语法"><a href="#一、基本操作语法" class="headerlink" title="一、基本操作语法"></a>一、基本操作语法</h2><h3 id="1-1-基本格式"><a href="#1-1-基本格式" class="headerlink" title="1.1 基本格式"></a>1.1 基本格式</h3><p><1> 设置标题前后均留有空格</p>
<p><2> 加粗:</p>
<p><strong>加粗示例1（较推荐）</strong></p>
<p><strong>加粗示例2</strong></p>
<p><3> 斜体：</p>
<p><em>斜体示例1(较推荐）</em></p>
<p>_斜体示例2_</p>
<h3 id="1-2-段落和换行"><a href="#1-2-段落和换行" class="headerlink" title="1.2 段落和换行"></a>1.2 段落和换行</h3><h4 id="没有空行示例"><a href="#没有空行示例" class="headerlink" title="没有空行示例"></a>没有空行示例</h4><p>第一行<br>第二行</p>
<h4 id="有空行示例"><a href="#有空行示例" class="headerlink" title="有空行示例"></a>有空行示例</h4><p>第一行</p>
<p>第二行</p>
<h4 id="段内换行"><a href="#段内换行" class="headerlink" title="段内换行"></a>段内换行</h4><p>第一行，如果在段内换行需要在结尾插入两个及以上的空格<br>第二行</p>
<h3 id="1-3-有序列表"><a href="#1-3-有序列表" class="headerlink" title="1.3 有序列表"></a>1.3 有序列表</h3><h4 id="有序列表示例"><a href="#有序列表示例" class="headerlink" title="有序列表示例"></a>有序列表示例</h4><p>(数字序号+英文句号+空格+列表内容)  </p>
<ol>
<li>我有一个梦想  </li>
<li>我有两个梦想  </li>
<li>我有三个梦想  </li>
</ol>
<h3 id="1-4-无序列表"><a href="#1-4-无序列表" class="headerlink" title="1.4 无序列表"></a>1.4 无序列表</h3><h4 id="无序列表示例"><a href="#无序列表示例" class="headerlink" title="无序列表示例"></a>无序列表示例</h4><p>(*/+/- + 空格 + 列表内容)</p>
<h5 id="使用星号"><a href="#使用星号" class="headerlink" title="使用星号"></a>使用星号</h5><ul>
<li>我有一个梦想</li>
<li>我有两个梦想</li>
<li>我有三个梦想<br>（其他标记效果相同）  </li>
</ul>
<h3 id="1-5-嵌套列表"><a href="#1-5-嵌套列表" class="headerlink" title="1.5 嵌套列表"></a>1.5 嵌套列表</h3><h4 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h4><p>在第一层列表上，每一层多一个TAB键    </p>
<ul>
<li>我有一个梦想<ul>
<li>你有一个梦想<ul>
<li>她有一个梦想<ul>
<li>他有一个梦想<br>(有序列表类似可以互相嵌套）    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>_(建议使用-标记无序列表避免与粗体和斜体混淆)_</strong>  </p>
<h3 id="1-6-分割线"><a href="#1-6-分割线" class="headerlink" title="1.6 分割线"></a>1.6 分割线</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p>分割线由3个及以上的<em>/-/_来标记，对应效果不同。<br><em>*分割线示例</em></em>  </p>
<ul>
<li>星号</li>
</ul>
<hr>
<hr>
<hr>
<ul>
<li>减号</li>
</ul>
<hr>
<h2 id=""><a href="#" class="headerlink" title="- - -"></a>- - -</h2><ul>
<li>下画线  </li>
</ul>
<hr>
<hr>
<hr>
<h2 id="二、图片文件操作"><a href="#二、图片文件操作" class="headerlink" title="二、图片文件操作"></a>二、图片文件操作</h2><h3 id="2-1-插入图片"><a href="#2-1-插入图片" class="headerlink" title="2.1 插入图片"></a>2.1 插入图片</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><p>本地图片<br>（支持相对路径和绝对路径）<br><img src="D:/VisualStudioIDE/background/1.png" alt="本地图片">  </p>
</li>
<li><p>网络图片<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fd5f14e00482699c1c3b3509142b16f88126deff7.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1666447219&amp;t=b8c922e69db81319d3dc686fb66a0e53" alt="网络图片"> </p>
</li>
</ul>
<h3 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h5><p><strong><a href="链接地址">链接文字</a></strong><br>经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a>   </p>
<h5 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h5><p>经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a>  </p>
<p>语法说明如下：</p>
<ul>
<li>链接标记可以有字母、数字、空格和标点符号；</li>
<li>链接标记不区分大小写；</li>
<li>定义的链接内容可以放在当前文件的任意位置，建议放在页尾；</li>
<li>当链接地址为网络地址时要以http/https开头，否则会被识别为本地地址。  <h4 id="网址链接"><a href="#网址链接" class="headerlink" title="网址链接"></a>网址链接</h4>在Markdown中，将网络地址或邮箱地址使用＜＞包裹起来会被自动转换为超链接。<br><strong>邮箱链接示例</strong><br>获取更多信息，请访问MarkStiff的邮箱<a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#76;&#90;&#72;&#x31;&#51;&#49;&#52;&#x35;&#x32;&#49;&#x6c;&#105;&#x67;&#97;&#111;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;">&#76;&#90;&#72;&#x31;&#51;&#49;&#52;&#x35;&#x32;&#49;&#x6c;&#105;&#x67;&#97;&#111;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a>   <h4 id="链接标题"><a href="#链接标题" class="headerlink" title="链接标题"></a>链接标题</h4>如果想了解关于Markdown的更多信息，请查看<a href="基本操作学习.md">Markdown指南</a>   </li>
</ul>
<h3 id="2-3-行内代码与代码块"><a href="#2-3-行内代码与代码块" class="headerlink" title="2.3 行内代码与代码块"></a>2.3 行内代码与代码块</h3><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p><strong>语法格式<code>Insert_Codes</code></strong>  </p>
<ul>
<li>使用<code>mkdir 文件夹</code>命令创建文件夹  </li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p><strong>语法格式：Tab键或4个空格开头</strong> //注意代码块需要隔行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;node;  <br></code></pre></td></tr></table></figure>
<h3 id="2-4-引用"><a href="#2-4-引用" class="headerlink" title="2.4 引用"></a>2.4 引用</h3><p><strong>语法格式：&gt; + 引用内容</strong><br>语法说明如下：</p>
<ol>
<li>多行引用也可以在每一行的开头都插入＞；</li>
<li>在引用中可以嵌套引用；</li>
<li>在引用中可以使用其他的Markdown语法；</li>
<li>段落与换行的格式在引用中也是适用的。  </li>
</ol>
<h4 id="单行引用"><a href="#单行引用" class="headerlink" title="单行引用"></a>单行引用</h4><blockquote>
<p>基于改进的自约束差分进化算法的多目标优化模型  </p>
<h4 id="多行引用"><a href="#多行引用" class="headerlink" title="多行引用"></a>多行引用</h4><p>引用MarkStiff的博客文章<a href="https://www.cnblogs.com/MarkStiff/p/16716797.html">MarkStiff</a><br>算法介绍</p>
<h4 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h4><p>多目标优化模型</p>
<blockquote>
<p>差分进化算法</p>
<blockquote>
<p>改进的自约束处理  </p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="2-5-转义"><a href="#2-5-转义" class="headerlink" title="2.5 转义"></a>2.5 转义</h3><p><strong>介绍</strong><br>当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用 <code>\</code> 进行转义<br><strong>语法格式：\特殊字符</strong>  </p>
<pre><code>`// 常见转义字符`
</code></pre><p>\   反斜线<br>`   反引号<br>*   星号<br>_   底线<br>\{}  花括号<br>[]  方括号<br>()  括弧<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   惊叹号  </p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理笔记</title>
    <url>/2022/10/20/%E5%A4%A7%E7%89%A9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章-静电场"><a href="#第一章-静电场" class="headerlink" title="第一章 静电场"></a>第一章 静电场</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture202211021157027.png" style="zoom:200%;" /></p>
<h3 id="第一讲-库仑定律"><a href="#第一讲-库仑定律" class="headerlink" title="第一讲 库仑定律"></a>第一讲 库仑定律</h3><h4 id="库仑定理——（真空静止点电荷）"><a href="#库仑定理——（真空静止点电荷）" class="headerlink" title="库仑定理——（真空静止点电荷）"></a>库仑定理——（真空静止点电荷）</h4><script type="math/tex; mode=display">
F = \frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\boldsymbol{r}^0\tag 1</script><p>其中真空介电常数 $\varepsilon_0 \approx 8.85\times10^{-12}  C^2N^{-1}m^{-2}$，令 $k=\frac{1}{4\pi\varepsilon_0}$ 则 $k\approx 9\times 10^9Nm^2/C^2$，矢量 $\boldsymbol{r}^0$ 由施力电荷指向受力电荷</p>
<h3 id="第二讲-电场强度-E"><a href="#第二讲-电场强度-E" class="headerlink" title="第二讲 电场强度$E$"></a>第二讲 电场强度$E$</h3><h4 id="2-1-电场强度"><a href="#2-1-电场强度" class="headerlink" title="2.1 电场强度"></a>2.1 电场强度</h4><script type="math/tex; mode=display">
E = \frac{F}{q_0}=\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}\boldsymbol{r}^0\tag 2</script><h4 id="2-2-均匀带电细圆环"><a href="#2-2-均匀带电细圆环" class="headerlink" title="2.2 均匀带电细圆环"></a>2.2 均匀带电细圆环</h4><p>圆环轴线上一点$P$的电场强度：</p>
<script type="math/tex; mode=display">
E = \frac{1}{4\pi\varepsilon_0}\frac{qx}{(R^2+x^2)^\frac{3}{2}}\tag 3</script><p>其中，$x$表示$P$点到圆环中心$O$的距离，$R$表示圆环半径，$q$表示圆环带电量；    </p>
<h4 id="2-3-有限长直线段"><a href="#2-3-有限长直线段" class="headerlink" title="2.3 有限长直线段"></a>2.3 有限长直线段</h4><p>直线外一点$P$电场强度：</p>
<script type="math/tex; mode=display">
E_x=\frac{\lambda}{4\pi\varepsilon_0 a}(cos\theta_1-cos\theta_2)\\
E_y=\frac{\lambda}{4\pi\varepsilon_0 a}(sin\theta_2-sin\theta_1)\tag 4</script><p>注：在建立坐标系的情况下，上式均带有方向，其中沿 $y$ 轴正向：$\theta_1\rightarrow \theta_2$，$\theta$ 为与 $y$ 轴正向夹角；<br>其中，$a$表示$P$点到直线的垂直距离；    </p>
<h4 id="2-4-均匀带电无限长直线"><a href="#2-4-均匀带电无限长直线" class="headerlink" title="2.4 均匀带电无限长直线"></a>2.4 均匀带电无限长直线</h4><p>由 $2.4$ 推得：令$\theta_1=0,\theta_2=\pi$     </p>
<script type="math/tex; mode=display">
E_x = \frac{\lambda}{2\pi\varepsilon_0 a}, E_y = 0\tag 5</script><h4 id="2-5-均匀带电无限大平面"><a href="#2-5-均匀带电无限大平面" class="headerlink" title="2.5 均匀带电无限大平面"></a>2.5 均匀带电无限大平面</h4><script type="math/tex; mode=display">
E=\frac{\sigma}{2\varepsilon_0} \tag 6</script><h4 id="2-6-无限大均匀带异号电荷平板间"><a href="#2-6-无限大均匀带异号电荷平板间" class="headerlink" title="2.6 无限大均匀带异号电荷平板间"></a>2.6 无限大均匀带异号电荷平板间</h4><script type="math/tex; mode=display">
E=\frac{\sigma}{\varepsilon_0}\tag 7</script><p>其中，$\sigma$表示每个平板的电荷面密度；     </p>
<h4 id="2-7-电偶极子"><a href="#2-7-电偶极子" class="headerlink" title="2.7 电偶极子"></a>2.7 电偶极子</h4><p>电偶极矩：$\boldsymbol{p}=q\boldsymbol{l}$<br>中垂线上一点$P$场强：</p>
<script type="math/tex; mode=display">
E = -\frac{\boldsymbol{p}}{4\pi\varepsilon_0y^3}   (y\gg l)\tag 8</script><p>共线上一点$P$场强：   </p>
<script type="math/tex; mode=display">
E=\frac{2\boldsymbol{p}}{4\pi\varepsilon_0x^3}(x\gg l)\tag 9</script><p>其中$\boldsymbol{l}$方向由负电荷指向正电荷；     </p>
<h4 id="2-8-力偶矩"><a href="#2-8-力偶矩" class="headerlink" title="2.8 力偶矩"></a>2.8 力偶矩</h4><p>电偶极子在匀强电场中得力偶矩：</p>
<script type="math/tex; mode=display">
\boldsymbol{F}_+=q\boldsymbol{E},\boldsymbol{F}_-=-q\boldsymbol{E}\\
M = F_+\cdot\frac{1}{2}lsin\theta+F_-\cdot\frac{1}{2}lsin\theta=qlEsin\theta\\
\Rightarrow\boldsymbol{M}=q\boldsymbol{l}\times\boldsymbol{E}=\boldsymbol{p}\times\boldsymbol{E}\tag{10}</script><p>注：电偶极子在电场的作用下总要使 $\boldsymbol{p}$ 转向 $\boldsymbol{E}$ 的方向；    </p>
<h3 id="第三讲-电通量-bigstar-高斯定理"><a href="#第三讲-电通量-bigstar-高斯定理" class="headerlink" title="第三讲 电通量 $\bigstar$高斯定理"></a>第三讲 电通量 $\bigstar$高斯定理</h3><h4 id="3-1-电通量"><a href="#3-1-电通量" class="headerlink" title="3.1 电通量"></a>3.1 电通量</h4><script type="math/tex; mode=display">
\Phi_e=\oint_S\boldsymbol{E}\cdot d\boldsymbol{S}\tag{11}</script><h4 id="3-2-高斯定理"><a href="#3-2-高斯定理" class="headerlink" title="3.2 高斯定理"></a>3.2 高斯定理</h4><p>选定高斯面后，电通量：</p>
<script type="math/tex; mode=display">
\Phi_e=\oint_S\boldsymbol{E}\cdot d\boldsymbol{S}=\frac{1}{\varepsilon_0}\sum_{(内)}q_i\tag{12}</script><h4 id="3-3-轴对称性电场"><a href="#3-3-轴对称性电场" class="headerlink" title="3.3 轴对称性电场"></a>3.3 轴对称性电场</h4><p>无限长均匀带电直线外一点$P$场强：</p>
<script type="math/tex; mode=display">
\Phi_e=\boldsymbol{E}\oint_侧d\boldsymbol{S}=2\pi rEl=\frac{1}{\varepsilon_0}\lambda l\\
\Rightarrow E = \frac{\lambda}{2\pi\varepsilon_0r}\tag{13}</script><p>其中，$r$表示$P$距离导线垂直距离；    </p>
<h4 id="3-4-球面对称性电场"><a href="#3-4-球面对称性电场" class="headerlink" title="3.4 球面对称性电场"></a>3.4 球面对称性电场</h4><p>均匀带电球面电场分布：</p>
<script type="math/tex; mode=display">
\Phi_e=\boldsymbol{E}\oint_S\boldsymbol{S}=E\cdot 4\pi r^2=\sum_{(内)}q_i=q\\
\Rightarrow E=\left\{\begin{array}{lcc} \frac{1}{4\pi \varepsilon_0}\frac{q}{r^2}\boldsymbol{r}^0&(r>R) \\ 0&(r<R)\tag{14}\end{array}\right.</script><h4 id="3-5-无限大均匀带电平面"><a href="#3-5-无限大均匀带电平面" class="headerlink" title="3.5 无限大均匀带电平面"></a>3.5 无限大均匀带电平面</h4><p>选定圆柱面作为高斯面：</p>
<script type="math/tex; mode=display">
\Phi_e=\oint_{左端面}\boldsymbol{E}\cdot d\boldsymbol{S}+\oint_{右端面}\boldsymbol{E}\cdot d\boldsymbol{S}=2ES=\frac{1}{\varepsilon_0}\sigma S\\
\Rightarrow E=\frac{\sigma}{2\varepsilon_0}\tag{15}</script><h4 id="3-6-均匀带电圆盘"><a href="#3-6-均匀带电圆盘" class="headerlink" title="3.6 均匀带电圆盘"></a>3.6 均匀带电圆盘</h4><script type="math/tex; mode=display">
E = \frac{\sigma}{2\varepsilon_0}(1-\frac{x}{\sqrt{R^2+x^2}})\tag{16}</script><h4 id="3-7-均匀带电球体"><a href="#3-7-均匀带电球体" class="headerlink" title="3.7 均匀带电球体"></a>3.7 均匀带电球体</h4><script type="math/tex; mode=display">
\boldsymbol{E}=\left\{\begin{array}{c}\frac{Q}{4\pi\varepsilon_0r^2}\boldsymbol{r_0}&(r>R)\\\frac{\rho}{3\varepsilon_0}\boldsymbol{r} & (r<R)\end{array}\right.</script><h3 id="第四讲-静电场的环路定理-电势能"><a href="#第四讲-静电场的环路定理-电势能" class="headerlink" title="第四讲 静电场的环路定理 电势能"></a>第四讲 静电场的环路定理 电势能</h3><h4 id="4-1-电场强度环流"><a href="#4-1-电场强度环流" class="headerlink" title="4.1 电场强度环流"></a>4.1 电场强度环流</h4><script type="math/tex; mode=display">
\oint\boldsymbol{E}\cdot d\boldsymbol{l}=0\tag{17}</script><p>环路定理表明静电场是无旋有源场；     </p>
<h4 id="4-2-电势能"><a href="#4-2-电势能" class="headerlink" title="4.2 电势能"></a>4.2 电势能</h4><p>选定电势能零参考点，则点$A$处的电势能：</p>
<script type="math/tex; mode=display">
w_a=A_{a'0'}=\int_a^{'0'}q_0\boldsymbol{E}\cdot d\boldsymbol{l}\tag{18}</script><p>注：电势能是标量，相对于电势能零参考点有负值；           </p>
<h3 id="第五讲-电势-电势差"><a href="#第五讲-电势-电势差" class="headerlink" title="第五讲 电势 电势差"></a>第五讲 电势 电势差</h3><h4 id="5-1-电势与电势差"><a href="#5-1-电势与电势差" class="headerlink" title="5.1 电势与电势差"></a>5.1 电势与电势差</h4><p>$A$点电势：</p>
<script type="math/tex; mode=display">
u_a=\frac{W_a}{q_0}=\int_a^{'0'}\boldsymbol{E}\cdot d\boldsymbol{l}\tag{19}</script><p>注：电势为标量；     </p>
<script type="math/tex; mode=display">
U_{ab}=u_a-u_b=\int_a^b\boldsymbol{E}\cdot d\boldsymbol{l}\tag{20}</script><p>电荷$q$$a\rightarrow b$时，静电力做功：</p>
<script type="math/tex; mode=display">
A_{ab}=q(u_a-u_b)\tag{21}</script><h4 id="5-2-电偶极子电势能"><a href="#5-2-电偶极子电势能" class="headerlink" title="5.2 电偶极子电势能"></a>5.2 电偶极子电势能</h4><p>在电场 $\boldsymbol{E}$ 中：</p>
<script type="math/tex; mode=display">
W=-\boldsymbol{p}\cdot\boldsymbol{E}\tag{22}</script><p>当$\boldsymbol{E}$为非均匀电场时，上式应改为积分形式；<br>在电场中做功：</p>
<script type="math/tex; mode=display">
W_{\theta_1\theta_2}=\left\{\begin{array}{ll}-\boldsymbol{p}\cdot\boldsymbol{E}(\theta_1)-(-\boldsymbol{p}\cdot\boldsymbol{E}(\theta_2))\\
\int_{\theta_1}^{\theta_2}-\boldsymbol{p}\times\boldsymbol{E}d\theta\end{array}\right.</script><h4 id="5-3-电势叠加原理"><a href="#5-3-电势叠加原理" class="headerlink" title="5.3 电势叠加原理"></a>5.3 电势叠加原理</h4><p>对于点电荷选取无穷远处作为零电势点：</p>
<script type="math/tex; mode=display">
u_a=\int_a^{\infty}\boldsymbol{E}\cdot d\boldsymbol{l}=\frac{1}{4\pi\varepsilon_0}\frac{q}{r}\\
W_a = \frac{1}{4\pi\varepsilon_0}\frac{q^2}{r}\tag{23}</script><p>叠加原理——标量叠加         </p>
<script type="math/tex; mode=display">
u_a=\sum u_i\\
\Rightarrow u_a=\int_Q\frac{1}{4\pi\varepsilon_0}\frac{dq}{r}(积分形式)\tag{24}</script><h4 id="5-4-电荷分布求电势"><a href="#5-4-电荷分布求电势" class="headerlink" title="5.4 电荷分布求电势"></a>5.4 电荷分布求电势</h4><p>积分形式：</p>
<script type="math/tex; mode=display">
u_a=\int_Q\frac{1}{4\pi\varepsilon_0}\frac{dq}{r}\tag{25}</script><p>电偶极子外任一点$C$的电势：</p>
<script type="math/tex; mode=display">
U_C = \frac{1}{4\pi\varepsilon_0}\frac{q}{r_+}-\frac{1}{4\pi\varepsilon_0}\frac{q}{r_-}=\frac{q}{4\pi\varepsilon_0}\frac{r_--r_+}{r_-r_+}\\
r\gg l\Rightarrow r_+r_-\approx r^2,r_--r_+\approx lcos\theta\\
\Rightarrow u_C = \frac{1}{4\pi\varepsilon_0}\frac{\boldsymbol{p}\cdot\boldsymbol{r}}{r^3}\tag{26}</script><h4 id="5-5-电场强度求电势"><a href="#5-5-电场强度求电势" class="headerlink" title="5.5 电场强度求电势"></a>5.5 电场强度求电势</h4><p>场强与电势关系：</p>
<script type="math/tex; mode=display">
u_a=\int_a^{\infty}\boldsymbol{E}\cdot d\boldsymbol{l}\tag{27}</script><p>带电体电荷分布具有对称性时，利用高斯定理求出场强分布进而求电势；<br><strong>【无限长均匀带电圆柱面】</strong><br>由高斯定理求得电场分布：</p>
<script type="math/tex; mode=display">
E = \left\{ \begin{array}{c}0 & r<R \\ \frac{\lambda}{2\pi\varepsilon_0r} & r>R\end{array}\right.\tag{28}</script><p>_一般而言，当电荷分布延伸到无穷远时，是不能选取无穷远处为电势零参考点的；_     </p>
<script type="math/tex; mode=display">
u_P=\int_P^{P_0}\boldsymbol{E}\cdot d\boldsymbol{l}=\int_P^{P'}\boldsymbol{E}\cdot d\boldsymbol{l}+\int_{P'}^{P_0}\boldsymbol{E}\cdot d\boldsymbol{l}\\
=0+\int_r^{r_0}\frac{\lambda}{2\pi\varepsilon_0r}dr\\
=-\frac{\lambda}{2\pi\varepsilon_0}\ln r+\frac{\lambda}{2\pi\varepsilon_0}\ln r_0\\
=-\frac{\lambda}{2\pi\varepsilon_0}\ln r+C(r>R)\tag{29}</script><script type="math/tex; mode=display">
u_P=\int_P^{P_0}\boldsymbol{E}\cdot d\boldsymbol{l}=\int_r^R\boldsymbol{E}\cdot d\boldsymbol{l}+\int_R^{r_0}\boldsymbol{E}\cdot d\boldsymbol{l}\\
=0+\int_R^{r_0}\frac{\lambda}{2\pi\varepsilon_0r}dr\\
=-\frac{\lambda}{2\pi\varepsilon_0}\ln R + C(r<R)\tag{30}</script><p>其中，$C=\frac{\lambda}{2\pi\varepsilon_0}\ln r_0$     </p>
<h4 id="5-6-均匀带电球面电势"><a href="#5-6-均匀带电球面电势" class="headerlink" title="5.6 均匀带电球面电势"></a>5.6 均匀带电球面电势</h4><script type="math/tex; mode=display">
V(r) = \left\{ \begin{array}{c}\frac{1}{4\pi\varepsilon_0} \frac{q}{R} & (r \le R)\\\frac{1}{4\pi\varepsilon_0}\frac{q}{r}&(r>R)\end{array}\right.\tag{31}</script><h4 id="5-7-均匀带电球体电势"><a href="#5-7-均匀带电球体电势" class="headerlink" title="5.7 均匀带电球体电势"></a>5.7 均匀带电球体电势</h4><p>球内距离球心$r$处一点$P$电势：</p>
<script type="math/tex; mode=display">
u = u_1+u_2=\frac{1}{4\pi\varepsilon_0}\frac{Q}{R^3}r^2+\int_r^R\frac{1}{4\pi\varepsilon_0}\frac{dq_2}{r'}\\
=\frac{1}{4\pi\varepsilon_0}\frac{Q}{R^3}r^2+\int_r^R\frac{3Qr'}{4\pi\varepsilon_0R^3}dr'\\
=\frac{Q(3R^2-r^2)}{8\pi\varepsilon_0R^3}(r<R)\tag{32}</script><p>球外距离球心$r$处一点$P$电势：</p>
<script type="math/tex; mode=display">
u = \frac{Q}{4\pi\varepsilon_0r}(r\ge R)\tag{33}</script><p>注：在$P$点的电场强度犹如电荷集中在球心处的点电荷在$P$点产生的电场强度一样，故电势同理；       </p>
<h3 id="第六讲-电势与场强微分关系"><a href="#第六讲-电势与场强微分关系" class="headerlink" title="第六讲 电势与场强微分关系"></a>第六讲 电势与场强微分关系</h3><script type="math/tex; mode=display">
E = -\frac{du}{dn}\\
E_l=-\frac{du}{dl}\\
\boldsymbol{E}=-(\frac{\partial u}{\partial x}\boldsymbol{i}+\frac{\partial u}{\partial y}\boldsymbol{j}+\frac{\partial u}{\partial z}\boldsymbol{k})\\
u(x,y,z)\Rightarrow E(x,y,z)\tag{34}</script><h3 id="第七讲-静电场中的导体-电容"><a href="#第七讲-静电场中的导体-电容" class="headerlink" title="第七讲 静电场中的导体 电容"></a>第七讲 静电场中的导体 电容</h3><h4 id="7-1-静电平衡导体表面"><a href="#7-1-静电平衡导体表面" class="headerlink" title="7.1 静电平衡导体表面"></a>7.1 静电平衡导体表面</h4><p>电场强度：</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\frac{\sigma}{\varepsilon_0}\boldsymbol{n}\tag{35}</script><p>区别于无限大带电平面产生的电场(缺少静电平衡的条件)：</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\frac{\sigma}{2\varepsilon_0}\boldsymbol{n}\tag{36}</script><h4 id="7-2-孤立导体电容"><a href="#7-2-孤立导体电容" class="headerlink" title="7.2 孤立导体电容"></a>7.2 孤立导体电容</h4><script type="math/tex; mode=display">
C = \frac{q}{u}\tag{37}</script><h4 id="7-3-平行板电容器电容"><a href="#7-3-平行板电容器电容" class="headerlink" title="7.3 平行板电容器电容"></a>7.3 平行板电容器电容</h4><script type="math/tex; mode=display">
C = \frac{q}{u_1-u_2}\\
=\frac{q}{Ed}=\frac{q}{\frac{\sigma}{\varepsilon_0}d}\\
=\frac{q}{\frac{qd}{\varepsilon_0S}}=\frac{\varepsilon_0S}{d}\tag{38}</script><h4 id="7-4-球形电容器电容"><a href="#7-4-球形电容器电容" class="headerlink" title="7.4 球形电容器电容"></a>7.4 球形电容器电容</h4><p>两球面间电场强度：</p>
<script type="math/tex; mode=display">
E=\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}\tag{39}</script><script type="math/tex; mode=display">
u_1-u_2=\int_{R_1}^{R_2}\boldsymbol{E}\cdot d\boldsymbol{l} = \int_{R_1}^{R_2}\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}dr\\
=\frac{q}{4\pi\varepsilon_0}\frac{R_2-R_1}{R_1R_2}\\
\Rightarrow C = \frac{q}{u_1-u_2}=\frac{4\pi\varepsilon_0R_1R_2}{R_2-R_1}\tag{40}</script><h4 id="7-5-电容器串并联"><a href="#7-5-电容器串并联" class="headerlink" title="7.5 电容器串并联"></a>7.5 电容器串并联</h4><script type="math/tex; mode=display">
\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}+\cdot\cdot\cdot+\frac{1}{C_n}(串联)\\
C = C_1+C_2+\cdot\cdot\cdot+C_n(并联)\tag{41}</script><h3 id="第八讲-静电能"><a href="#第八讲-静电能" class="headerlink" title="第八讲 静电能"></a>第八讲 静电能</h3><h4 id="8-1-静电能公式推导"><a href="#8-1-静电能公式推导" class="headerlink" title="8.1 静电能公式推导"></a>8.1 静电能公式推导</h4><script type="math/tex; mode=display">
U(t) = \frac{q(t)}{C}\\dA = U(t)dq = \frac{q(t)}{C}dq\\
A = \int dA = \int_0^Q\frac{q(t)}{C}dq=\frac{Q^2}{2C}\\
Q=CU\Rightarrow A = \frac{1}{2}CU^2=\frac{1}{2}QU\\
\Rightarrow W=A=\frac{Q^2}{2C}=\frac{1}{2}CU^2=\frac{1}{2}QU\tag{42}</script><h4 id="8-2-电场能量密度推导"><a href="#8-2-电场能量密度推导" class="headerlink" title="8.2 电场能量密度推导"></a>8.2 电场能量密度推导</h4><script type="math/tex; mode=display">
U=Ed, C = \frac{\varepsilon_0S}{d}\\
\Rightarrow W = \frac{1}{2}\varepsilon_0E^2Sd = \frac{1}{2}\varepsilon_0E^2V\\
\Rightarrow \omega = \frac{W}{V}=\frac{1}{2}\varepsilon_0E^2\tag{43}</script><h3 id="第九讲-电介质的极化-束缚电荷"><a href="#第九讲-电介质的极化-束缚电荷" class="headerlink" title="第九讲 电介质的极化 束缚电荷"></a>第九讲 电介质的极化 束缚电荷</h3><h4 id="9-1-电介质"><a href="#9-1-电介质" class="headerlink" title="9.1 电介质"></a>9.1 电介质</h4><script type="math/tex; mode=display">
C = \varepsilon_r C_0\tag{44}</script><p>其中，$\varepsilon_r$ 称为介质的相对介电常数（相对电容率），$C_0$ 表示真空中对应的电容；因此，除真空中 $\varepsilon_r=1$ 外，其余 $\varepsilon_r&gt;1$；    </p>
<h4 id="9-2-介质极化"><a href="#9-2-介质极化" class="headerlink" title="9.2 介质极化"></a>9.2 介质极化</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}有极分子\Rightarrow 取向极化\\
无极分子\Rightarrow 位移极化\end{array}\right.</script><h3 id="第十讲-电介质内的电场强度"><a href="#第十讲-电介质内的电场强度" class="headerlink" title="第十讲 电介质内的电场强度"></a>第十讲 电介质内的电场强度</h3><p>根据电介质极化原理推导：</p>
<script type="math/tex; mode=display">
\boldsymbol{E} = \boldsymbol{E}_0+\boldsymbol{E}'\\
E_0=\frac{\sigma_0}{\varepsilon_0},E'=\frac{\sigma'}{\varepsilon_0}\\
\Rightarrow E = \frac{\sigma_0}{\varepsilon_0}-\frac{\sigma'}{\varepsilon_0}\\E = \frac{E_0}{\varepsilon_r}\\
\Rightarrow \sigma'=(1-\frac{1}{\varepsilon_r})\sigma_0\tag{45}</script><h3 id="第十一讲-bigstar-电介质中的高斯定理"><a href="#第十一讲-bigstar-电介质中的高斯定理" class="headerlink" title="第十一讲 $\bigstar$电介质中的高斯定理"></a>第十一讲 $\bigstar$电介质中的高斯定理</h3><h4 id="11-1-电位移矢量"><a href="#11-1-电位移矢量" class="headerlink" title="11.1 电位移矢量"></a>11.1 电位移矢量</h4><p>推导：</p>
<script type="math/tex; mode=display">
\iint_S\boldsymbol{E}\cdot d\boldsymbol{S}=\frac{1}{\varepsilon_0}(\sigma_0-\sigma')S\\
式(45)\Rightarrow \frac{1}{\varepsilon_0}(\sigma_0-\sigma')=\frac{\sigma_0}{\varepsilon_0\varepsilon_r}\\
\Rightarrow \iint_S\varepsilon_0\varepsilon_r\boldsymbol{E}\cdot d\boldsymbol{S}=\varepsilon_0S=q_0\\
令\boldsymbol{D} = \varepsilon\boldsymbol{E} = \varepsilon_0\varepsilon_r\boldsymbol{E}\\
\Rightarrow \iint_S\boldsymbol{D}\cdot d\boldsymbol{S} = q_0\tag{46}</script><p>其中，$D$ 称为电位移矢量或电通密度，$\varepsilon = \varepsilon_0\varepsilon_r$ 称为电介质的介电常数；    </p>
<h4 id="11-2-电介质中的能量密度"><a href="#11-2-电介质中的能量密度" class="headerlink" title="11.2 电介质中的能量密度"></a>11.2 电介质中的能量密度</h4><script type="math/tex; mode=display">
\omega = \frac{1}{2}\boldsymbol{D}\cdot\boldsymbol{E}\\
\varepsilon_r = 1\Rightarrow \omega = \frac{1}{2}\varepsilon_0E^2(真空中)\tag{47}</script><h3 id="第十二讲-经典习题"><a href="#第十二讲-经典习题" class="headerlink" title="第十二讲 经典习题"></a>第十二讲 经典习题</h3><p><img src="https://s1.ax1x.com/2022/10/21/x6HOKS.md.png" alt="x6HOKS.md.png"><br><img src="https://s1.ax1x.com/2022/10/21/x6HxEj.md.png" alt="x6HxEj.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcDqsK.md.png" alt="xcDqsK.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcDLqO.md.png" alt="xcDLqO.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcrX60.md.png" alt="xcrX60.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcs8jP.md.png" alt="xcs8jP.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcyRqf.md.png" alt="xcyRqf.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcyhdS.md.png" alt="xcyhdS.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcy4Ig.md.png" alt="xcy4Ig.md.png"><br><img src="https://s1.ax1x.com/2022/10/22/xcyTRs.png" alt="xcyTRs.png" style="zoom:141.3%;" /><br><img src="https://s1.ax1x.com/2022/10/22/xcybMq.png" alt="xcybMq.png" style="zoom:143%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051126108.png" style="zoom:88.1%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051127368.png" style="zoom:87.3%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051135357.png" style="zoom:45.8%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051135852.png" style="zoom:46.39%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051156275.png" style="zoom:53.55%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051157253.png" style="zoom:49.2%;" /></p>
<h2 id="第二章-恒定电流的磁场"><a href="#第二章-恒定电流的磁场" class="headerlink" title="第二章 恒定电流的磁场"></a>第二章 恒定电流的磁场</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture202211021159616.png" alt="xc6lOP.md.jpg" style="zoom:200%;" /></p>
<h3 id="第一讲-磁感应强度-B"><a href="#第一讲-磁感应强度-B" class="headerlink" title="第一讲 磁感应强度$B$"></a>第一讲 磁感应强度$B$</h3><p>电流元$Idl$所受磁场力：</p>
<script type="math/tex; mode=display">
d\boldsymbol{F} = Id\boldsymbol{l}\times\boldsymbol{B}\tag{1}</script><h3 id="第二讲-毕奥-萨伐尔定律"><a href="#第二讲-毕奥-萨伐尔定律" class="headerlink" title="第二讲 毕奥-萨伐尔定律"></a>第二讲 毕奥-萨伐尔定律</h3><h4 id="2-1-电流元的磁场"><a href="#2-1-电流元的磁场" class="headerlink" title="2.1 电流元的磁场"></a>2.1 电流元的磁场</h4><script type="math/tex; mode=display">
d\boldsymbol{B} = \frac{\mu_0}{4\pi}\frac{Id\boldsymbol{l}\times\boldsymbol{r}^0}{r^2}\tag{2}</script><p>其中，$\mu_0=4\pi\times10^{-7}N/A^2$称为真空磁导率，$\boldsymbol{r}_0$表示到$P$点的单位矢量，$r$表示到$P$点的距离；     </p>
<h4 id="2-2-运动电荷的磁场"><a href="#2-2-运动电荷的磁场" class="headerlink" title="2.2 运动电荷的磁场"></a>2.2 运动电荷的磁场</h4><script type="math/tex; mode=display">
\boldsymbol{B} = \frac{d\boldsymbol{B}}{dN}=\frac{\mu_0}{4\pi}\frac{q\boldsymbol{v}\times\boldsymbol{r}^0}{r^2}\tag{3}</script><h4 id="2-3-载流直导线的磁场"><a href="#2-3-载流直导线的磁场" class="headerlink" title="2.3 载流直导线的磁场"></a>2.3 载流直导线的磁场</h4><script type="math/tex; mode=display">
dB = \frac{\mu_0}{4\pi}\frac{Idlsin\theta}{r^2}\\
\Rightarrow B = \frac{\mu_0I}{4\pi r}\int_{\theta_1}^{\theta_2}sin\theta d\theta=\frac{\mu_0I}{4\pi r}(cos\theta_1-cos\theta_2)\\
\theta_1\approx 0,\theta_2\approx\pi\Rightarrow B = \frac{\mu_0I}{2\pi r}\tag{4}</script><p>式中，$r$表示到载流导线的距离；    </p>
<h4 id="2-4-载流圆环的磁场"><a href="#2-4-载流圆环的磁场" class="headerlink" title="2.4 载流圆环的磁场"></a>2.4 载流圆环的磁场</h4><script type="math/tex; mode=display">
B = \int dB_x = \int dBcos\theta = \frac{\mu_0}{4\pi}\int \frac{Idl}{r^2}cos\theta\\
cos\theta = \frac{R}{r}=\frac{R}{(R^2+x^2)^{1/2}}\\
\Rightarrow B = \frac{\mu_0IR^2}{2(R^2+x^2)^{3/2}}\tag{5}</script><p>【$N$匝线圈】</p>
<script type="math/tex; mode=display">
B = \frac{\mu_0IR^2N}{2(R^2+x^2)^{3/2}}\tag{6}</script><p>【圆弧磁场】</p>
<script type="math/tex; mode=display">
式(5) x = 0\Rightarrow B = \frac{\mu_0I}{2R}(圆心处)\\
\Rightarrow B =  \frac{\mu_0I}{2R}\cdot\frac{\varphi}{2\pi}=\frac{\mu_0I\varphi}{4\pi R}\tag{7}</script><h4 id="2-5-载流线圈的磁矩"><a href="#2-5-载流线圈的磁矩" class="headerlink" title="2.5 载流线圈的磁矩"></a>2.5 载流线圈的磁矩</h4><script type="math/tex; mode=display">
式(5)令x\gg R,(x^2+R^2)\approx x^2\\
\Rightarrow B\approx \frac{\mu_0IR^2}{2x^3} = \frac{\mu_0I\pi R^2}{2\pi x^3}=\frac{\mu_0 IS}{2\pi x^3}\\
\Rightarrow 定义:\ \ \ \ \boldsymbol{p}_m = IS\boldsymbol{n}\\
\boldsymbol{B} = \frac{\mu_0}{2\pi}\frac{\boldsymbol{p}_m}{x^3}\tag{8}</script><p>其中，$\boldsymbol{n}$表示线圈平面正法线方向上的单位矢量；<br>圆心处的磁感应强度：</p>
<script type="math/tex; mode=display">
\boldsymbol{B} = \frac{\mu_0}{2\pi}\frac{\boldsymbol{p}_m}{R^3}\tag{9}</script><h4 id="2-6-无限大均匀载流平面"><a href="#2-6-无限大均匀载流平面" class="headerlink" title="2.6 无限大均匀载流平面"></a>2.6 无限大均匀载流平面</h4><script type="math/tex; mode=display">
dB = \frac{\mu_0\alpha dx}{2\pi\sqrt{r^2+x^2}}\\
由对称性：B_x = \int dB_x, \ \ \ B_y = \int dB_y = 0\\
B = B_x = \int \frac{r}{\sqrt{r^2+x^2}}\cdot \frac{\mu_0 \alpha dx}{2\pi\sqrt{r^2+x^2}} =\int \frac{\mu_0 \alpha r dx}{2\pi (r^2+x^2)}\\
=\frac{\mu_0 \alpha r}{2\pi}\int_{-\infty}^{+\infty}\frac{1}{r^2+x^2}dx=\frac{\mu_0 \alpha}{2}\\
故\ \ \ B = \frac{1}{2}\mu_0\alpha\tag{10}</script><p>式中，$r$ 表示$P$点距到无限大载流平面的距离，$\alpha$ 表示流过单位长度的电流；    </p>
<h4 id="2-7-均匀密绕直螺线管"><a href="#2-7-均匀密绕直螺线管" class="headerlink" title="2.7 均匀密绕直螺线管"></a>2.7 均匀密绕直螺线管</h4><script type="math/tex; mode=display">
dB = \frac{\mu_0R^2dI'}{2(R^2+l^2)^{3/2}} = \frac{\mu_0R^2Indl}{2(R^2+l^2)^{3/2}}\\
l = Rcot\beta\ ,\ \ \ dl = -Rcsc^2\beta d\beta\ , \ \ \ \R^2+l^2 = R^2csc^2\beta\\
\Rightarrow dB= -\frac{\mu_0}{2}nIsin\beta d\beta\\
\Rightarrow B =\int_{\beta_1}^{\beta_2}-\frac{\mu_0}{2}nIsin\beta d\beta = \frac{\mu_0nI}{2}(cos\beta_2-cos\beta_1)\tag{11}</script><p>【无限长】</p>
<script type="math/tex; mode=display">
L\gg R,\ \ \beta_1\rightarrow\pi, \ \ \beta_2\rightarrow 0 \Rightarrow B = \mu_0nI\tag{12}</script><p>【半无限长】<br>端点处：</p>
<script type="math/tex; mode=display">
\beta_1 = \frac{\pi}{2}, \ \ \beta_2\rightarrow 0\ , 或 \ \ \beta_1\rightarrow \pi, \ \ \beta_2=\frac{\pi}{2}\Rightarrow B = \frac{\mu_0nI}{2}\tag{13}</script><p>式中，$n$表示单位长度上的线圈匝数；      </p>
<h3 id="第三讲-磁通量-磁场的高斯定理"><a href="#第三讲-磁通量-磁场的高斯定理" class="headerlink" title="第三讲 磁通量 磁场的高斯定理"></a>第三讲 磁通量 磁场的高斯定理</h3><h4 id="3-1-磁通量"><a href="#3-1-磁通量" class="headerlink" title="3.1 磁通量"></a>3.1 磁通量</h4><script type="math/tex; mode=display">
\Phi_m = \int_S \boldsymbol{B}\cdot d\boldsymbol{S}\tag{14}</script><h4 id="3-2-高斯定理-1"><a href="#3-2-高斯定理-1" class="headerlink" title="3.2 高斯定理"></a>3.2 高斯定理</h4><script type="math/tex; mode=display">
\oint_S \boldsymbol{B}\cdot d\boldsymbol{S}=0\tag{15}</script><h3 id="第四讲-bigstar-安培环路定理"><a href="#第四讲-bigstar-安培环路定理" class="headerlink" title="第四讲 $\bigstar$安培环路定理"></a>第四讲 $\bigstar$安培环路定理</h3><script type="math/tex; mode=display">
\oint_L\boldsymbol{B}\cdot d\boldsymbol{l}=\mu_0\sum_{(内)}I_i\tag{16}</script><p>式中，$I_i$ 的正（负）取决于电流方向与闭合路径 $L$ 绕行方向满足（不满足）右螺旋法则；$B$ 表示闭合路径 $L$ 内外所有电流产生的总磁感应强度；<br>【无限大载流平面】<br><img src="https://s1.ax1x.com/2022/10/22/xchO56.md.png" alt="xchO56.md.png"></p>
<script type="math/tex; mode=display">
\oint_L\boldsymbol{B}\cdot d\boldsymbol{l} = \int_{PQ}\boldsymbol{B}\cdot d\boldsymbol{l}+\int_{QR}\boldsymbol{B}\cdot d\boldsymbol{l}+\int_{RS}\boldsymbol{B}\cdot d\boldsymbol{l}+\int_{SP}\boldsymbol{B}\cdot d\boldsymbol{l}\\
=Bx+0+Bx+0 = 2Bx = \mu_0 \alpha x\\
\Rightarrow B = \frac{1}{2}\mu_0\alpha\tag{17}</script><h3 id="第五讲-磁场对电流作用"><a href="#第五讲-磁场对电流作用" class="headerlink" title="第五讲 磁场对电流作用"></a>第五讲 磁场对电流作用</h3><h4 id="5-1-载流导线"><a href="#5-1-载流导线" class="headerlink" title="5.1 载流导线"></a>5.1 载流导线</h4><p>所受安培力：</p>
<script type="math/tex; mode=display">
\boldsymbol{F} = \int_LId\boldsymbol{l}\times\boldsymbol{B}\tag{18}</script><h4 id="5-2-载流线圈"><a href="#5-2-载流线圈" class="headerlink" title="5.2 载流线圈"></a>5.2 载流线圈</h4><p>所受磁力矩：</p>
<script type="math/tex; mode=display">
M = F_{ab}l_1sin\varphi=BIl_1l_2sin\varphi=BISsin\varphi\\
\boldsymbol{p}_m = IS\boldsymbol{n}\\
\Rightarrow \boldsymbol{M}=\boldsymbol{p}_m\times\boldsymbol{B}\tag{19}</script><p>式中，$\boldsymbol{n}$ 的方向按电流方向用右螺旋法则确定；     </p>
<h4 id="5-3-磁力的功"><a href="#5-3-磁力的功" class="headerlink" title="5.3 磁力的功"></a>5.3 磁力的功</h4><script type="math/tex; mode=display">
A = F\overline{aa'} = BIl\overline{aa'}=BI\vartriangle S = I\vartriangle\Phi\\
\Rightarrow A = \int_{\Phi_1}^{\Phi_2}Id\Phi = I(\Phi_2-\Phi_1)=I\vartriangle\Phi\tag{20}</script><h4 id="5-4-磁偶极子势能"><a href="#5-4-磁偶极子势能" class="headerlink" title="5.4 磁偶极子势能"></a>5.4 磁偶极子势能</h4><p>载流线圈相当于磁偶极子，因此载流线圈同理；     </p>
<script type="math/tex; mode=display">
\varphi = \frac{\pi}{2}时,\  \ \ W = 0(零势能点)\\
W = -A = -\int_\varphi^{\pi/2}Md\varphi = -p_mB\int_\varphi^{\pi/2}sin\varphi d\varphi = -p_mBcos\varphi\\
\Rightarrow W = -\boldsymbol{p}_m\cdot \boldsymbol{B}\tag{21}</script><h3 id="第六讲-带电粒子在电场和磁场中的运动"><a href="#第六讲-带电粒子在电场和磁场中的运动" class="headerlink" title="第六讲 带电粒子在电场和磁场中的运动"></a>第六讲 带电粒子在电场和磁场中的运动</h3><h4 id="6-1-洛伦兹力"><a href="#6-1-洛伦兹力" class="headerlink" title="6.1 洛伦兹力"></a>6.1 洛伦兹力</h4><script type="math/tex; mode=display">
\boldsymbol{F} = q\boldsymbol{v}\times\boldsymbol{B}\tag{22}</script><p>式中，$q$ 包含电荷正负特性符号；</p>
<h4 id="6-2-霍尔效应"><a href="#6-2-霍尔效应" class="headerlink" title="6.2 霍尔效应"></a>6.2 霍尔效应</h4><script type="math/tex; mode=display">
q\overline{v}B=qE\Rightarrow E = \overline{v}B\\
U = El = vBl\\
I = nqS\overline{v}\\
\Rightarrow U = \frac{IB}{nqd} = K\frac{IB}{d}\\
K = \frac{1}{nq}(霍尔系数)\tag{23}</script><p>式中，$d$ 和 $l$ 分别表示沿电流方向上导体截面的宽度和高度；$n$ 表示单位体积的载流子数；<br>【载流子种类】</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}p\ (positive)\ \ \ 型半导体\Rightarrow 空穴\Rightarrow 空穴导电\\n\ (negative)\ 型半导体\Rightarrow 电子\Rightarrow 电子导电\\
金属导体(大多数)\Rightarrow电子\Rightarrow电子导电\end{array}\right.</script><h3 id="第七讲-磁介质"><a href="#第七讲-磁介质" class="headerlink" title="第七讲 磁介质"></a>第七讲 磁介质</h3><h4 id="7-1-相对磁导率"><a href="#7-1-相对磁导率" class="headerlink" title="7.1 相对磁导率"></a>7.1 相对磁导率</h4><script type="math/tex; mode=display">
\mu_r = \frac{B}{B_0}\tag{24}</script><p>式中，$B_0$ 表示真空磁感应强度，$\mu_r$ 表示磁介质的相对磁导率，$B$ 表示磁介质的磁感应强度；     </p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}\mu_r > 1\Rightarrow 顺磁质\ (弱/非磁性物质)\\ \mu_r<1\Rightarrow 抗磁质\ (弱/非磁性物质)
\\\mu_r\gg 1 \Rightarrow 铁磁质\ (强磁性物质)\end{array}\right.</script><h4 id="7-2-bigstar-磁介质的安培环路定理"><a href="#7-2-bigstar-磁介质的安培环路定理" class="headerlink" title="7.2 $\bigstar$ 磁介质的安培环路定理"></a>7.2 $\bigstar$ 磁介质的安培环路定理</h4><script type="math/tex; mode=display">
\oint_L\boldsymbol{B}\cdot d\boldsymbol{l} = \mu_0\mu_r\sum_{(内)}I\\
令\mu = \mu_0\mu_r\Rightarrow \oint_L \frac{\boldsymbol{B}}{\mu}\cdot d\boldsymbol{l}=\sum_{(内)}I\\
令\boldsymbol{H} = \frac{\boldsymbol{B}}{\mu}
\Rightarrow\oint_L\boldsymbol{H}\cdot d\boldsymbol{l}=\sum_{(内)}I\tag{25}</script><p>式中，$\mu$ 表示磁介质的磁导率，$\boldsymbol{H}$ 表示磁场强度，对有介质存在的环路定理的处理可以参考电位移矢量 $\boldsymbol{D}$；     </p>
<h3 id="第八讲-经典习题"><a href="#第八讲-经典习题" class="headerlink" title="第八讲 经典习题"></a>第八讲 经典习题</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211031442409.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211031443235.png" style="zoom:101.5%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211031455520.png" style="zoom:90.1%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211031657183.png" style="zoom:90.1%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211031658555.png" style="zoom:90.1%;" /></p>
<h2 id="第三章-电磁感应与电磁场"><a href="#第三章-电磁感应与电磁场" class="headerlink" title="第三章 电磁感应与电磁场"></a>第三章 电磁感应与电磁场</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture202211021159420.jpg" alt="xcHROS.md.jpg" style="zoom:200%;" /></p>
<h3 id="第一讲-电磁感应的基本规律"><a href="#第一讲-电磁感应的基本规律" class="headerlink" title="第一讲 电磁感应的基本规律"></a>第一讲 电磁感应的基本规律</h3><h4 id="1-1-电动势"><a href="#1-1-电动势" class="headerlink" title="1.1 电动势"></a>1.1 电动势</h4><p>闭合回路上：</p>
<script type="math/tex; mode=display">
\xi = \oint\boldsymbol{E}_k\cdot d\boldsymbol{l}\tag{1}</script><p>对于一段电路$ab$：</p>
<script type="math/tex; mode=display">
\xi = \int_a^b\boldsymbol{E}_k\cdot d\boldsymbol{l}\tag{2}</script><p>其中，$\boldsymbol{E}_k$表示非静电性电场强度；    </p>
<h4 id="1-2-法拉第电磁感应定律"><a href="#1-2-法拉第电磁感应定律" class="headerlink" title="1.2 法拉第电磁感应定律"></a>1.2 法拉第电磁感应定律</h4><script type="math/tex; mode=display">
\xi_i=-\frac{d\Phi}{dt}\tag{3}</script><p>由楞次定律确定方向$\Rightarrow$方向相反；    </p>
<h4 id="1-3-多匝串联线圈"><a href="#1-3-多匝串联线圈" class="headerlink" title="1.3 多匝串联线圈"></a>1.3 多匝串联线圈</h4><script type="math/tex; mode=display">
\xi_i=-\frac{d}{dt}(\sum_{k=1}^N\Phi_k)=-\frac{d\Psi}{dt}\tag{4}</script><script type="math/tex; mode=display">
\xi_i=-\frac{d\Psi}{dt}=-N\frac{d\Phi}{dt}(\Phi_i=\Phi_j, 1 \leq i,j \leq N)\tag{5}</script><p>其中，$\Psi=\sum_{k=1}^N\Phi_k$表示穿过各线圈的总磁通量，称为磁通链数；</p>
<h4 id="1-4-长直螺线管"><a href="#1-4-长直螺线管" class="headerlink" title="1.4 长直螺线管"></a>1.4 长直螺线管</h4><p>在长直螺线管外套一 $N$ 匝，总内阻为 $R$ 的圆线圈，$S$ 表示螺线管截面积：</p>
<script type="math/tex; mode=display">
B=\mu_0nI\Rightarrow \Phi = \boldsymbol{B}\cdot\boldsymbol{S}=\mu_0nIS\\
当通电电流均匀变化时，螺线管内的感应电动势\\
\xi_i=-\frac{d\Psi}{dt}=-N\frac{d\Phi}{dt}=-\mu_0nNS\frac{dI}{dt}\\</script><p>【螺线管内磁感应强度】</p>
<script type="math/tex; mode=display">
感应电流\ I_i=\frac{\xi_i}{R}=-\frac{N}{R}\frac{d\Phi}{dt}\\
\Delta_{q_i}=\int_{t_1}^{t_2}I_idt=-\frac{N}{R}\int_{\Phi_1}^{\Phi_2}d\Phi=-\frac{N}{R}(\Phi_2-\Phi_1)\\
\Longrightarrow \Phi_1-\Phi_2=\frac{\Delta_{q_i}R}{N}\\
当 \Phi_1=0\vert_{t=t_1},\Phi_2=BS\vert_{t=t_2\rightarrow+\infty} 时，\Rightarrow B=\frac{\Delta_{q_i}R}{NS}</script><h3 id="第二讲-动生电动势-感生电动势"><a href="#第二讲-动生电动势-感生电动势" class="headerlink" title="第二讲 动生电动势 感生电动势"></a>第二讲 动生电动势 感生电动势</h3><h4 id="2-1-动生电动势"><a href="#2-1-动生电动势" class="headerlink" title="2.1 动生电动势"></a>2.1 动生电动势</h4><p>导体棒 $ab$ 产生的动生电动势：</p>
<script type="math/tex; mode=display">
\xi_i=\int_a^b\boldsymbol{E}_k\cdot d\boldsymbol{l}=\int_a^b(\boldsymbol{v}\times\boldsymbol{B})\cdot d\boldsymbol{l}\tag{6}</script><p>闭合回路产生的动生电动势：</p>
<script type="math/tex; mode=display">
\xi_i=\oint_Ld\xi_i=\oint_L(\boldsymbol{v}\times\boldsymbol{B})\cdot d\boldsymbol{l}\tag{7}</script><p>动生电动势方向由 $\boldsymbol{v}\times\boldsymbol{B}\cdot d\boldsymbol{l}$ 判定：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ccc}\xi_i>0\Rightarrow u_a<u_b\\
\xi_i<0\Rightarrow u_a>u_b\end{array}\right.\tag{8}</script><p>注：积分路径：$a\rightarrow b$，在电源内部非静电性电场强度从负极指向正极， $\boldsymbol{E}_k$ 与积分方向一致时积分值为正，否则为负；</p>
<h4 id="2-2-感生电动势"><a href="#2-2-感生电动势" class="headerlink" title="2.2 感生电动势"></a>2.2 感生电动势</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$感生电场假说 \Rightarrow有旋电场$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>【回路固定不动】</p>
<script type="math/tex; mode=display">
\xi_i=\oint_L\boldsymbol{E}_V\cdot d\boldsymbol{l}=-\iint_S\frac{\partial \boldsymbol{B}}{\partial t}\cdot d\boldsymbol{S}\tag{9}</script><p>感生电动势方向由楞次定律判定；有旋电场度 $E_V$ 的方向判定：闭合回路由右螺旋法则指向磁场方向选定回路绕行正方向，由式 $(9)$ 代入符号计算，$E_V$ 正负与回路绕行方向保持一致；<br>当 $E_V$ 相等，磁场均匀变化时，</p>
<script type="math/tex; mode=display">
\xi_i=E_V\oint_Ldl=-\frac{\partial{B}}{\partial{t}}\iint_SdS=-\frac{\partial{B}}{\partial{t}}S\tag{10}\\
\Longrightarrow\ 计算某一闭合回路上的有旋电场强度(\ S\ 表示磁场面积)</script><h3 id="第三讲-自感与互感"><a href="#第三讲-自感与互感" class="headerlink" title="第三讲 自感与互感"></a>第三讲 自感与互感</h3><h4 id="3-1-自感电动势"><a href="#3-1-自感电动势" class="headerlink" title="3.1 自感电动势"></a>3.1 自感电动势</h4><script type="math/tex; mode=display">
\Psi=LI\Rightarrow \xi_L=-\frac{d\Psi}{dt}=-L\frac{dI}{dt}\ \ (L为常量)\tag{11}</script><p>式中 $L$ 表示自感系数，与 $I$ 无关(存在铁磁质时与 $I$ 有关)，仅有回路的匝数、几何形状、大小以及周围介质磁导率决定；</p>
<h4 id="3-2-长直螺线管自感系数"><a href="#3-2-长直螺线管自感系数" class="headerlink" title="3.2 长直螺线管自感系数"></a>3.2 长直螺线管自感系数</h4><p>【空心自感线圈】</p>
<script type="math/tex; mode=display">
B = \mu_0nI=\mu_0\frac{N}{l}I\Rightarrow \Psi=NBS=\mu_0\frac{N^2}{l}\pi R^2I\\
\Longrightarrow L=\frac{\Psi}{I}=\frac{\mu_0N^2\pi R^2}{l}=\mu_0n^2V\ (V=\pi R^2l)\tag{12}</script><h4 id="3-3-传输线的分布电感"><a href="#3-3-传输线的分布电感" class="headerlink" title="3.3 传输线的分布电感"></a>3.3 传输线的分布电感</h4><p>两长直平行导线电流 $I$，半径 $r_0$，轴线间距 $d$，且 $r_0\leq d$；</p>
<script type="math/tex; mode=display">
导线微元:d\Phi_1=BdS=\frac{\mu_0I}{2\pi r}ldr\\
\Rightarrow \Phi_1=\int_{r_0}^{d-r_0}\frac{\mu_0Il}{2\pi}\frac{dr}{r}=\frac{\mu_0Il}{2\pi}\ln(\frac{d-r_0}{r_0})\\
\left\{\begin{array}{c}\Phi=\Phi_1+\Phi_2=2\Phi_1\ \ (电流反向)\\\Phi=\Phi_1+\Phi_2=0\ \ \ \ \ \ \ (电流同向)\end{array}\right.\\
L=\frac{\Phi}{I}=\frac{\mu_0}{\pi}l\ln(\frac{d-r_0}{r_0})\approx \frac{\mu_0}{\pi}l\ln\frac{d}{r_0}\ \ (电流反向)\tag{13}</script><h3 id="3-4-互感电动势"><a href="#3-4-互感电动势" class="headerlink" title="3.4 互感电动势"></a>3.4 互感电动势</h3><script type="math/tex; mode=display">
\left\{\begin{array}{c}\Psi_{21}=M_{21}I_1\ \ (回路1对回路2)\\\Psi_{12}=M_{12}I_2\ \ (回路2对回路1)\\M_{21}=M_{12}=M\end{array}\right.\\\Longrightarrow \xi_M=-M\frac{dI}{dt}\tag{14}</script><p>式中 $M_{21}$ 表示回路 $1$ 对回路 $2$ 的互感系数，$M_{12}$ 表示回路 $2$ 对回路 $1$ 的互感系数；$M$ 表示两个回路间的互感系数，与 $I$ 无关(存在铁磁质时与 $I$ 有关)，由回路的匝数、几何形状、尺寸、周围介质磁导率以及回路的相对位置决定；<br>|$M_{12}=M_{21}=M\Rightarrow 转换研究对象简化计算互感系数\Rightarrow 互感电动势$|<br>|:——:|</p>
<h3 id="第四讲-磁能"><a href="#第四讲-磁能" class="headerlink" title="第四讲 磁能"></a>第四讲 磁能</h3><h4 id="4-1-自感磁能"><a href="#4-1-自感磁能" class="headerlink" title="4.1 自感磁能"></a>4.1 自感磁能</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}dA=-\xi_Lidt\\\xi_L=-L\frac{di}{dt}\end{array}\right.\Rightarrow dA=Lidi\\
\Longrightarrow A=\int_0^ILidi=\frac{1}{2}LI^2\tag{15}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$即     W_m=\frac{1}{2}LI^2        (自感磁能)   $</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>式中，$L$ 表示线圈自感，$I$ 表示线圈所通电流；</p>
<h4 id="4-2-长直螺线管磁能"><a href="#4-2-长直螺线管磁能" class="headerlink" title="4.2 长直螺线管磁能"></a>4.2 长直螺线管磁能</h4><script type="math/tex; mode=display">
由式(12)\Rightarrow L=\mu n^2V\Rightarrow W_m=\frac{1}{2}LI^2=\frac{1}{2}\mu n^2I^2V\\
B=\mu nI\Longrightarrow H=\frac{B}{\mu}=nI\tag{16}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$W_m=\frac{1}{2}BHV$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$磁能密度       \omega_m=\frac{W_m}{V}=\frac{1}{2}BH$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-3-有限体积内的磁能"><a href="#4-3-有限体积内的磁能" class="headerlink" title="4.3 有限体积内的磁能"></a>4.3 有限体积内的磁能</h4><script type="math/tex; mode=display">
W_m=\int_VdW_m=\frac{1}{2}\int_VBHdV\tag{17}</script><h3 id="第五讲-麦克斯韦电磁场理论"><a href="#第五讲-麦克斯韦电磁场理论" class="headerlink" title="第五讲 麦克斯韦电磁场理论"></a>第五讲 麦克斯韦电磁场理论</h3><h4 id="5-1-位移电流"><a href="#5-1-位移电流" class="headerlink" title="5.1 位移电流"></a>5.1 位移电流</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}传导电流\Leftarrow 电荷定向移动形成的电流\\位移电流\Leftarrow 电位移通量的变化率(变化的电场)\end{array}\right.\\
\Phi_D=DS=\varepsilon ES=\varepsilon\cdot\frac{\sigma}{\varepsilon}S=\sigma S\\
\Longrightarrow \frac{d\Phi}{dt}=\frac{d}{dt}(\sigma S)=\frac{dq}{dt}=I\ (传导电流)\tag{18}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\Longrightarrow I_D = \frac{d\Phi_D}{dt}=\frac{dD}{dt}S=\varepsilon\frac{dE}{dt}S (位移电流)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\Longrightarrow 全电流 = I+I_D$</td>
</tr>
<tr>
<td style="text-align:center">非恒定电路中传导电流不连续但全电流保持连续</td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-2-全电流安培环路定理"><a href="#5-2-全电流安培环路定理" class="headerlink" title="5.2 全电流安培环路定理"></a>5.2 全电流安培环路定理</h4><script type="math/tex; mode=display">
\oint_L\boldsymbol{H}\cdot d\boldsymbol{l}=I+I_D\tag{19}</script><h4 id="5-3-麦克斯韦方程组"><a href="#5-3-麦克斯韦方程组" class="headerlink" title="5.3 麦克斯韦方程组"></a>5.3 麦克斯韦方程组</h4><script type="math/tex; mode=display">
电场\boldsymbol{E}、\boldsymbol{D}=\left\{\begin{array}{c}自由电荷产生的静电场\boldsymbol{E_1}、\boldsymbol{D_1}\\
变化磁场产生的有旋电场\boldsymbol{E_2}、\boldsymbol{D_2}\end{array}\right.\Rightarrow \left\{\begin{array}{c}\boldsymbol{E}=\boldsymbol{E_1}+\boldsymbol{E_2}\\
\boldsymbol{D}=\boldsymbol{D_1}+\boldsymbol{D_2}\end{array}\right.\\
磁场\boldsymbol{B}、\boldsymbol{H}=\left\{\begin{array}{c}传导电流产生的磁场\boldsymbol{B_1}、\boldsymbol{H_1}\\
位移电流产生的磁场\boldsymbol{B_2}、\boldsymbol{H_2}\end{array}\right.\Rightarrow \left\{\begin{array}{c}\boldsymbol{B}=\boldsymbol{B_1}+\boldsymbol{B_2}\\
\boldsymbol{H}=\boldsymbol{H_1}+\boldsymbol{H_2}\end{array}\right.\tag{20}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电场的高斯定理</th>
<th style="text-align:center">$\oint_S\boldsymbol{D}\cdot d\boldsymbol{S}=\sum_iq_i$</th>
<th style="text-align:center">电场是有源场</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">法拉第电磁感应定律</td>
<td style="text-align:center">$\oint_L\boldsymbol{E}\cdot d\boldsymbol{l}=-\iint_S\frac{\partial{\boldsymbol{B}}}{\partial{t}}\cdot d\boldsymbol{S}$</td>
<td style="text-align:center">静电场是保守(无旋、有势)场</td>
</tr>
<tr>
<td style="text-align:center">磁场的高斯定理</td>
<td style="text-align:center">$\oint_S\boldsymbol{B}\cdot d\boldsymbol{S}=0$</td>
<td style="text-align:center">磁场是无源场</td>
</tr>
<tr>
<td style="text-align:center">全电流安培环路定理</td>
<td style="text-align:center">$\oint_L\boldsymbol{H}\cdot d\boldsymbol{l}=\sum(I_D+I)$</td>
<td style="text-align:center">磁场是有旋(非保守)场</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第六讲-经典习题"><a href="#第六讲-经典习题" class="headerlink" title="第六讲 经典习题"></a>第六讲 经典习题</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051212846.png" style="zoom:85.1%;" /><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img202211051213867.png" alt=""></p>
<h2 id="第四章-狭义相对论力学基础"><a href="#第四章-狭义相对论力学基础" class="headerlink" title="第四章 狭义相对论力学基础"></a>第四章 狭义相对论力学基础</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture202211021156442.png" alt=""></p>
<h3 id="第一讲-力学相对性原理"><a href="#第一讲-力学相对性原理" class="headerlink" title="第一讲 力学相对性原理"></a>第一讲 力学相对性原理</h3><h4 id="1-1-经典力学相对性原理"><a href="#1-1-经典力学相对性原理" class="headerlink" title="1.1 经典力学相对性原理"></a>1.1 经典力学相对性原理</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">力学相对性原理</th>
<th style="text-align:center">$\left\{\begin{array}{c}对于描述力学现象的规律而言，所有惯性系都是等价的\\力学规律的数学表达式应具有伽利略坐标变换的不变性(协变性)\end{array}\right.$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-2-伽利略坐标变化式"><a href="#1-2-伽利略坐标变化式" class="headerlink" title="1.2 伽利略坐标变化式"></a>1.2 伽利略坐标变化式</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}\lambda_{PS'}+\lambda_{S'S}=\lambda_{PS}\Longrightarrow \lambda' = \lambda-\mu t\ \ (\lambda=x,y,z,\boldsymbol{v},\boldsymbol{a},\mu=u)\\t'=t\end{array}\right.\tag{1}</script><h3 id="第二讲-狭义相对论基本假设"><a href="#第二讲-狭义相对论基本假设" class="headerlink" title="第二讲 狭义相对论基本假设"></a>第二讲 狭义相对论基本假设</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">狭义相对论的相对性原理</th>
<th style="text-align:center">$\left\{\begin{array}{c}在所有惯性系中，一切物理学定理都相同，即具有相同的数学表达式\\对于描述一切物理现象的规律而言，所有惯性系都是等价的\end{array}\right.$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">光速不变原理</td>
<td style="text-align:center">$在所有惯性系中，真空中光沿各个方向传播的速率都等于同一个恒量 c，与光源和观察者的运动状态无关$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三讲-狭义相对论的时空观"><a href="#第三讲-狭义相对论的时空观" class="headerlink" title="第三讲 狭义相对论的时空观"></a>第三讲 狭义相对论的时空观</h3><h4 id="3-1-同时性的相对性"><a href="#3-1-同时性的相对性" class="headerlink" title="3.1 同时性的相对性"></a>3.1 同时性的相对性</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}异地发生的两个同时事件，同时性具有相对性(对任意参考系)\\
同地发生的两个同时事件，同时性具有绝对性(对任意参考系)\end{array}\right.</script><h4 id="3-2-时间延缓"><a href="#3-2-时间延缓" class="headerlink" title="3.2 时间延缓"></a>3.2 时间延缓</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间间隔具有相对性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\tau=\frac{\tau_0}{\sqrt{1-(\frac{u}{c})^2}}=\gamma\tau_0\tag{2}</script><p>式中，$\gamma = \frac{1}{\sqrt{1-(\frac{u}{c})^2}}$，$\tau_0$ 表示同地不同时的两事件的时间间隔称为原时，且在不同参考系中测得的时间间隔以原时最短；</p>
<h4 id="3-3-长度收缩"><a href="#3-3-长度收缩" class="headerlink" title="3.3 长度收缩"></a>3.3 长度收缩</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">长度测量具有相对性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
L'=L\sqrt{1-(\frac{u}{c})^2}\tag{3}</script><p>式中，$L$ 表示观测者静止时测得的长度(原长)，$L’$ 表示在沿尺长度方向运动速度为 $u$ 时测得的长度，且在不同参考系中测得的长度以原长最长；</p>
<h3 id="第四讲-洛伦兹变换"><a href="#第四讲-洛伦兹变换" class="headerlink" title="第四讲 洛伦兹变换"></a>第四讲 洛伦兹变换</h3><h4 id="4-1-时空坐标变换"><a href="#4-1-时空坐标变换" class="headerlink" title="4.1 时空坐标变换"></a>4.1 时空坐标变换</h4><script type="math/tex; mode=display">
P在S中的时空坐标(x,y,z,t),在S'中的时空坐标(x',y',z',t')\\
S系中测得S'中坐标x''= x'\sqrt{1-(\frac{u}{c})^2}\ \ \ (长度收缩)\\
\Longrightarrow 在S系中P坐标 x = ut + x''=ut+x'\sqrt{1-(\frac{u}{c})^2}\\
S'系中测得S中坐标x_1= x\sqrt{1-(\frac{u}{c})^2}\ \ \ (长度收缩)\\
\Longrightarrow 在S'系中P坐标 x' = x_1 -ut' = x\sqrt{1-(\frac{u}{c})^2} - ut'\\
\Longrightarrow x' = \frac{x-ut}{\sqrt{1-(\frac{u}{c})^2}},t' = \frac{t-\frac{u}{c^2}x}{\sqrt{1-(\frac{u}{c})^2}}\tag{4}</script><p>式中，$u$ 表示 $S’$ 相对于 $S$ 的速度(相对速度)，$x’$ 表示待求坐标系中参量；<br>推导时间变换式</p>
<script type="math/tex; mode=display">
由x' = \frac{x-ut}{\sqrt{1-(\frac{u}{c})^2}}及逆变换x = \frac{x'+ut'}{\sqrt{1-(\frac{u}{c})^2}}联立消去x'解t'</script><h4 id="4-2-时空间隔变换"><a href="#4-2-时空间隔变换" class="headerlink" title="4.2 时空间隔变换"></a>4.2 时空间隔变换</h4><script type="math/tex; mode=display">
P_1,P_2在S中的时空坐标(x_1,y_1,z_1,t_1),(x_2,y_2,z_2,t_2),在S'中的时空坐标(x_1',y_1',z_1',t_1'),(x_2',y_2',z_2',t_2')\\
由S\rightarrow S'\\
\Delta t'=\frac{\Delta t-\frac{u}{c^2}\Delta x}{\sqrt{1-\beta^2}},\Delta x'=\frac{\Delta x-u\Delta t}{\sqrt{1-\beta^2}}\ (\beta = \frac{u}{c})\\
由S'\rightarrow S\\
\Delta t=\frac{\Delta t'+\frac{u}{c^2}\Delta x'}{\sqrt{1-\beta^2}},\Delta x=\frac{\Delta x'+u\Delta t'}{\sqrt{1-\beta^2}}\ (\beta = \frac{u}{c})\tag{5}</script><p>式中，$u$ 关联于坐标轴选取的正方向，一般选定 $S$ 系运动方向为坐标轴正方向；</p>
<h4 id="4-3-爱因斯坦速度相加定律"><a href="#4-3-爱因斯坦速度相加定律" class="headerlink" title="4.3 爱因斯坦速度相加定律"></a>4.3 爱因斯坦速度相加定律</h4><script type="math/tex; mode=display">
由式(4)求微分\Rightarrow\left\{\begin{array}{c}dx'=\frac{(v_x-u)}{\sqrt{1-\beta^2}}dt\\dy'= dy\\dz'= dz\\dt' = \frac{(1-\frac{u}{c^2}v_x)}{\sqrt{1-\beta^2}}dt\end{array}\right.\\
\Rightarrow v_x'=\frac{dx'}{dt'}=\frac{v_x-u}{1-\frac{u}{c^2}v_x}\\
\Rightarrow v_y'=\frac{dy'}{dt'}=\frac{v_y\sqrt{1-\beta^2}}{1-\frac{u}{c^2}v_x}\\
\Rightarrow v_z'=\frac{dz'}{dt'}=\frac{v_z\sqrt{1-\beta^2}}{1-\frac{u}{c^2}v_x}\tag{6}</script><h3 id="第五讲-狭义相对论质点动力学"><a href="#第五讲-狭义相对论质点动力学" class="headerlink" title="第五讲 狭义相对论质点动力学"></a>第五讲 狭义相对论质点动力学</h3><h4 id="5-1-相对论动量和质量"><a href="#5-1-相对论动量和质量" class="headerlink" title="5.1 相对论动量和质量"></a>5.1 相对论动量和质量</h4><script type="math/tex; mode=display">
m(v) = \frac{m_0}{\sqrt{1-(\frac{u}{c})^2}}\ (质速关系式)\\
\Longrightarrow \boldsymbol{p}=m\boldsymbol{v}=\frac{m_0}{\sqrt{1-(\frac{u}{c})^2}}\boldsymbol{v}\\
\Longrightarrow \boldsymbol{F}=\frac{d\boldsymbol{p}}{dt}=\frac{d}{dt}(\frac{m_0}{\sqrt{1-(\frac{u}{c})^2}}\boldsymbol{v})\tag{7}</script><p>式中，$m_0$ 表示物体静止质量；</p>
<h4 id="5-2-相对论动能"><a href="#5-2-相对论动能" class="headerlink" title="5.2 相对论动能"></a>5.2 相对论动能</h4><script type="math/tex; mode=display">
E_k = \int \boldsymbol{F}\cdot d\boldsymbol{r}=\int \frac{d(m\boldsymbol{v})}{dt}\cdot d\boldsymbol{r}=\int d(m\boldsymbol{v})\cdot \frac{d\boldsymbol{r}}{dt}=\int d(m\boldsymbol{v})\cdot\boldsymbol{v}\\
m\propto\boldsymbol{v}\Longrightarrow d(m\boldsymbol{v})\cdot\boldsymbol{v}=(\boldsymbol{v}dm+md\boldsymbol{v})\cdot \boldsymbol{v}=v^2dm+mvdv\\
式(7)\Rightarrow m^2v^2=m^2c^2-m_0^2c^2\Rightarrow v^2dm+mvdv=c^2dm\\
E_k=\int_{m_0}^mc^2dm=mc^2-m_0c^2\tag{8}</script><h4 id="5-3-质能方程"><a href="#5-3-质能方程" class="headerlink" title="5.3 质能方程"></a>5.3 质能方程</h4><script type="math/tex; mode=display">
\left\{\begin{array}{c}E=mc^2\ \ (运动能量)\\
E_0=m_0c^2\ \ (静止能量)\end{array}\right.\tag{9}</script><h4 id="5-4-光子质量"><a href="#5-4-光子质量" class="headerlink" title="5.4 光子质量"></a>5.4 光子质量</h4><script type="math/tex; mode=display">
光子能量 E= h\nu\ \ (爱因斯坦光子假说)\\
\Longrightarrow m_\varphi=\frac{E}{c^2}=\frac{h\nu}{c^2}=\frac{h}{c\lambda}\tag{10}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">光子、中微子在真空中速率为 $c$，不可能静止因此静止能量等于零</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-5-相对论能量与动量关系"><a href="#5-5-相对论能量与动量关系" class="headerlink" title="5.5 相对论能量与动量关系"></a>5.5 相对论能量与动量关系</h4><script type="math/tex; mode=display">
式(7)\Rightarrow m^2(1-\frac{v^2}{c^2})=m_0^2\\
\Longrightarrow m^2c^4=m^2v^2c^2+m_0^2c^4\\
p=mv\Rightarrow E^2=p^2c^2+E_0^2\\
光子\ \ m_0=0\Rightarrow E_0=0\Rightarrow E^2=p^2c^2\\
\Longrightarrow p=\frac{h\nu}{c}=\frac{h}{\lambda}\tag{11}</script><h2 id="第五章-量子物理基础"><a href="#第五章-量子物理基础" class="headerlink" title="第五章 量子物理基础"></a>第五章 量子物理基础</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture202211021216245.jpg" style="zoom:190%;" /></p>
<h3 id="第一讲-普朗克量子假设"><a href="#第一讲-普朗克量子假设" class="headerlink" title="第一讲 普朗克量子假设"></a>第一讲 普朗克量子假设</h3><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">热辐射</th>
<th style="text-align:center">物体由其温度所决定的电磁辐射(温度越高，单位时间内辐射的能量越高)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">平衡热辐射</td>
<td style="text-align:center">当辐射和吸收达到平衡时，物体的温度不再发生变化而处于热平衡状态时的热辐射</td>
</tr>
<tr>
<td style="text-align:center">单色辐射出射度(单色辐出度)</td>
<td style="text-align:center">物体单位表面积在单位时间内发射的，波长在 $\lambda\rightarrow\lambda+d\lambda$ 范围内的辐射能 $dM_\lambda$与波长间隔 $d\lambda$ 的比值</td>
</tr>
<tr>
<td style="text-align:center">绝对黑体(黑体)</td>
<td style="text-align:center">能够全部吸收各种波长的辐射能而不发生发射和透射的物体</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-2-单色辐出度"><a href="#1-2-单色辐出度" class="headerlink" title="1.2 单色辐出度"></a>1.2 单色辐出度</h4><script type="math/tex; mode=display">
M_\lambda(T)=\frac{dM_\lambda}{d\lambda}\tag{1}</script><p>【单色辐出度图】<br>|温度越高|单色辐出度越大，峰值波长越短|<br>|:——-:|:——-:|</p>
<h4 id="1-3-普朗克量子假设"><a href="#1-3-普朗克量子假设" class="headerlink" title="1.3 普朗克量子假设"></a>1.3 普朗克量子假设</h4><script type="math/tex; mode=display">
\varepsilon=nh\nu\tag{2}</script><p>式中，$\varepsilon$ 表示腔壁中带电谐振子离散变化的能量，振子的频率为 $\nu$，$n$ 表示量子数，$h\nu$ 表示能量子——谐振子能量的最小单位(不是物质而是能量单位)；</p>
<h3 id="第二讲-爱因斯坦光子理论"><a href="#第二讲-爱因斯坦光子理论" class="headerlink" title="第二讲 爱因斯坦光子理论"></a>第二讲 爱因斯坦光子理论</h3><h4 id="2-1-光电效应"><a href="#2-1-光电效应" class="headerlink" title="2.1 光电效应"></a>2.1 光电效应</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">金属及其化合物在光的照射下发射电子的现象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>【光电效应伏安特性曲线】<br>|照射光光强越大，饱和光电流越大|<br>|:——:|<br>|光电子最大初动能与照射光强度无关，而与频率成线性关系|</p>
<h4 id="2-2-光电效应方程"><a href="#2-2-光电效应方程" class="headerlink" title="2.2 光电效应方程"></a>2.2 光电效应方程</h4><script type="math/tex; mode=display">
\frac{1}{2}mv_m^2=eU_a\ (遏止电压)\\
h\nu = A + \frac{1}{2}mv_m^2\ \ (光电效应方程)\\
\nu_0=\frac{A}{h}\ (截止频率)\\
\Longrightarrow U_a = \frac{h}{e}\nu-\frac{A}{e}\tag{3}</script><h3 id="第三讲-康普顿效应及光子理论解释"><a href="#第三讲-康普顿效应及光子理论解释" class="headerlink" title="第三讲 康普顿效应及光子理论解释"></a>第三讲 康普顿效应及光子理论解释</h3><h4 id="3-1-康普顿效应"><a href="#3-1-康普顿效应" class="headerlink" title="3.1 康普顿效应"></a>3.1 康普顿效应</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">单色 $X$ 射线被物质散射时，散射光两种波长中有一种波长比入射线长的散射现象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-光子理论解释"><a href="#3-2-光子理论解释" class="headerlink" title="3.2 光子理论解释"></a>3.2 光子理论解释</h4><p>【微观机制】——等价于微观粒子的弹性碰撞</p>
<script type="math/tex; mode=display">
入射光子频率\nu_0,散射角为\theta的光子频率为\nu,电子沿着与入射线成\varphi角的方向运动,静质量m_0,动质量m\\
动量守恒定律\ \ \ \ \left\{\begin{array}{c}\frac{h\nu_0}{c}=\frac{h\nu}{c}\cos\theta+mv\cos\varphi\\
\frac{h\nu}{c}\sin\theta=mv\sin\varphi\end{array}\right.\\
\Longrightarrow m^2v^2c^2=h^2(\nu_0^2-\nu^2-2\nu_0\nu\cos\theta)\tag{4}</script><script type="math/tex; mode=display">
能量守恒定律\ \ \ \ \ \ \ \ \ \ \ hv_0+m_0c^2=hv+mc^2\tag{5}\\
\left\{\begin{array}{c}式(5)平方-式(4)\\m^2(1-\frac{v^2}{c^2})=m_0^2\end{array}\right.\Longrightarrow m_0c^2(\nu_0-\nu)=h\nu_0\nu(1-\cos\theta)</script><script type="math/tex; mode=display">
\Longrightarrow \Delta\lambda = \lambda - \lambda_0=\frac{c}{\nu}-\frac{c}{\nu_0}=\frac{h}{m_0c}(1-\cos\theta)>0\\
=\frac{2h}{m_0c}\sin^2\frac{\theta}{2}=2\lambda_C\sin^2\frac{\theta}{2}\tag{6}</script><p>式中，$\lambda_C=\frac{h}{m_0c}$ 称为电子的康普顿波长；</p>
]]></content>
      <categories>
        <category>大学物理</category>
      </categories>
      <tags>
        <tag>大物</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2022/12/10/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>本文主要分享学习堆排序算法<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Status bool</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KeyType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InfoType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LT(x, y) (x&lt;y?1:0)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    KeyType key;         <span class="hljs-comment">//关键字类型</span><br>    InfoType info;       <span class="hljs-comment">// 数据项</span><br>&#125;ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType r[MAXSIZE+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;            <span class="hljs-comment">// 顺序表类型</span><br><span class="hljs-keyword">typedef</span> SqList HeapType;    <span class="hljs-comment">// 堆类型</span><br><br><span class="hljs-function">Status <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(HeapType &amp;H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">HeapSort</span><span class="hljs-params">(HeapType &amp;H)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    HeapType H;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the length of the sequence:\n&quot;</span>;<br>    cin &gt;&gt; H.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=H.length;i++)<br>        cin &gt;&gt; H.r[i].key;<br>    <span class="hljs-built_in">HeapSort</span>(H);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After Heap Sorting output the sequence:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=H.length;i++)<br>        cout &lt;&lt; H.r[i].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(HeapType &amp;H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 除H.r[s].key之外其余元素均满足堆的定义</span><br>    <span class="hljs-comment">// 本函数调整H.r[s]的关键字使得H.r[s...m]成为一个大顶堆</span><br>    ElemType rc = H.r[s];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>*s;j&lt;=m;j*=<span class="hljs-number">2</span>)&#123;    <span class="hljs-comment">// 沿key较大的孩子节点向下筛选</span><br>        <span class="hljs-comment">//下句主要从s的孩子节点中挑选最大值，j为其下标</span><br>        <span class="hljs-comment">//判定j&lt;m因为当只有一个孩子即左孩子时不需移动 j</span><br>        <span class="hljs-keyword">if</span>(j&lt;m &amp;&amp; <span class="hljs-built_in">LT</span>(H.r[j].key, H.r[j+<span class="hljs-number">1</span>].key)) j++;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LT</span>(rc.key, H.r[j].key)) <span class="hljs-keyword">break</span>;    <br>        H.r[s] = H.r[j];   <span class="hljs-comment">// 更新较大值（向上传递）</span><br>        s = j;    <span class="hljs-comment">// 沿较大孩子所在子树向下筛选</span><br>    &#125;<br>    H.r[s] = rc;   <span class="hljs-comment">// 最终定位</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">HeapSort</span><span class="hljs-params">(HeapType &amp;H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对顺序表H进行堆排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=H.length/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;--i)  <span class="hljs-comment">// 初始对所有元素建立大顶堆</span><br>        <span class="hljs-built_in">HeapAdjust</span>(H, i, H.length);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=H.length;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>        ElemType temp = H.r[<span class="hljs-number">1</span>];   <span class="hljs-comment">// 每次最大值在堆顶H.r[1]</span><br>        H.r[<span class="hljs-number">1</span>] = H.r[i];          <span class="hljs-comment">// 每次和最后一个元素交换即输出元素后最后一个元素上堆顶</span><br>        H.r[i] = temp;<br>        <span class="hljs-built_in">HeapAdjust</span>(H, <span class="hljs-number">1</span>, i<span class="hljs-number">-1</span>);   <span class="hljs-comment">// 重新调整</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<blockquote>
<p>给出一个算例演示</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the length of the sequence:</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">49 38 65 97 76 13 27 49</span><br><span class="hljs-comment">After Heap Sorting output the sequence:</span><br><span class="hljs-comment">13 27 38 49 49 65 76 97 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>导数的综合应用</title>
    <url>/2022/10/20/%E5%AF%BC%E6%95%B0%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="第七讲、导数的综合应用"><a href="#第七讲、导数的综合应用" class="headerlink" title="第七讲、导数的综合应用"></a>第七讲、导数的综合应用</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210231137608.png" alt=""><br>注解：式中</p>
<script type="math/tex; mode=display">
\frac{\partial(F,G)}{\partial(y,z)}=\left|\begin{array}{c}F_y & F_z\\G_y & G_z \end{array}\right|</script><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210231146576.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210231151279.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210231426722.png" alt=""></p>
<h3 id="七、典型例题"><a href="#七、典型例题" class="headerlink" title="七、典型例题"></a>七、典型例题</h3><h4 id="7-1-方程实根的讨论"><a href="#7-1-方程实根的讨论" class="headerlink" title="7.1 方程实根的讨论"></a>7.1 方程实根的讨论</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210231444545.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210231445906.png" alt=""></p>
<h4 id="7-2-导数几何应用"><a href="#7-2-导数几何应用" class="headerlink" title="7.2 导数几何应用"></a>7.2 导数几何应用</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241134798.png" alt=""></p>
<h4 id="7-3-函数极值与最值"><a href="#7-3-函数极值与最值" class="headerlink" title="7.3 函数极值与最值"></a>7.3 函数极值与最值</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241204719.png" alt=""><br>注解：思路分析——将乘积项拆分为点积，进一步得到函数驻点<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241221501.png" alt=""><br>注解：注意求最值时改用参数方程的方法；<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241316108.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241318021.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241319430.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241319963.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241323639.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241324726.png" alt=""><br>注解：中值定理的使用，以及 $r = \sqrt{x^2+y^2}$ 的使用；<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241329909.png" alt=""></p>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程</title>
    <url>/2022/10/31/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="第十八讲、微分中值定理"><a href="#第十八讲、微分中值定理" class="headerlink" title="第十八讲、微分中值定理"></a>第十八讲、微分中值定理</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210311640205.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210311701345.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210311702067.png" alt=""></p>
<h3 id="十八、典型例题"><a href="#十八、典型例题" class="headerlink" title="十八、典型例题"></a>十八、典型例题</h3>]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/12/16/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="2-路归并排序"><a href="#2-路归并排序" class="headerlink" title="2-路归并排序"></a>2-路归并排序</h3><p>本文主要介绍学习2-路归并排序<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Status bool</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_num 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LT(x,y) (x&lt;y?1:0)</span><br><span class="hljs-comment">/*-------------2-路归并排序-------------*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> key;<br>&#125;RcdType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    RcdType r[Max_num];<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><span class="hljs-comment">//---------------非递归算法-------------</span><br><span class="hljs-function">Status <span class="hljs-title">NonCurMerge</span><span class="hljs-params">(SqList &amp;L)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">MergeSort</span><span class="hljs-params">(RcdType *SR, RcdType *TR, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-comment">//-----------------递归算法--------------</span><br><span class="hljs-function">Status <span class="hljs-title">CurMerge</span><span class="hljs-params">(SqList &amp;L)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">MSort</span><span class="hljs-params">(RcdType *SR, RcdType *TR, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SqList L1, L2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the length of sequence: &quot;</span>;<br>    cin &gt;&gt; L1.length;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the elements of the sequence:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=L1.length;i++)<br>        cin &gt;&gt; L1.r[i].key;<br>    L2 = L1;<br>    <span class="hljs-comment">//------- 非递归算法---------</span><br>    <span class="hljs-built_in">NonCurMerge</span>(L1);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Output the sequence with NonCurrSortAlgorithm:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=L1.length;i++)<br>        cout &lt;&lt; L1.r[i].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-comment">//--------递归算法------------</span><br>    <span class="hljs-built_in">CurMerge</span>(L2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Output the sequence with CurrSortAlgorithm:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=L2.length;i++)<br>        cout &lt;&lt; L2.r[i].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">NonCurMerge</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> delta = <span class="hljs-number">1</span>, n = L.length;<br>    SqList T;T.length = n;  <span class="hljs-comment">// 内存辅助空间</span><br>    <span class="hljs-keyword">while</span>(delta &lt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>*delta)&#123;<br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">2</span>*delta&gt;n) <span class="hljs-built_in">MergeSort</span>(L.r,T.r,i,i+delta<span class="hljs-number">-1</span>,n);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">MergeSort</span>(L.r,T.r,i,i+delta<span class="hljs-number">-1</span>,i+<span class="hljs-number">2</span>*delta<span class="hljs-number">-1</span>);<br>        &#125;<br>        L = T;    <span class="hljs-comment">// 赋值转换存储方向</span><br>        delta *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">MergeSort</span><span class="hljs-params">(RcdType *SR, RcdType *TR, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 有序表归并函数 SR[i...m]、SR[m+1...n]----&gt;TR[i...n]</span><br>    <span class="hljs-type">int</span> j = m+<span class="hljs-number">1</span>, k = i;<br>    <span class="hljs-keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=n)&#123;    <span class="hljs-comment">// 取最小值</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">LT</span>(SR[i].key, SR[j].key)) TR[k++] = SR[i++];<br>        <span class="hljs-keyword">else</span> TR[k++] = SR[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=m) TR[k++] = SR[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=n) TR[k++] = TR[j++];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// --------------递归算法-------------------</span><br><span class="hljs-function">Status <span class="hljs-title">CurMerge</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对顺序表进行归并排序</span><br>    <span class="hljs-built_in">MSort</span>(L.r, L.r, <span class="hljs-number">1</span>, L.length);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">MSort</span><span class="hljs-params">(RcdType *SR, RcdType *TR, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将SR[s..t]归并排序到TR[s...t] </span><br>    RcdType TRtemp[Max_num];   <span class="hljs-comment">// 内存辅助空间</span><br>    <span class="hljs-keyword">if</span>(s==t) TR[s] = SR[s];<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> m = (s + t)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">MSort</span>(SR, TRtemp, s, m);<br>        <span class="hljs-built_in">MSort</span>(SR, TRtemp, m+<span class="hljs-number">1</span>, t);<br>        <span class="hljs-built_in">MergeSort</span>(TRtemp, TR, s, m, t);  <br>    &#125;           <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br> &#125;           <br></code></pre></td></tr></table></figure></p>
<blockquote>
<p>给出一个算例演示</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the length of sequence: 10</span><br><span class="hljs-comment">Input the elements of the sequence:</span><br><span class="hljs-comment">9 8 7 6 5 4 3 2 1 0</span><br><span class="hljs-comment">Output the sequence with NonCurrSortAlgorithm:</span><br><span class="hljs-comment">0 1 2 3 4 5 6 7 8 9</span><br><span class="hljs-comment">Output the sequence with CurrSortAlgorithm:</span><br><span class="hljs-comment">0 1 2 3 4 5 6 7 8 9</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>微分中值定理</title>
    <url>/2022/10/16/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="第五讲、微分中值定理"><a href="#第五讲、微分中值定理" class="headerlink" title="第五讲、微分中值定理"></a>第五讲、微分中值定理</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210161916050.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210161921095.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210161925822.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210161926024.png" alt=""></p>
<h3 id="五、典型例题"><a href="#五、典型例题" class="headerlink" title="五、典型例题"></a>五、典型例题</h3><h4 id="5-1-中值定理极限讨论"><a href="#5-1-中值定理极限讨论" class="headerlink" title="5.1 中值定理极限讨论"></a>5.1 中值定理极限讨论</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210161949559.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210162053502.png" alt=""></p>
<h4 id="5-2-含一个中值的等式证明"><a href="#5-2-含一个中值的等式证明" class="headerlink" title="5.2 含一个中值的等式证明"></a>5.2 含一个中值的等式证明</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181840565.png" alt=""><br>注解：<strong>【罗尔定理】</strong>怎样由待证明等式构造函数，寻找两个零点；以及原函数与二阶导数同时存在时怎样利用一阶导数构造函数；    </p>
<p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181854544.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181854337.png" alt=""></p>
<p><strong>【一道经典题目】</strong>    </p>
<p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181910099.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181911586.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181912493.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181927169.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181927558.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181928459.png" alt=""><br>注解：泰勒公式运用以及两端点泰勒展开式作差，最值定理以及介值定理；   </p>
<p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181935473.png" alt=""><br>注解：整体思路和上一道题目类似，特别注意<strong>积分上限函数</strong>的运用以及连续导数；    </p>
<p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181943530.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181943811.png" alt=""><br>注解：怎样由<strong>三角函数</strong>结合待证明等式构造辅助函数，寻找两个零点；   </p>
<h4 id="5-3-含多个中值的等式证明"><a href="#5-3-含多个中值的等式证明" class="headerlink" title="5.3 含多个中值的等式证明"></a>5.3 含多个中值的等式证明</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210181958654.png" alt=""><br>注解：$F(x)$怎样构造的，借助$f(a+b-x)$巧妙地利用条件$f(a)=0$构造$F(b)=0$，以及构造$m、n$作为函数指数；     </p>
<p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182015730.png" alt=""><br>注解：这道题目准备工作很重要，设定$c = a/(a+b)$以及介值定理$f(\mu)=c$；     </p>
<p><strong>【同型题目】</strong><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182021005.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182021741.png" alt=""></p>
<p><strong>柯西中值定理</strong><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182030140.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182031770.png" alt=""></p>
<h4 id="5-4-含中值不等式的证明"><a href="#5-4-含中值不等式的证明" class="headerlink" title="5.4 含中值不等式的证明"></a>5.4 含中值不等式的证明</h4><p><strong>极限保号性</strong><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182040859.png" alt=""><br>注解：这一类题目注重拉格朗日中值定理的应用，因为通过$Lagrange$中值定理可以判断取值范围；       </p>
<p><strong>反证法</strong><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182053243.png" alt=""><br>注解：构造$x^\alpha G(x)$特别好，从不等式（导函数）中构造原函数；以及最后再次构造原函数，这道题目连续多次构造处理；      </p>
<h4 id="5-5-利用中值定理证明函数性质"><a href="#5-5-利用中值定理证明函数性质" class="headerlink" title="5.5 利用中值定理证明函数性质"></a>5.5 利用中值定理证明函数性质</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182104382.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182104890.png" alt=""><br>注解：此道题目对$f(x+\theta h)$的二阶导函数再次泰勒展开，以及在区$h-&gt; 0$特别好；    </p>
<p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182111905.png" alt=""><br>注解：在处理$g^`(x)=0$时，设定$g(x)$极限为$L$或无穷大；之后假设证明：求极限问题；<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182147647.png" alt=""><br>注解：带绝对值类的题目，对不等式而言尽可能放缩，注意其中二阶导数放缩不大于函数值与一阶导数值之和；    </p>
<p><strong>【拓展】</strong><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182151889.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210182151370.png" alt=""><br>注解：怎样求$f(x)$的导数，以及注意$f(0)$的导数需单独求解，另外对原函数等价于导数的积分处理进一步放缩特别好；</p>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2022/12/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>本文主要介绍快速排序以及基于三者取中法则的改进算法<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Status bool</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KeyType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InfoType int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    KeyType key;         <span class="hljs-comment">//关键字类型</span><br>    InfoType info;       <span class="hljs-comment">// 数据项</span><br>&#125;ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType r[MAXSIZE+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;            <span class="hljs-comment">// 顺序表类型</span><br><span class="hljs-comment">/*---------------快速排序---------------*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>;<br><span class="hljs-comment">// 利用三者取中法则改进</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AdvancedPartition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList &amp;L)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">QSort</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SqList L;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the length of sequence: &quot;</span>;<br>    cin &gt;&gt; L.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;<br>        cin &gt;&gt; L.r[i+<span class="hljs-number">1</span>].key;<br>    &#125;<br>    <span class="hljs-built_in">QuickSort</span>(L);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After quick sorting output the sequence:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;<br>        cout &lt;&lt; L.r[i+<span class="hljs-number">1</span>].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对顺序表做快速排序</span><br>    <span class="hljs-built_in">QSort</span>(L, <span class="hljs-number">1</span>, L.length);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">QSort</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;      <span class="hljs-comment">// 长度大于1</span><br>        <span class="hljs-type">int</span> piv = <span class="hljs-built_in">AdvancedPartition</span>(L, low, high);   <span class="hljs-comment">// 寻找枢轴位置</span><br>        <span class="hljs-comment">// 由于枢轴位置已到位，故跳过枢轴位，将序列一分为二，递归排序</span><br>        <span class="hljs-built_in">QSort</span>(L, low, piv<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">QSort</span>(L, piv+<span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 寻找枢轴函数，在low和high之间寻找枢轴，使枢轴记录到位，并返回其位置</span><br>    <span class="hljs-comment">// 使得枢轴之前(后)均不大于(小于)它</span><br>    L.r[<span class="hljs-number">0</span>] = L.r[low];     <span class="hljs-comment">// 暂存</span><br>    <span class="hljs-type">int</span> piv = L.r[low].key;   <span class="hljs-comment">// 子表的第一个记录当作枢轴</span><br>    <span class="hljs-keyword">while</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; L.r[high].key &gt;= piv) high--;<br>        L.r[low] = L.r[high];      <span class="hljs-comment">// 将记录移到低位</span><br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; L.r[low].key &lt;= piv) low++;<br>        L.r[high] = L.r[low];      <span class="hljs-comment">// 将记录移到高位</span><br>    &#125;<br>    L.r[low] = L.r[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 枢轴记录到位</span><br>    <span class="hljs-keyword">return</span> low;     <span class="hljs-comment">// 返回枢轴位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AdvancedPartition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用三者取中规则寻找枢轴函数</span><br>    <span class="hljs-type">int</span> piv = <span class="hljs-number">0</span>, inpiv = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 记录子表的枢轴,枢轴下标</span><br>    <span class="hljs-type">int</span> maxv = L.r[low].key &gt; L.r[high].key?low:high;<br>    <span class="hljs-type">int</span> minv = low + high - maxv;<br>    <span class="hljs-type">int</span> midv = (low+high)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(L.r[midv].key &lt; L.r[minv].key) inpiv = minv;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.r[midv].key &gt; L.r[maxv].key) inpiv = maxv;<br>    <span class="hljs-keyword">else</span> inpiv = midv;<br>    <span class="hljs-comment">// 进行转换</span><br>    L.r[<span class="hljs-number">0</span>] = L.r[inpiv];<br>    piv = L.r[inpiv].key;<br>    <span class="hljs-keyword">if</span>(inpiv != low) L.r[inpiv] = L.r[low];<br>    <span class="hljs-keyword">while</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; L.r[high].key &gt;= piv) high--;<br>        L.r[low] = L.r[high];      <span class="hljs-comment">// 将记录移到低位</span><br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; L.r[low].key &lt;= piv) low++;<br>        L.r[high] = L.r[low];      <span class="hljs-comment">// 将记录移到高位</span><br>    &#125;<br>    L.r[low] = L.r[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 枢轴记录到位</span><br>    <span class="hljs-keyword">return</span> low;     <span class="hljs-comment">// 返回枢轴位置</span><br>&#125;<br></code></pre></td></tr></table></figure><br>给出一个算例演示<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">//-------demo 1-------</span><br><span class="hljs-comment">Input the length of sequence: 10</span><br><span class="hljs-comment">1 2 3 4 5 6 7 8 9 10</span><br><span class="hljs-comment">After quick sorting output the sequence:</span><br><span class="hljs-comment">5 1 6 2 3 7 8 9 4 10</span><br><span class="hljs-comment">//-------demo 2--------</span><br><span class="hljs-comment">Input the length of sequence: 10</span><br><span class="hljs-comment">49 38 65 97 76 13 27 49 55 04</span><br><span class="hljs-comment">After quick sorting output the sequence:</span><br><span class="hljs-comment">4 13 27 38 49 49 55 65 76 97</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2022/11/02/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="一、拓扑排序"><a href="#一、拓扑排序" class="headerlink" title="一、拓扑排序"></a>一、拓扑排序</h3><h3 id="二、AOV网与AOE网"><a href="#二、AOV网与AOE网" class="headerlink" title="二、AOV网与AOE网"></a>二、<code>AOV</code>网与<code>AOE</code>网</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;ADL.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++) </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_Vertex_Num 20</span><br><span class="hljs-comment">//-------------------AOV-------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">FindInDegree</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> *indegree)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> *T, <span class="hljs-type">int</span> &amp;Ttop)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">CriticalPath</span><span class="hljs-params">(ALGraph G)</span></span>;<br><span class="hljs-type">int</span> ve[Max_Vertex_Num];    <span class="hljs-comment">// 顶点事件最早发生时间</span><br><span class="hljs-type">int</span> vl[Max_Vertex_Num];    <span class="hljs-comment">// 顶点事件最迟发生时间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ALGraph G, GR;<br>    <span class="hljs-built_in">CreateGraph</span>(G, GR);<br>    <span class="hljs-built_in">GraphPrint</span>(G, GR);<br>    <span class="hljs-built_in">CriticalPath</span>(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> *T, <span class="hljs-type">int</span> &amp;Ttop)</span></span><br><span class="hljs-function"></span>&#123;      <br>    <span class="hljs-comment">// 有向无环图的拓扑排序</span><br>    <span class="hljs-comment">//求各顶点时间的最早发生时间ve(全局变量)</span><br>    <span class="hljs-comment">//若G无回路，则用T返回G的一个拓扑序列，且函数返回OK，否则返回ERROR</span><br>    <span class="hljs-type">int</span> S[Max_Vertex_Num], Stop = <span class="hljs-number">-1</span>, i = <span class="hljs-number">0</span>;  <span class="hljs-comment">/*栈St的指针为top*/</span><br>    <span class="hljs-type">int</span> *indegree = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[G.vexnum];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">FindInDegree</span>(G, indegree)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//indegree顶点入度</span><br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">if</span>(!indegree[i]) S[++Stop] = i; <br>    <br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Directed acycline graph topologicalsort:\n&quot;</span>;<br>    <span class="hljs-keyword">while</span>(Stop &gt; <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">/*栈不为空时循环*/</span><br>        i = S[Stop--]; T[++Ttop] = i;   <span class="hljs-comment">// i号顶点入T栈</span><br>        count++;<br>        cout &lt;&lt; G.Vextices[i].data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出拓扑排序</span><br>        <span class="hljs-keyword">for</span>(ArcNode* p=G.Vextices[i].firstarc; p; p=p-&gt;nextarc)&#123;<br>            <span class="hljs-type">int</span> k = p-&gt;adjvex;      <span class="hljs-comment">// 邻接弧头节点位置</span><br>            <span class="hljs-keyword">if</span>(--indegree[k]==<span class="hljs-number">0</span>) S[++Stop] = k;   <span class="hljs-comment">// 零入度进栈</span><br>            <span class="hljs-keyword">if</span>(ve[i]+p-&gt;weight &gt; ve[k]) ve[k] = ve[i] + p-&gt;weight;  <br>        &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] indegree;<br>    <span class="hljs-keyword">if</span>(count &lt; G.vexnum)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 有回路  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-comment">// TopologicalOrder</span><br><br><span class="hljs-function">Status <span class="hljs-title">FindInDegree</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> *indegree)</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//inp(i,0,G.vexnum-1) indegree[i] = 0;</span><br>    <span class="hljs-built_in">memset</span>(indegree, <span class="hljs-number">0</span>, G.vexnum*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));  <br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//扫描邻接表，计算各顶点的入度</span><br>        <span class="hljs-keyword">for</span>(ArcNode *p=G.Vextices[i].firstarc;  p;  p=p-&gt;nextarc)<br>            indegree[p-&gt;adjvex]++; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CriticalPath</span><span class="hljs-params">(ALGraph G)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// G为有向网，输出G的各项关键活动</span><br>    <span class="hljs-type">int</span> T[Max_Vertex_Num], Ttop = <span class="hljs-number">-1</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 存储拓扑排序序列，模拟栈                                                 //建立用于产生拓扑逆序的栈T</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">TopologicalSort</span>(G, T, Ttop))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This graph has a cicle.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//该有向网有回路返回false</span><br>    &#125;<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;--------------Critical Path Table-----------------\n&quot;</span>;<br>    <span class="hljs-built_in">inp</span>(j,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>) vl[j] = ve[G.vexnum<span class="hljs-number">-1</span>]; <span class="hljs-comment">//初始化顶点事件的最迟发生时间</span><br>    <span class="hljs-keyword">while</span> (Ttop &gt; <span class="hljs-number">-1</span>)&#123;        <span class="hljs-comment">//按拓扑逆序求各顶点的vl值</span><br>        j = T[Ttop--]; <br>        <span class="hljs-keyword">for</span>(ArcNode *p=G.Vextices[j].firstarc; p; p=p-&gt;nextarc)&#123;<br>            <span class="hljs-type">int</span> k = p-&gt;adjvex, dut = p-&gt;weight;     <span class="hljs-comment">// dut&lt;j,k&gt;</span><br>            <span class="hljs-comment">// vl[k]已经求得，与j各邻接弧k的所有vl[k]-dut要最小，保证耗时最长的相对于vl[k]能准时  </span><br>            <span class="hljs-keyword">if</span>(vl[k] - dut &lt; vl[j])  vl[j] = vl[k] - dut;   <span class="hljs-comment">// min(vl(k)-dut&lt;j,k&gt;)   </span><br>        &#125;<span class="hljs-comment">// for</span><br>    &#125; <span class="hljs-comment">//while</span><br><br>    <span class="hljs-comment">// 求e、l和关键活动</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Activities on edge:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|  Edge  | duration | e | l | l-e | CriActi |\n&quot;</span>;   <span class="hljs-comment">// title</span><br>    <span class="hljs-built_in">inp</span>(j,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)                    <br>        <span class="hljs-keyword">for</span> (ArcNode *p = G.Vextices[j].firstarc; p; p = p-&gt;nextarc) &#123;<br>            <span class="hljs-type">int</span> k = p-&gt;adjvex, dut= p-&gt;weight;<br>            <span class="hljs-type">int</span> ee = ve[j], el = vl[k]-dut;<br>            string tag = (ve[j]==(vl[k]-dut))? <span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No &quot;</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;|&lt;&quot;</span> &lt;&lt; G.Vextices[j].data &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; G.Vextices[k].data &lt;&lt; <span class="hljs-string">&quot;&gt;|    &quot;</span>;<br>            cout &lt;&lt; dut &lt;&lt; <span class="hljs-string">&quot;     | &quot;</span> &lt;&lt; ee &lt;&lt; <span class="hljs-string">&quot; | &quot;</span> &lt;&lt; el &lt;&lt; <span class="hljs-string">&quot; |  &quot;</span> &lt;&lt; el-ee &lt;&lt; <span class="hljs-string">&quot;  |   &quot;</span> &lt;&lt; tag &lt;&lt; <span class="hljs-string">&quot;   |\n&quot;</span>; <span class="hljs-comment">//输出关键活动</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Events on vertex:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;| Vertex | ve | vl |\n&quot;</span>;   <span class="hljs-comment">//title</span><br>    <span class="hljs-built_in">inp</span>(j,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;|   &quot;</span> &lt;&lt; G.Vextices[j].data &lt;&lt; <span class="hljs-string">&quot;   | &quot;</span> &lt;&lt; ve[j] &lt;&lt; <span class="hljs-string">&quot;  | &quot;</span> &lt;&lt; vl[j] &lt;&lt; <span class="hljs-string">&quot;  |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-comment">//CriticalPath</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>给出一个算例演示：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//------------------Here is a demo----------------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">6 8 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">V1 V2 V3 V4 V5 V6</span><br><span class="hljs-comment">Input two vertices and weight of the edges:</span><br><span class="hljs-comment">V1 V2 3</span><br><span class="hljs-comment">V2 V5 3</span><br><span class="hljs-comment">V2 V4 2</span><br><span class="hljs-comment">V1 V3 2</span><br><span class="hljs-comment">V3 V4 4</span><br><span class="hljs-comment">V4 V6 2</span><br><span class="hljs-comment">V3 V6 3</span><br><span class="hljs-comment">V5 V6 1</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: directed nets</span><br><span class="hljs-comment">Vextices number: 6   Arcs number: 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: V1-[3]-&gt;V2  V1-[2]-&gt;V3</span><br><span class="hljs-comment">In path:</span><br><span class="hljs-comment">V1  Vextice Degree: 2  Outdegree: 2  Indegree: 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V2-[3]-&gt;V5  V2-[2]-&gt;V4</span><br><span class="hljs-comment">In path: V1-[3]-&gt;-V2</span><br><span class="hljs-comment">V2  Vextice Degree: 3  Outdegree: 2  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V3-[4]-&gt;V4  V3-[3]-&gt;V6</span><br><span class="hljs-comment">In path: V1-[2]-&gt;-V3</span><br><span class="hljs-comment">V3  Vextice Degree: 3  Outdegree: 2  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V4-[2]-&gt;V6</span><br><span class="hljs-comment">In path: V2-[2]-&gt;-V4  V3-[4]-&gt;-V4</span><br><span class="hljs-comment">V4  Vextice Degree: 3  Outdegree: 1  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V5-[1]-&gt;V6</span><br><span class="hljs-comment">In path: V2-[3]-&gt;-V5</span><br><span class="hljs-comment">V5  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path:</span><br><span class="hljs-comment">In path: V4-[2]-&gt;-V6  V3-[3]-&gt;-V6  V5-[1]-&gt;-V6</span><br><span class="hljs-comment">V6  Vextice Degree: 3  Outdegree: 0  Indegree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Directed acycline graph topologicalsort:</span><br><span class="hljs-comment">V1 V3 V2 V4 V5 V6</span><br><span class="hljs-comment">--------------Critical Path Table-----------------</span><br><span class="hljs-comment">Activities on edge:</span><br><span class="hljs-comment">---------------------------------------------</span><br><span class="hljs-comment">|  Edge  | duration | e | l | l-e | CriActi |</span><br><span class="hljs-comment">|&lt;V1, V2&gt;|    3     | 0 | 1 |  1  |   No    |</span><br><span class="hljs-comment">|&lt;V1, V3&gt;|    2     | 0 | 0 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V2, V5&gt;|    3     | 3 | 4 |  1  |   No    |</span><br><span class="hljs-comment">|&lt;V2, V4&gt;|    2     | 3 | 4 |  1  |   No    |</span><br><span class="hljs-comment">|&lt;V3, V4&gt;|    4     | 2 | 2 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V3, V6&gt;|    3     | 2 | 5 |  3  |   No    |</span><br><span class="hljs-comment">|&lt;V4, V6&gt;|    2     | 6 | 6 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V5, V6&gt;|    1     | 6 | 7 |  1  |   No    |</span><br><span class="hljs-comment">---------------------------------------------</span><br><span class="hljs-comment">Events on vertex:</span><br><span class="hljs-comment">--------------------</span><br><span class="hljs-comment">| Vertex | ve | vl |</span><br><span class="hljs-comment">|   V1   | 0  | 0  |</span><br><span class="hljs-comment">|   V2   | 3  | 4  |</span><br><span class="hljs-comment">|   V3   | 2  | 2  |</span><br><span class="hljs-comment">|   V4   | 6  | 6  |</span><br><span class="hljs-comment">|   V5   | 6  | 7  |</span><br><span class="hljs-comment">|   V6   | 8  | 8  |</span><br><span class="hljs-comment">--------------------</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//----------------Here is another demo------------//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">9 11 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">V1 V2 V3 V4 V5 V6 V7 V8 V9</span><br><span class="hljs-comment">Input two vertices and weight of the edges:</span><br><span class="hljs-comment">V1 V2 6</span><br><span class="hljs-comment">V1 V3 4</span><br><span class="hljs-comment">V1 V4 5</span><br><span class="hljs-comment">V2 V5 1</span><br><span class="hljs-comment">V3 V5 1</span><br><span class="hljs-comment">V4 V6 2</span><br><span class="hljs-comment">V5 V7 9</span><br><span class="hljs-comment">V5 V8 7</span><br><span class="hljs-comment">V6 V8 4</span><br><span class="hljs-comment">V7 V9 2</span><br><span class="hljs-comment">V8 V9 4</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: directed nets</span><br><span class="hljs-comment">Vextices number: 9   Arcs number: 11</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: V1-[6]-&gt;V2  V1-[4]-&gt;V3  V1-[5]-&gt;V4</span><br><span class="hljs-comment">In path:</span><br><span class="hljs-comment">V1  Vextice Degree: 3  Outdegree: 3  Indegree: 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V2-[1]-&gt;V5</span><br><span class="hljs-comment">In path: V1-[6]-&gt;-V2</span><br><span class="hljs-comment">V2  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V3-[1]-&gt;V5</span><br><span class="hljs-comment">In path: V1-[4]-&gt;-V3</span><br><span class="hljs-comment">V3  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V4-[2]-&gt;V6</span><br><span class="hljs-comment">In path: V1-[5]-&gt;-V4</span><br><span class="hljs-comment">V4  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V5-[9]-&gt;V7  V5-[7]-&gt;V8</span><br><span class="hljs-comment">In path: V2-[1]-&gt;-V5  V3-[1]-&gt;-V5</span><br><span class="hljs-comment">V5  Vextice Degree: 4  Outdegree: 2  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V6-[4]-&gt;V8</span><br><span class="hljs-comment">In path: V4-[2]-&gt;-V6</span><br><span class="hljs-comment">V6  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V7-[2]-&gt;V9</span><br><span class="hljs-comment">In path: V5-[9]-&gt;-V7</span><br><span class="hljs-comment">V7  Vextice Degree: 2  Outdegree: 1  Indegree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: V8-[4]-&gt;V9</span><br><span class="hljs-comment">In path: V5-[7]-&gt;-V8  V6-[4]-&gt;-V8</span><br><span class="hljs-comment">V8  Vextice Degree: 3  Outdegree: 1  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path:</span><br><span class="hljs-comment">In path: V7-[2]-&gt;-V9  V8-[4]-&gt;-V9</span><br><span class="hljs-comment">V9  Vextice Degree: 2  Outdegree: 0  Indegree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Directed acycline graph topologicalsort:</span><br><span class="hljs-comment">V1 V4 V6 V3 V2 V5 V8 V7 V9</span><br><span class="hljs-comment">--------------Critical Path Table-----------------</span><br><span class="hljs-comment">Activities on edge:</span><br><span class="hljs-comment">---------------------------------------------</span><br><span class="hljs-comment">|  Edge  | duration | e | l | l-e | CriActi |</span><br><span class="hljs-comment">|&lt;V1, V2&gt;|    6     | 0 | 0 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V1, V3&gt;|    4     | 0 | 2 |  2  |   No    |</span><br><span class="hljs-comment">|&lt;V1, V4&gt;|    5     | 0 | 3 |  3  |   No    |</span><br><span class="hljs-comment">|&lt;V2, V5&gt;|    1     | 6 | 6 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V3, V5&gt;|    1     | 4 | 6 |  2  |   No    |</span><br><span class="hljs-comment">|&lt;V4, V6&gt;|    2     | 5 | 8 |  3  |   No    |</span><br><span class="hljs-comment">|&lt;V5, V7&gt;|    9     | 7 | 7 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V5, V8&gt;|    7     | 7 | 7 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V6, V8&gt;|    4     | 7 | 10 |  3  |   No    |</span><br><span class="hljs-comment">|&lt;V7, V9&gt;|    2     | 16 | 16 |  0  |   Yes   |</span><br><span class="hljs-comment">|&lt;V8, V9&gt;|    4     | 14 | 14 |  0  |   Yes   |</span><br><span class="hljs-comment">---------------------------------------------</span><br><span class="hljs-comment">Events on vertex:</span><br><span class="hljs-comment">--------------------</span><br><span class="hljs-comment">| Vertex | ve | vl |</span><br><span class="hljs-comment">|   V1   | 0  | 0  |</span><br><span class="hljs-comment">|   V2   | 6  | 6  |</span><br><span class="hljs-comment">|   V3   | 4  | 6  |</span><br><span class="hljs-comment">|   V4   | 5  | 8  |</span><br><span class="hljs-comment">|   V5   | 7  | 7  |</span><br><span class="hljs-comment">|   V6   | 7  | 10  |</span><br><span class="hljs-comment">|   V7   | 16  | 16  |</span><br><span class="hljs-comment">|   V8   | 14  | 14  |</span><br><span class="hljs-comment">|   V9   | 18  | 18  |</span><br><span class="hljs-comment">--------------------</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>导数与微分</title>
    <url>/2022/10/14/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="第四讲、导数与微分"><a href="#第四讲、导数与微分" class="headerlink" title="第四讲、导数与微分"></a>第四讲、导数与微分</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210150947774.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210150948701.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210150949084.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210150950494.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210150954031.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210150957582.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151001182.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151005971.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151006420.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151009629.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151017716.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151018484.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151024755.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151025747.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151026169.png" alt=""></p>
<h3 id="隐函数存在定理"><a href="#隐函数存在定理" class="headerlink" title="隐函数存在定理"></a>隐函数存在定理</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151417363.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151417271.png" alt=""></p>
<h2 id="四、典型例题"><a href="#四、典型例题" class="headerlink" title="四、典型例题"></a>四、典型例题</h2><h3 id="4-1-由方程组求导数"><a href="#4-1-由方程组求导数" class="headerlink" title="4.1 由方程组求导数"></a>4.1 由方程组求导数</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151435749.png" alt=""></p>
<h3 id="4-2-等价展开式处理"><a href="#4-2-等价展开式处理" class="headerlink" title="4.2 等价展开式处理"></a>4.2 等价展开式处理</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151436893.png" alt=""></p>
<h3 id="4-3-Taylor-公式求导数"><a href="#4-3-Taylor-公式求导数" class="headerlink" title="4.3 $Taylor$公式求导数"></a>4.3 $Taylor$公式求导数</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151444390.png" alt=""></p>
<h3 id="4-4-Leibniz-公式运用"><a href="#4-4-Leibniz-公式运用" class="headerlink" title="4.4 $Leibniz$公式运用"></a>4.4 $Leibniz$公式运用</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151508577.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151509345.png" alt=""></p>
<h4 id="4-4-1-求高阶导数"><a href="#4-4-1-求高阶导数" class="headerlink" title="4.4.1 求高阶导数"></a>4.4.1 求高阶导数</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151514227.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151514273.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151515512.png" alt=""></p>
<h4 id="4-4-2-综合运用"><a href="#4-4-2-综合运用" class="headerlink" title="4.4.2 综合运用"></a>4.4.2 综合运用</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151519871.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151523339.png" alt=""></p>
<h3 id="4-5-单侧倒数与可导性"><a href="#4-5-单侧倒数与可导性" class="headerlink" title="4.5 单侧倒数与可导性"></a>4.5 单侧倒数与可导性</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151528587.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151614398.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210151614240.png" alt=""></p>
<h3 id="4-6-多元函数连续性与可导性"><a href="#4-6-多元函数连续性与可导性" class="headerlink" title="4.6 多元函数连续性与可导性"></a>4.6 多元函数连续性与可导性</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152011769.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152011451.png" alt=""></p>
<h3 id="4-7-偏导数与全微分"><a href="#4-7-偏导数与全微分" class="headerlink" title="4.7 偏导数与全微分"></a>4.7 偏导数与全微分</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152036350.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152040725.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152040468.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152045549.png" alt=""><br>注解：当函数$u=f(x,y,z)$对$\theta$偏导数等于零时，则说明函数与该变量无关（或不含有或为常量）；<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152050892.png" alt=""><br>注解：信息挖掘，$F(rcos\theta,rsin\theta)=h(r)$，根据$h(r)$不含有$theta$可得对$\theta$偏导数等于零，于是$F$对于$\theta$偏导数也等于零；        </p>
<h3 id="4-8-方向导数与梯度"><a href="#4-8-方向导数与梯度" class="headerlink" title="4.8 方向导数与梯度"></a>4.8 方向导数与梯度</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152100015.png" alt=""><br>注解：注意坐标转换；<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152103825.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210152103222.png" alt=""></p>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数模C题</title>
    <url>/2022/05/13/%E6%95%B0%E6%A8%A1C%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数模C题总结"><a href="#数模C题总结" class="headerlink" title="数模C题总结"></a>数模C题总结</h2><h4 id="第一部分——问题分析"><a href="#第一部分——问题分析" class="headerlink" title="第一部分——问题分析"></a>第一部分——问题分析</h4><p>拆分问题，将各个问题进行拆分，尤其是效果分析类的</p>
<h4 id="第一部分——数据预处理"><a href="#第一部分——数据预处理" class="headerlink" title="第一部分——数据预处理"></a>第一部分——数据预处理</h4><p><strong>数据探索性分析</strong>      </p>
<pre><code>箱型图======&gt;探究是否有偏好情况=======&gt;决定了之后问题解决是否要考虑材料种类差异
对数直方图、洛伦兹图======&gt;探究数据是否存在数量级差异以及数据的均衡程度
散点图======&gt;探究数据的分布情况
</code></pre><h4 id="第二部分——评价类"><a href="#第二部分——评价类" class="headerlink" title="第二部分——评价类"></a>第二部分——评价类</h4><p><strong>熵权法-TOPSIS</strong>    </p>
<pre><code>叙述:
熵权法通过计算指标的信息熵，根据其相对变化程度对系统的整体影响来决定权重，避免了
层次分析法等主观赋权法的弊端，获取权重的客观性较强。在得到权重后， 利用 TOPSIS
方法将它们综合， TOPSIS 法通过构建评价问题的正理想解和负理想解，计算每个方案到理
想方案的相对贴近度来对方案进行排序，最终求解出最优方案。
</code></pre><h4 id="第三部分——横纵向分析"><a href="#第三部分——横纵向分析" class="headerlink" title="第三部分——横纵向分析"></a>第三部分——横纵向分析</h4><pre><code>模型构建分析时，直接显著点出横向角度和纵向角度（一般有时间）来分析
核密度曲线
季节性分解
</code></pre><p>_机会约束叙述：_<br><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172332648-38102188.png" alt="">     </p>
<pre><code>蒙特卡洛法
针状图====&gt;检验有效数据的完整性      
</code></pre><h4 id="第四部分——方案实施效果分析"><a href="#第四部分——方案实施效果分析" class="headerlink" title="第四部分——方案实施效果分析"></a>第四部分——方案实施效果分析</h4><pre><code>绘制数据结果图=====&gt;结合图像说明或解释
变化面积图
置信因子α灵敏度分析:
分别取置信因子α=0.85， 0.9， 0.95对约束进行松弛，可以得到丌同的决策集合。
随着置信度𝛼的上升，随机变量𝜉的少数极端抖动造成约束条件难以满足， 迫使企
业需要增大订单量来对冲风险，亍是表现为总订单额的升高。
类似的，对亍转运损失率，随着置信度𝛼的上升，转运损失率也在违约率高的周
内相应明显升高，这也进一步印证了前文关亍损失率和违约率的机理猜测。    
</code></pre><h4 id="第五部分——惩罚因子"><a href="#第五部分——惩罚因子" class="headerlink" title="第五部分——惩罚因子"></a>第五部分——惩罚因子</h4><pre><code>问题三只在问题二的基础上改变了一点要求，即尽量多地采购A 类和尽量少地采购C类原材料，
可以考虑为每立方米 A、 B、 C 三种材料分别赋予惩罚因子为 1、 5、10，以惩罚函数最小为目标，约束同问题二，建立右图所示的觃划模型。转运方案制定不方案实施效果分析同问题二。
</code></pre>]]></content>
      <tags>
        <tag>数模</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈</title>
    <url>/2022/10/25/%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h2 id="杂谈笔记"><a href="#杂谈笔记" class="headerlink" title="杂谈笔记"></a>杂谈笔记</h2><h3 id="一、内联函数以及读入多位整数"><a href="#一、内联函数以及读入多位整数" class="headerlink" title="一、内联函数以及读入多位整数"></a>一、内联函数以及读入多位整数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 读入多位数函数</span><br>	<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;  <span class="hljs-comment">// f标记正负</span><br>	<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>		<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>		ch=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>		x=x*<span class="hljs-number">10</span> + ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>		ch=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> x*f;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内联函数使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> m = <span class="hljs-built_in">read</span>();<br></code></pre></td></tr></table></figure></p>
<h3 id="二、循环简记"><a href="#二、循环简记" class="headerlink" title="二、循环简记"></a>二、循环简记</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;++i)  <span class="hljs-comment">//increasing loop</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dep(i,x,y) for(i=x,i&gt;=y;--i)  <span class="hljs-comment">//decreasing loop</span></span><br></code></pre></td></tr></table></figure>
<p>给出一个读入前缀和的演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,n) presum[i]=<span class="hljs-built_in">read</span>(),presum[i]+=presum[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// prefix sum</span><br></code></pre></td></tr></table></figure></p>
<h3 id="三、单调队列——最大子序和"><a href="#三、单调队列——最大子序和" class="headerlink" title="三、单调队列——最大子序和"></a>三、单调队列——最大子序和</h3><p><a href="https://www.acwing.com/problem/content/description/137/">题目链接-135. 最大子序和</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dep(i,x,y) for(i=x;i&gt;=y;i--)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>        x = x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        ch=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m;<br>ll presum[N];<br><span class="hljs-type">int</span> q[N];   <span class="hljs-comment">// 模拟队列窗口</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,j,hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 指向当前窗口的首尾</span><br>    ll ans=<span class="hljs-number">-1e18</span>;     <span class="hljs-comment">// 初始置于无穷小</span><br>    <br>    n = <span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-comment">// 读入前缀和</span><br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,n) presum[i]=<span class="hljs-built_in">read</span>(),presum[i]+=presum[i<span class="hljs-number">-1</span>];<br><br>    q[++tt]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//维持一个单调增队列，队首元素的前缀和最小</span><br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>        <span class="hljs-comment">// 寻找窗口最值(在队首位置)</span><br>        ans=<span class="hljs-built_in">max</span>(ans,presum[i]-presum[q[hh]]);<br>        <span class="hljs-comment">// 当前元素小于队尾元素，对下一元素而言，因当前元素的存在，队尾元素不可能成为下一元素的最优选择，因此出队</span><br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;presum[q[tt]]&gt;presum[i]) --tt;<br>        q[++tt]=i;<br>        <span class="hljs-keyword">if</span>(i-q[hh]&gt;=m) ++hh;       <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>注解：维持一个单调增队列，设 $dp[i]$ 表示以 $i$ 结尾的长度不超过 $m$ 的连续子序列的最大值，则有状态转移方程：</p>
<script type="math/tex; mode=display">
dp[i]=presum[i]-min(presum[i-1],pre[i-2],\cdot\cdot\cdot,pre[max(0,i-m)])</script><p>所以对每一个 $i$ 位置元素而言，前面元素应尽量小；在维持窗口允许的长度时，可以维护一个队列保留 $i$ 位置元素对应窗口中的可行解，队首为最优解；     </p>
<h3 id="四、set使用"><a href="#四、set使用" class="headerlink" title="四、set使用"></a>四、<code>set</code>使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7f7f7f7f</span>;    <span class="hljs-comment">// 定义int的无穷大量</span><br>set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; s;<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(a, <span class="hljs-number">1</span>));   <span class="hljs-comment">// 插入生成元素</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans;   <span class="hljs-comment">//定义二元组类型</span><br>ans.first = INF;    <span class="hljs-comment">// 选取第一个元素</span><br>ans.second = <span class="hljs-number">3</span>;      <span class="hljs-comment">// 第二个元素；</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法</title>
    <url>/2022/11/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;MGraph.h&quot;</span></span><br><span class="hljs-comment">//-----------------最短路算法--------------//</span><br><span class="hljs-comment">// 采用邻接矩阵存储表示</span><br><span class="hljs-comment">//-----------------Dijkstra算法求最短路径--------------//</span><br><span class="hljs-function">Status <span class="hljs-title">DijsMinPath</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> v0)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">DispDijsPaths</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *D, <span class="hljs-type">int</span> *fa, <span class="hljs-type">bool</span> *<span class="hljs-keyword">final</span>, <span class="hljs-type">int</span> v0)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">MinDijsPrint</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *fa, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> v0)</span></span>;<br><span class="hljs-comment">//-----------------Floyd算法求最短路径--------------//</span><br><span class="hljs-function">Status <span class="hljs-title">FloydMinPath</span><span class="hljs-params">(MGraph G)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">MinFloydPrint</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *path, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span>; <br><span class="hljs-function">Status <span class="hljs-title">DispFloydPaths</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *D, <span class="hljs-type">int</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MGraph G;<br>    <span class="hljs-built_in">CreateGraph</span>(G);<br>    <span class="hljs-built_in">GraphPrint</span>(G);<br>    cout &lt;&lt; <span class="hljs-string">&quot;----------------------Dijkstra MinPath Problem Page------------------\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the source node: &quot;</span>;<br>    VertexType sv;<br>    cin &gt;&gt; sv;<br>    <span class="hljs-type">int</span> v0 = <span class="hljs-built_in">LocateVex</span>(G, sv);<br>    <span class="hljs-built_in">DijsMinPath</span>(G, v0);<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------Floyd MinPath Problem Page---------------------\n&quot;</span>;<br>    <span class="hljs-built_in">FloydMinPath</span>(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*-------------------------------Dijkstra ALgorithm-----------------------*/</span><br><span class="hljs-function">Status <span class="hljs-title">DijsMinPath</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> v0)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// D[v]表示v0到v的最短路径带权长度</span><br>    <span class="hljs-comment">// fa[v]=w表示通过w中转，即D(v0,w)+arc(w,v)便于回溯路径</span><br>    <span class="hljs-comment">// final[v]：标识数组，为True当且仅当v属于S, 即已经求得v0到v最短路</span><br>    <span class="hljs-type">int</span> fa[Max_Vertex_Num], D[Max_Vertex_Num];<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">final</span>[Max_Vertex_Num];<br>    <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 初始化操作</span><br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">final</span>[v] = <span class="hljs-literal">false</span>;    <br>        D[v] = G.arcs[v0][v].adj;<br>        <span class="hljs-comment">// v0到v邻接</span><br>        <span class="hljs-keyword">if</span>(D[v] != INFINITY) fa[v] = v0; <span class="hljs-comment">// 路径回溯</span><br>    &#125;<br><br>    <span class="hljs-keyword">final</span>[v0] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 初始化节点v0属于S集</span><br>    <span class="hljs-comment">// 取min(d(v0,v)) v属于V-S, 即求剩余节点中到v0距离最短得节点v</span><br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,G.vexnum<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-comment">// 当前所知离v0顶点的最近距离, 初始未找到为无穷大</span><br>        <span class="hljs-type">int</span> min_path = INFINITY;   <br>        <span class="hljs-built_in">inp</span>(w,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">final</span>[w])    <span class="hljs-comment">// w节点在V-S中</span><br>                <span class="hljs-keyword">if</span>(D[w] &lt; min_path)&#123;  <span class="hljs-comment">// 取min</span><br>                    v = w;      <br>                    min_path = D[w];<br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将选中的节点即确定距离得节点加入S集中</span><br>        <span class="hljs-keyword">if</span>(min_path != INFINITY) <span class="hljs-keyword">final</span>[v] = <span class="hljs-literal">true</span>;    <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 通过新选的节点v中转更新V-S中节点距离操作</span><br>        <span class="hljs-built_in">inp</span>(w,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">final</span>[w] &amp;&amp; G.arcs[v][w].adj != INFINITY)    <span class="hljs-comment">// 避免最大值上溢问题的特判</span><br>                <span class="hljs-keyword">if</span>(min_path + G.arcs[v][w].adj &lt; D[w])&#123;<br>                    D[w] = min_path + G.arcs[v][w].adj;<br>                    fa[w] = v;    <span class="hljs-comment">// 上次中转节点    </span><br>                &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">DispDijsPaths</span>(G, D, fa, <span class="hljs-keyword">final</span>, v0);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DispDijsPaths</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *D, <span class="hljs-type">int</span> *fa, <span class="hljs-type">bool</span> *<span class="hljs-keyword">final</span>, <span class="hljs-type">int</span> v0)</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i != v0)&#123;   <span class="hljs-comment">// 不包括源点</span><br>	        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">final</span>[i])&#123;    <span class="hljs-comment">// 如果已确定最短距离</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;from &quot;</span> &lt;&lt; G.vexs[v0] &lt;&lt; <span class="hljs-string">&quot; to &quot;</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="hljs-string">&quot; the shortest path length: &quot;</span> &lt;&lt; D[i];<br>                cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Display the path:\n&quot;</span> &lt;&lt; G.vexs[v0] &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>; <span class="hljs-comment">/*输出路径上的起点*/</span><br>                <span class="hljs-built_in">MinDijsPrint</span>(G, fa, i, v0);	<span class="hljs-comment">/*输出路径上的中间点*/</span><br>                cout &lt;&lt; G.vexs[i] &lt;&lt; endl;	<span class="hljs-comment">/*输出路径上的终点*/</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;from &quot;</span> &lt;&lt; G.vexs[v0] &lt;&lt; <span class="hljs-string">&quot; to &quot;</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="hljs-string">&quot; there is no road.\n&quot;</span>;<br>	   &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">MinDijsPrint</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *fa, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> v0)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 回溯输出v到v0的最短路径</span><br>    <span class="hljs-type">int</span> w = fa[v];<br>    <span class="hljs-keyword">if</span>(w == v0)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 找到了起点则返回</span><br>    &#125;<br>    <span class="hljs-built_in">MinDijsPrint</span>(G, fa, w, v0);   <span class="hljs-comment">// 找w顶点的父顶点</span><br>    cout &lt;&lt; G.vexs[w] &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/*-------------------------------Dijkstra ALgorithm-----------------------*/</span><br><br><span class="hljs-comment">/*-------------------------------Floyd ALgorithm--------------------------*/</span><br><span class="hljs-function">Status <span class="hljs-title">FloydMinPath</span><span class="hljs-params">(MGraph G)</span></span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">// path[v][w]表示v到w最短路径上经过的最后一个节点即w的父节点</span><br>    <span class="hljs-type">int</span> path[G.vexnum][G.vexnum], D[G.vexnum][G.vexnum];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)    <span class="hljs-comment">//矩阵 D与 path初始化</span><br>        <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)&#123;<br>            D[i][j] = G.arcs[i][j].adj;<br>            <span class="hljs-keyword">if</span>(D[i][j] != INFINITY)  path[i][j] = i;     <span class="hljs-comment">// 头节点 	    	</span><br>	        <span class="hljs-keyword">else</span> path[i][j] = <span class="hljs-number">-1</span>;	    <span class="hljs-comment">// i到j无路径	</span><br>        &#125;<br>    <br>    <span class="hljs-comment">// 生成D(k)及path(k)</span><br>    <span class="hljs-built_in">inp</span>(k, <span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">inp</span>(j, <span class="hljs-number">0</span>, G.vexnum<span class="hljs-number">-1</span>)<br>                <span class="hljs-comment">// 加入Vk节点</span><br>                <span class="hljs-keyword">if</span>(D[i][k] != INFINITY &amp;&amp; D[k][j] != INFINITY)    <span class="hljs-comment">// 解决INF运算溢出的问题</span><br>                    <span class="hljs-keyword">if</span>(D[i][j] &gt; D[i][k] + D[k][j])&#123; <br>                        D[i][j] = D[i][k] + D[k][j];<br>                        path[i][j] = path[k][j];   <span class="hljs-comment">//缩短路径长度, 经过 k 到 j</span><br>                        <span class="hljs-comment">//注解：相当于对&lt;i,j&gt;路径改向，&lt;i,j&gt;方向改为经k的&lt;k,j&gt;方向</span><br>                    &#125;<br>    <span class="hljs-built_in">DispFloydPaths</span>(G, &amp;D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], &amp;path[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DispFloydPaths</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *D, <span class="hljs-type">int</span> *path)</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>;<br>        <span class="hljs-built_in">inp</span>(j,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">continue</span>;     <span class="hljs-comment">// 不包括节点自身</span><br>            <span class="hljs-keyword">if</span>(D[i*G.vexnum + j] != INFINITY)&#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;from &quot;</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="hljs-string">&quot; to &quot;</span> &lt;&lt; G.vexs[j] &lt;&lt; <span class="hljs-string">&quot; the shortest path length: &quot;</span> &lt;&lt; D[i*G.vexnum + j] &lt;&lt; endl;<br>                cout &lt;&lt; <span class="hljs-string">&quot;Display the path:\n&quot;</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>; <span class="hljs-comment">/*输出路径上的起点*/</span><br>                <span class="hljs-built_in">MinFloydPrint</span>(G, path, i, j);	<span class="hljs-comment">/*输出路径上的中间点*/</span><br>                cout &lt;&lt; G.vexs[j] &lt;&lt; endl;	<span class="hljs-comment">/*输出路径上的终点*/</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;from &quot;</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="hljs-string">&quot; to &quot;</span> &lt;&lt; G.vexs[j] &lt;&lt; <span class="hljs-string">&quot; there is no road.\n&quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">MinFloydPrint</span><span class="hljs-params">(MGraph G, <span class="hljs-type">int</span> *path, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span>    </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 回溯输出v到w的最短路径</span><br>    <span class="hljs-type">int</span> p = path[v*G.vexnum + w];<br>    <span class="hljs-keyword">if</span>(p == v)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 找到了起点则返回</span><br>    &#125;<br>    <span class="hljs-built_in">MinFloydPrint</span>(G, path, v, p);   <span class="hljs-comment">// 找w顶点的父顶点</span><br>    cout &lt;&lt; G.vexs[p] &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/*-------------------------------Floyd ALgorithm--------------------------*/</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>一个算例演示</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">6 8 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">V0 V1 V2 V3 V4 V5</span><br><span class="hljs-comment">Input two vertices and weight of the edges:</span><br><span class="hljs-comment">V0 V5 100</span><br><span class="hljs-comment">V0 V4 30</span><br><span class="hljs-comment">V0 V2 10</span><br><span class="hljs-comment">V1 V2 5 </span><br><span class="hljs-comment">V4 V5 60</span><br><span class="hljs-comment">V4 V3 20</span><br><span class="hljs-comment">V3 V5 10</span><br><span class="hljs-comment">V2 V3 50</span><br><span class="hljs-comment">Output Graph Information:</span><br><span class="hljs-comment">Graph Kind: directed nets</span><br><span class="hljs-comment">Vextices number: 6   Arcs number: 8</span><br><span class="hljs-comment">Vextices Vector Information:</span><br><span class="hljs-comment">V0-&lt;0&gt;-V0 V0-&lt;10&gt;-V2 V0-&lt;30&gt;-V4 V0-&lt;100&gt;-V5     </span><br><span class="hljs-comment">V0  Vextice Degree: 5  Outdegree: 4  Indegree: 1</span><br><span class="hljs-comment">V1-&lt;0&gt;-V1 V1-&lt;5&gt;-V2</span><br><span class="hljs-comment">V1  Vextice Degree: 3  Outdegree: 2  Indegree: 1</span><br><span class="hljs-comment">V2-&lt;0&gt;-V2 V2-&lt;50&gt;-V3</span><br><span class="hljs-comment">V2  Vextice Degree: 5  Outdegree: 2  Indegree: 3</span><br><span class="hljs-comment">V3-&lt;0&gt;-V3 V3-&lt;10&gt;-V5</span><br><span class="hljs-comment">V3  Vextice Degree: 5  Outdegree: 2  Indegree: 3</span><br><span class="hljs-comment">V4-&lt;20&gt;-V3 V4-&lt;0&gt;-V4 V4-&lt;60&gt;-V5</span><br><span class="hljs-comment">V4  Vextice Degree: 5  Outdegree: 3  Indegree: 2</span><br><span class="hljs-comment">V5-&lt;0&gt;-V5</span><br><span class="hljs-comment">V5  Vextice Degree: 5  Outdegree: 1  Indegree: 4</span><br><span class="hljs-comment">----------------------Dijkstra MinPath Problem Page------------------</span><br><span class="hljs-comment">Input the source node: V0</span><br><span class="hljs-comment">from V0 to V1 there is no road.</span><br><span class="hljs-comment">from V0 to V2 the shortest path length: 10</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V2</span><br><span class="hljs-comment">from V0 to V3 the shortest path length: 50</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V4-&gt;V3</span><br><span class="hljs-comment">from V0 to V4 the shortest path length: 30</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V4</span><br><span class="hljs-comment">from V0 to V5 the shortest path length: 60</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V4-&gt;V3-&gt;V5</span><br><span class="hljs-comment">-----------------------Floyd MinPath Problem Page---------------------</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">from V0 to V1 there is no road.</span><br><span class="hljs-comment">from V0 to V2 the shortest path length: 10</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V2</span><br><span class="hljs-comment">from V0 to V3 the shortest path length: 50</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V4-&gt;V3</span><br><span class="hljs-comment">from V0 to V4 the shortest path length: 30</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V4</span><br><span class="hljs-comment">from V0 to V5 the shortest path length: 60</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V0-&gt;V4-&gt;V3-&gt;V5</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">from V1 to V0 there is no road.</span><br><span class="hljs-comment">from V1 to V2 the shortest path length: 5</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V1-&gt;V2</span><br><span class="hljs-comment">from V1 to V3 the shortest path length: 55</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V1-&gt;V2-&gt;V3</span><br><span class="hljs-comment">from V1 to V4 there is no road.</span><br><span class="hljs-comment">from V1 to V5 the shortest path length: 65</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V1-&gt;V2-&gt;V3-&gt;V5</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">from V2 to V0 there is no road.</span><br><span class="hljs-comment">from V2 to V1 there is no road.</span><br><span class="hljs-comment">from V2 to V3 the shortest path length: 50</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V2-&gt;V3</span><br><span class="hljs-comment">from V2 to V4 there is no road.</span><br><span class="hljs-comment">from V2 to V5 the shortest path length: 60</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V2-&gt;V3-&gt;V5</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">from V3 to V0 there is no road.</span><br><span class="hljs-comment">from V3 to V1 there is no road.</span><br><span class="hljs-comment">from V3 to V2 there is no road.</span><br><span class="hljs-comment">from V3 to V4 there is no road.</span><br><span class="hljs-comment">from V3 to V5 the shortest path length: 10</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V3-&gt;V5</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">from V4 to V0 there is no road.</span><br><span class="hljs-comment">from V4 to V1 there is no road.</span><br><span class="hljs-comment">from V4 to V2 there is no road.</span><br><span class="hljs-comment">from V4 to V3 the shortest path length: 20</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V4-&gt;V3</span><br><span class="hljs-comment">from V4 to V5 the shortest path length: 30</span><br><span class="hljs-comment">Display the path:</span><br><span class="hljs-comment">V4-&gt;V3-&gt;V5</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">from V5 to V0 there is no road.</span><br><span class="hljs-comment">from V5 to V1 there is no road.</span><br><span class="hljs-comment">from V5 to V2 there is no road.</span><br><span class="hljs-comment">from V5 to V3 there is no road.</span><br><span class="hljs-comment">from V5 to V4 there is no road.</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>栈进阶数据结构</title>
    <url>/2022/10/08/%E6%A0%88%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<h3 id="一、栈维护最值"><a href="#一、栈维护最值" class="headerlink" title="一、栈维护最值"></a>一、栈维护最值</h3><p>时间复杂度<code>O(1)</code>；设置三个栈<code>A、B、C</code>，其中<code>A</code>栈存储原始数据，<code>B、C</code>栈分别维护栈中最小值和最大值:<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 进栈操作</span><br>A.<span class="hljs-built_in">push</span>(x);<br>B.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(B.<span class="hljs-built_in">top</span>(),x));<br>C.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">max</span>(C.<span class="hljs-built_in">top</span>(),x));<br><span class="hljs-comment">// 出栈操作</span><br>A.<span class="hljs-built_in">pop</span>();<br>B.<span class="hljs-built_in">pop</span>();<br>C.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure></p>
<h3 id="二、对顶栈"><a href="#二、对顶栈" class="headerlink" title="二、对顶栈"></a>二、对顶栈</h3><p>应用思想：始终在序列中间某个指定位置进行修改；<br>建立两个栈，<code>A</code>栈存储从序列开头到当前位置的这一段子序列，栈<code>B</code>存储当前位置到序列结尾处的这一段子序列，二者都以当前位置那一端作为栈顶。<br>栈求  <strong>_最大前缀和_</strong>  时，用一个数组<code>f</code>维护栈<code>A</code>的最大前缀和；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A的栈顶位置下标pA，使用数组模拟栈</span><br><span class="hljs-comment">// sum是A的前缀和数组</span><br>A.<span class="hljs-built_in">push</span>(x);<br>sum[pA]=sum[pA<span class="hljs-number">-1</span>]+A[pA];<br>f[pA] = <span class="hljs-built_in">max</span>(f[pA<span class="hljs-number">-1</span>],sum[pA]);<br></code></pre></td></tr></table></figure>
<h3 id="三、单调栈"><a href="#三、单调栈" class="headerlink" title="三、单调栈"></a>三、单调栈</h3><p>单调栈算法：时间复杂度<code>O(N)</code>，处理问题思想在于 <strong>_及时排除不可能的选项，保持策略集合的高度有效性和秩序性_</strong><br>应用：需要维护一个单调的序列并且可以不断从一端插入或删除<br>典例：<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210081928282.png" alt=""><br>思路分析:<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210081937079.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 数组模拟栈：往往更快一些</span><br>a[n+<span class="hljs-number">1</span>] = p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// p为栈顶位置，初始为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<br>&#123;<br>	<span class="hljs-keyword">if</span>(a[i] &gt; s[p])&#123; <span class="hljs-comment">// 矩形高度大于栈顶高度时直接进栈</span><br>		s[++p] = a[i];<br>		w[p] = <span class="hljs-number">1</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// 否则依次比较、寻找不高于当前矩形的位置</span><br>		<span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(s[p] &gt; a[i])&#123;<br>			width += w[p];<span class="hljs-comment">// 宽度叠加</span><br>			<span class="hljs-comment">// 这里s[p]是当前栈顶的高度值，ans记录最终的最大值</span><br>			ans = <span class="hljs-built_in">max</span>(ans, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)width*s[p]); <br>			p--;<br>		&#125;<br>		<span class="hljs-comment">// 更新栈，基于当前栈顶位置</span><br>		s[++p] = a[i],w[p] = width + <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>非连通图生成森林</title>
    <url>/2022/10/30/%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<h3 id="一、深度优先生成森林"><a href="#一、深度优先生成森林" class="headerlink" title="一、深度优先生成森林"></a>一、深度优先生成森林</h3><p>本节实现对非连通图由深度优先搜索生成森林；<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//----------------建立无向图的深度优先生成森林------------------//</span><br><span class="hljs-comment">// 以孩子兄弟链表作生成森林的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> &#123;<br>       TElemType data;<br>       <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>  *firstchild,  *nextsibling;  <br>&#125;CSNode, *CSTree;<br><span class="hljs-function">Status <span class="hljs-title">DFSForest</span><span class="hljs-params">(ALGraph G,  CSTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// 建立无向图G的深度优先生成森林</span><br>    CSTree  p,  q;   <br>    T = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;     <br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)  visite[v] = unvisited;   <span class="hljs-comment">// 节点初始化</span><br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">if</span>(!visite[v])&#123;<br>            p = (CSTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));<br>            *p = &#123;G.Vextices[v].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>            <span class="hljs-keyword">if</span>(!T) T = p;<br>            <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;     <span class="hljs-comment">// 是其他生成树的根</span><br>            q = p;                 <span class="hljs-comment">// q指示当前生成树的根</span><br>            <span class="hljs-built_in">DFSTree</span>(G, v, q);        <span class="hljs-comment">// 建立以p为根的生成树</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DFSTree</span><span class="hljs-params">(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// 从第v个顶点出发深度优先遍历图G，建立以T为根的生成树</span><br>    CSTree p, q;    <br>    visite[v] = visited;    <span class="hljs-comment">// 子树根节点已访问过</span><br>    <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(ArcNode *a=G.Vextices[v].firstarc; a; a=a-&gt;nextarc)&#123;<br>        <span class="hljs-type">int</span> w = a-&gt;adjvex;<br>        <span class="hljs-keyword">if</span>(!visite[w])&#123;    <span class="hljs-comment">// 排除根节点的父代节点</span><br>            p = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));    <span class="hljs-comment">// 为当前遍历的节点申请空间</span><br>            *p = &#123;G.Vextices[w].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;; <br>            <span class="hljs-keyword">if</span>(first) &#123;<br>                T-&gt;firstchild = p;     <span class="hljs-comment">// 找到根节点的第一个孩子 </span><br>                first = <span class="hljs-literal">false</span>; <br>            &#125;<br>            <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;    <span class="hljs-comment">// 其他孩子节点作为上一节点的右兄弟节点</span><br>            q = p;                      <span class="hljs-comment">// 更新上一节点</span><br>            <span class="hljs-built_in">DFSTree</span>(G, w, q);           <span class="hljs-comment">// 递归生成以q为根节点的子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><br>注解：<br><code>DFSForest()</code>函数：</p>
<ul>
<li>通过对所有节点遍历，如果节点未被访问过，申请节点空间，进行赋值存储；</li>
<li><code>T</code>指向整个森林的根节点，<code>DFSTree()</code>函数为连通子图生成一棵树，从一个连通子图中的一个节点进行深度优先搜索一定会遍历该连通子图中所有的节点；</li>
<li>因此对其他未被访问过的节点即是另一个连通子图上的节点，再次循环，将其连接在<code>q</code>(指向上一棵树的根节点)的兄弟节点；      </li>
<li><p>总体而言，<code>DFSForest()</code>函数是将各个连通子图转换成一棵树，再串联成森林；<br><code>DFSTree()</code>函数：</p>
</li>
<li><p>通过邻接点遍历，设置第一次访问(除了父代节点)为孩子节点，其余邻接点均通过<code>q</code>记录上一个兄弟置于右兄弟位置上；</p>
</li>
<li><p>深度优先的体现：对当前节点的每一个邻接点，再次进行递归生成树，优先保证加深度而非加宽度(即优先遍历孩子节点而非优先遍历兄弟节点)；</p>
<h3 id="二、广度优先生成森林"><a href="#二、广度优先生成森林" class="headerlink" title="二、广度优先生成森林"></a>二、广度优先生成森林</h3><p>本节实现对非连通图由广度优先搜索生成森林；    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//----------------建立无向图的广度优先生成森林------------------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QElem</span> &#123;        <span class="hljs-comment">// 用于广度优先生成树中元素结构</span><br>       CSTree  node;<br>       <span class="hljs-type">int</span> v;  <br>&#125;QElem;<br><span class="hljs-function">Status <span class="hljs-title">BFSForest</span><span class="hljs-params">(ALGraph G,  CSTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// 建立无向图G的广度优先生成森林</span><br>    CSTree  p,  q;   <br>    T = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;     <br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)  visite[v] = unvisited;   <span class="hljs-comment">// 节点初始化</span><br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">if</span>(!visite[v])&#123;<br>            p = (CSTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));<br>            *p = &#123;G.Vextices[v].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>            <span class="hljs-keyword">if</span>(!T) T = p;<br>            <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;     <span class="hljs-comment">// 是其他生成树的根</span><br>            q = p;                 <span class="hljs-comment">// q指示当前生成树的根</span><br>            <span class="hljs-built_in">BFSTree</span>(G, v, q);        <span class="hljs-comment">// 建立以p为根的生成树</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">BFSTree</span><span class="hljs-params">(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 处理根节点</span><br>    queue&lt;QElem&gt; Q; Q.<span class="hljs-built_in">push</span>(&#123;T, v&#125;); visite[v]=visited; <br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>        QElem e = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>        CSTree q = e.node;<br>        first = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 标记q节点的第一个孩子</span><br>        <span class="hljs-comment">// 在邻接表中搜寻当前节点未访问过的节点</span><br>        <span class="hljs-keyword">for</span>(ArcNode *a=G.Vextices[e.v].firstarc;  a;  a=a-&gt;nextarc)&#123;<br>            <span class="hljs-type">int</span> w = a-&gt;adjvex;<br>            <span class="hljs-keyword">if</span>(!visite[w])&#123;<br>                CSTree p = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));<br>                *p = &#123;G.Vextices[w].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>                Q.<span class="hljs-built_in">push</span>(&#123;p, w&#125;);visite[w] = visited;<br><br>                <span class="hljs-keyword">if</span>(first)&#123;<br>                    q-&gt;firstchild = p;  <br>                    first = <span class="hljs-literal">false</span>; <br>                &#125;<br>                <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;<br>                q = p;   <span class="hljs-comment">// 更新上一节点==&gt;指向上一兄弟</span><br>            &#125;<span class="hljs-comment">//if</span><br>        &#125;<span class="hljs-comment">//for</span><br>    &#125;<span class="hljs-comment">//while</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注解：</p>
</li>
<li><p><code>DFSForest()</code>函数同理，而<code>BFSTree()</code>函数通过队列对根节点未被访问过的邻接点不断扩展；</p>
</li>
<li>广度优先的体现：对每一个从队列取出的当前节点扩展所有邻接点，即遍历构建除根节点外的其他所有孩子节点；</li>
<li>因此生成的森林中按照层序遍历，每一层都是尽量多节点的；<br>综合后的代码：(其中<code>ADL.h</code>是图的存储结构表示中给出的邻接表与逆邻接表表示方式)        <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;ADL.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//-------------建立无向图的生成森林------------------//</span><br><span class="hljs-comment">// 以孩子兄弟链表作生成森林的存储结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TElemType string</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_Vertex_Num 20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;unvisited, visited&#125;VisitIf;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> &#123;<br>       TElemType data;<br>       <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>  *firstchild,  *nextsibling;  <br>&#125;CSNode, *CSTree;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QElem</span> &#123;        <span class="hljs-comment">// 用于广度优先生成树中元素结构</span><br>       CSTree  node;<br>       <span class="hljs-type">int</span> v;  <br>&#125;QElem;<br><br>VisitIf visite[Max_Vertex_Num];<br><br><span class="hljs-comment">//-------------------------生成森林函数---------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">CreateForest</span><span class="hljs-params">(ALGraph G,  CSTree &amp;T, Status(*CreateTree)(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T))</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">DFSTree</span><span class="hljs-params">(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T)</span></span>;   <span class="hljs-comment">// 深度优先</span><br><span class="hljs-function">Status <span class="hljs-title">BFSTree</span><span class="hljs-params">(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T)</span></span>;   <span class="hljs-comment">// 广度优先</span><br><span class="hljs-comment">//--------------------生成森林的遍历-------------------------//</span><br><span class="hljs-function">Status <span class="hljs-title">CSFPreRootOrder</span><span class="hljs-params">(CSTree T, Status(*Visit)(TElemType e))</span></span>;     <span class="hljs-comment">// 先根遍历</span><br><span class="hljs-function">Status <span class="hljs-title">CSFPostRootOrder</span><span class="hljs-params">(CSTree T, Status(*Visit)(TElemType e))</span></span>;		<span class="hljs-comment">// 后根遍历</span><br><span class="hljs-function">Status <span class="hljs-title">LevelOrderTraverse</span><span class="hljs-params">(CSTree T, Status(*Visit)(TElemType e))</span></span>;     <span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">TreeTransOperator</span><span class="hljs-params">(TElemType e)</span></span>;    <span class="hljs-comment">// 二叉树遍历算子</span><br><span class="hljs-function">Status <span class="hljs-title">ForestPrint</span><span class="hljs-params">(CSTree T)</span></span>;       <span class="hljs-comment">// 森林输出函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ALGraph G, GR;<br>    <span class="hljs-built_in">CreateGraph</span>(G, GR);<br>    CSTree DFST, BFST;<br>    <span class="hljs-built_in">CreateForest</span>(G, DFST, DFSTree);<br>    <span class="hljs-built_in">CreateForest</span>(G, BFST, BFSTree);<br>    <span class="hljs-built_in">GraphPrint</span>(G, GR);<br>    cout &lt;&lt; <span class="hljs-string">&quot;------------------------CS_Forest DFS Traverse-------------------------\n&quot;</span>;<br>    <span class="hljs-built_in">ForestPrint</span>(DFST);<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;------------------------CS_Forest BFS Traverse-------------------------\n&quot;</span>;<br>    <span class="hljs-built_in">ForestPrint</span>(BFST);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateForest</span><span class="hljs-params">(ALGraph G,  CSTree &amp;T, Status(*CreateTree)(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T))</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// 建立无向图G的生成森林</span><br>    CSTree  p,  q;   <br>    T = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;     <br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)  visite[v] = unvisited;   <span class="hljs-comment">// 节点初始化</span><br>    <span class="hljs-built_in">inp</span>(v,<span class="hljs-number">0</span>,G.vexnum<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">if</span>(!visite[v])&#123;<br>            p = (CSTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));<br>            *p = &#123;G.Vextices[v].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>            <span class="hljs-keyword">if</span>(!T) T = p;<br>            <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;     <span class="hljs-comment">// 是其他生成树的根</span><br>            q = p;                 <span class="hljs-comment">// q指示当前生成树的根</span><br>            <span class="hljs-built_in">CreateTree</span>(G, v, q);        <span class="hljs-comment">// 建立以p为根的生成树</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//-----------深度优先生成森林------------//</span><br><span class="hljs-function">Status <span class="hljs-title">DFSTree</span><span class="hljs-params">(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// 从第v个顶点出发深度优先遍历图G，建立以T为根的生成树</span><br>    CSTree p, q;    <br>    visite[v] = visited;    <span class="hljs-comment">// 子树根节点已访问过</span><br>    <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(ArcNode *a=G.Vextices[v].firstarc; a; a=a-&gt;nextarc)&#123;<br>        <span class="hljs-type">int</span> w = a-&gt;adjvex;<br>        <span class="hljs-keyword">if</span>(!visite[w])&#123;    <span class="hljs-comment">// 排除根节点的父代节点</span><br>            p = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));    <span class="hljs-comment">// 为当前遍历的节点申请空间</span><br>            *p = &#123;G.Vextices[w].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;; <br>            <span class="hljs-keyword">if</span>(first) &#123;<br>                T-&gt;firstchild = p;     <span class="hljs-comment">// 找到根节点的第一个孩子 </span><br>                first = <span class="hljs-literal">false</span>; <br>            &#125;<br>            <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;    <span class="hljs-comment">// 其他孩子节点作为上一节点的右兄弟节点</span><br>            q = p;                      <span class="hljs-comment">// 更新上一节点</span><br>            <span class="hljs-built_in">DFSTree</span>(G, w, q);           <span class="hljs-comment">// 递归生成以q为根节点的子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//-----------广度优先生成森林------------//</span><br><span class="hljs-function">Status <span class="hljs-title">BFSTree</span><span class="hljs-params">(ALGraph G,  <span class="hljs-type">int</span> v,  CSTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 处理根节点</span><br>    queue&lt;QElem&gt; Q; Q.<span class="hljs-built_in">push</span>(&#123;T, v&#125;); visite[v]=visited; <br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>        QElem e = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>        CSTree q = e.node;<br>        first = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 标记q节点的第一个孩子</span><br>        <span class="hljs-comment">// 在邻接表中搜寻当前节点未访问过的节点</span><br>        <span class="hljs-keyword">for</span>(ArcNode *a=G.Vextices[e.v].firstarc;  a;  a=a-&gt;nextarc)&#123;<br>            <span class="hljs-type">int</span> w = a-&gt;adjvex;<br>            <span class="hljs-keyword">if</span>(!visite[w])&#123;<br>                CSTree p = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));<br>                *p = &#123;G.Vextices[w].data, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>                Q.<span class="hljs-built_in">push</span>(&#123;p, w&#125;);visite[w] = visited;<br><br>                <span class="hljs-keyword">if</span>(first)&#123;<br>                    q-&gt;firstchild = p;  <br>                    first = <span class="hljs-literal">false</span>; <br>                &#125;<br>                <span class="hljs-keyword">else</span> q-&gt;nextsibling = p;<br>                q = p;   <span class="hljs-comment">// 更新上一节点==&gt;指向上一兄弟</span><br>            &#125;<span class="hljs-comment">//if</span><br>        &#125;<span class="hljs-comment">//for</span><br>    &#125;<span class="hljs-comment">//while</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">TreeTransOperator</span><span class="hljs-params">(TElemType e)</span>    <span class="hljs-comment">// 二叉树遍历算子</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对数据元素操作的应用函数</span><br>    cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CSFPreRootOrder</span><span class="hljs-params">(CSTree T, Status(*Visit)(TElemType e))</span>    <span class="hljs-comment">// 前根遍历</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>	<span class="hljs-built_in">Visit</span>(T-&gt;data);<br>	<span class="hljs-built_in">CSFPreRootOrder</span>(T-&gt;firstchild, Visit);<br>	<span class="hljs-built_in">CSFPreRootOrder</span>(T-&gt;nextsibling, Visit);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">CSFPostRootOrder</span><span class="hljs-params">(CSTree T, Status(*Visit)(TElemType e))</span>		<span class="hljs-comment">// 后根遍历</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>	<span class="hljs-built_in">CSFPostRootOrder</span>(T-&gt;firstchild, Visit);<br>	<span class="hljs-built_in">Visit</span>(T-&gt;data);<br>	<span class="hljs-built_in">CSFPostRootOrder</span>(T-&gt;nextsibling, Visit);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">LevelOrderTraverse</span><span class="hljs-params">(CSTree T, Status(*Visit)(TElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This is an empty tree.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>	queue&lt;CSNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, width = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        CSTree P;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,width<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>                P = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>                q.<span class="hljs-built_in">push</span>(P);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(P-&gt;nextsibling)&#123;<br>                q.<span class="hljs-built_in">push</span>(P-&gt;nextsibling);<br>                P = P-&gt;nextsibling;<br>            &#125;<br>        &#125;<br><br>        width = q.<span class="hljs-built_in">size</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Nodes number of the current layer: &quot;</span> &lt;&lt; width &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,width<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>                P = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-built_in">Visit</span>(P-&gt;data);<br>            <span class="hljs-keyword">if</span>(P-&gt;firstchild) q.<span class="hljs-built_in">push</span>(P-&gt;firstchild);<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ForestPrint</span><span class="hljs-params">(CSTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    CSTree P = T;<br>    <span class="hljs-keyword">while</span>(T)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------Subtree &quot;</span> &lt;&lt; i++ &lt;&lt;<span class="hljs-string">&quot;------------------\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CS_Forest First root Traverse:\n&quot;</span>;<br>        <span class="hljs-built_in">TreeTransOperator</span>(T-&gt;data);<br>        <span class="hljs-built_in">CSFPreRootOrder</span>(T-&gt;firstchild, TreeTransOperator);     <span class="hljs-comment">// 等于二叉树中先序</span><br>        <br>        cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;CS_Forest Post root Traverse:\n&quot;</span>;<br>        <span class="hljs-built_in">CSFPostRootOrder</span>(T-&gt;firstchild, TreeTransOperator);    <span class="hljs-comment">// 等于二叉树中中序</span><br>        <span class="hljs-built_in">TreeTransOperator</span>(T-&gt;data);<br>        cout &lt;&lt; endl;<br>        T = T-&gt;nextsibling;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;CS_Forest Level Traverse:\n&quot;</span>;<br>    <span class="hljs-built_in">LevelOrderTraverse</span>(P, TreeTransOperator);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
给出一个算例：    <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):</span><br><span class="hljs-comment">13 13 0</span><br><span class="hljs-comment">Input Graph Node Sign:</span><br><span class="hljs-comment">A B C D E F G H I J K L M</span><br><span class="hljs-comment">Input two vertices of the edges:</span><br><span class="hljs-comment">A B </span><br><span class="hljs-comment">A C</span><br><span class="hljs-comment">A F</span><br><span class="hljs-comment">A L</span><br><span class="hljs-comment">L J</span><br><span class="hljs-comment">L M</span><br><span class="hljs-comment">J M</span><br><span class="hljs-comment">B M</span><br><span class="hljs-comment">D E</span><br><span class="hljs-comment">G H</span><br><span class="hljs-comment">G K</span><br><span class="hljs-comment">G I</span><br><span class="hljs-comment">H K</span><br><span class="hljs-comment">----------------Output Graph Information-----------------</span><br><span class="hljs-comment">Graph Kind: undirected graph</span><br><span class="hljs-comment">Vextices number: 13   Arcs number: 13</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">----------------Vextices Vector Information----------------</span><br><span class="hljs-comment">The Nodes Path:</span><br><span class="hljs-comment">Out path: A-&lt;-[1]-&gt;-B  A-&lt;-[1]-&gt;-C  A-&lt;-[1]-&gt;-F  A-&lt;-[1]-&gt;-L</span><br><span class="hljs-comment">A  Vextice Degree: 4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: B-&lt;-[1]-&gt;-A  B-&lt;-[1]-&gt;-M</span><br><span class="hljs-comment">B  Vextice Degree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: C-&lt;-[1]-&gt;-A</span><br><span class="hljs-comment">C  Vextice Degree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: D-&lt;-[1]-&gt;-E</span><br><span class="hljs-comment">D  Vextice Degree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: E-&lt;-[1]-&gt;-D</span><br><span class="hljs-comment">E  Vextice Degree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: F-&lt;-[1]-&gt;-A</span><br><span class="hljs-comment">F  Vextice Degree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: G-&lt;-[1]-&gt;-H  G-&lt;-[1]-&gt;-K  G-&lt;-[1]-&gt;-I</span><br><span class="hljs-comment">G  Vextice Degree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: H-&lt;-[1]-&gt;-G  H-&lt;-[1]-&gt;-K</span><br><span class="hljs-comment">H  Vextice Degree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: I-&lt;-[1]-&gt;-G</span><br><span class="hljs-comment">I  Vextice Degree: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: J-&lt;-[1]-&gt;-L  J-&lt;-[1]-&gt;-M  </span><br><span class="hljs-comment">J  Vextice Degree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: K-&lt;-[1]-&gt;-G  K-&lt;-[1]-&gt;-H</span><br><span class="hljs-comment">K  Vextice Degree: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: L-&lt;-[1]-&gt;-A  L-&lt;-[1]-&gt;-J  L-&lt;-[1]-&gt;-M</span><br><span class="hljs-comment">L  Vextice Degree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Out path: M-&lt;-[1]-&gt;-L  M-&lt;-[1]-&gt;-J  M-&lt;-[1]-&gt;-B</span><br><span class="hljs-comment">M  Vextice Degree: 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">------------------------CS_Forest DFS Traverse-------------------------</span><br><span class="hljs-comment">--------------------Subtree 1------------------</span><br><span class="hljs-comment">CS_Forest First root Traverse:</span><br><span class="hljs-comment">A B M L J C F </span><br><span class="hljs-comment">CS_Forest Post root Traverse:</span><br><span class="hljs-comment">J L M B C F A</span><br><span class="hljs-comment">--------------------Subtree 2------------------</span><br><span class="hljs-comment">CS_Forest First root Traverse:</span><br><span class="hljs-comment">D E</span><br><span class="hljs-comment">CS_Forest Post root Traverse:</span><br><span class="hljs-comment">E D</span><br><span class="hljs-comment">--------------------Subtree 3------------------</span><br><span class="hljs-comment">CS_Forest First root Traverse:</span><br><span class="hljs-comment">G H K I</span><br><span class="hljs-comment">CS_Forest Post root Traverse:</span><br><span class="hljs-comment">K H I G</span><br><span class="hljs-comment">CS_Forest Level Traverse:</span><br><span class="hljs-comment">Nodes number of the current layer: 3 A D G</span><br><span class="hljs-comment">Nodes number of the current layer: 6 B C F E H I</span><br><span class="hljs-comment">Nodes number of the current layer: 2 M K</span><br><span class="hljs-comment">Nodes number of the current layer: 1 L</span><br><span class="hljs-comment">Nodes number of the current layer: 1 J</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">------------------------CS_Forest BFS Traverse-------------------------</span><br><span class="hljs-comment">--------------------Subtree 1------------------</span><br><span class="hljs-comment">CS_Forest First root Traverse:</span><br><span class="hljs-comment">A B M C F L J</span><br><span class="hljs-comment">CS_Forest Post root Traverse:</span><br><span class="hljs-comment">M B C F J L A</span><br><span class="hljs-comment">--------------------Subtree 2------------------</span><br><span class="hljs-comment">CS_Forest First root Traverse:</span><br><span class="hljs-comment">D E</span><br><span class="hljs-comment">CS_Forest Post root Traverse:</span><br><span class="hljs-comment">E D</span><br><span class="hljs-comment">--------------------Subtree 3------------------</span><br><span class="hljs-comment">CS_Forest First root Traverse:</span><br><span class="hljs-comment">G H K I</span><br><span class="hljs-comment">CS_Forest Post root Traverse:</span><br><span class="hljs-comment">H K I G</span><br><span class="hljs-comment">CS_Forest Level Traverse:</span><br><span class="hljs-comment">Nodes number of the current layer: 3 A D G</span><br><span class="hljs-comment">Nodes number of the current layer: 8 B C F L E H K I</span><br><span class="hljs-comment">Nodes number of the current layer: 2 M J</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/2022/12/09/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>本文主要介绍四种插入排序算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inp(i,x,y) for(i=x;i&lt;=y;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dep(i,x,y) for(i=x;i&gt;=y;i--)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Status bool</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_time_num 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KeyType int </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InfoType string</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LT(x,y) (x &lt; y ? 1:0)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    KeyType key;         <span class="hljs-comment">//关键字类型</span><br>    InfoType info;       <span class="hljs-comment">// 数据项</span><br>&#125;ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType r[MAXSIZE+<span class="hljs-number">1</span>];    <span class="hljs-comment">// r[0]作哨兵</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;            <span class="hljs-comment">// 顺序表类型</span><br><span class="hljs-comment">// 表插入排序数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    KeyType key;    <br>    <span class="hljs-type">int</span> next;<br>&#125;SLNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SLNode r[MAXSIZE+<span class="hljs-number">1</span>];    <span class="hljs-comment">// 0号单元为表头结点</span><br>    <span class="hljs-type">int</span> length;      <span class="hljs-comment">// 链表当前长度</span><br>&#125;SLinkList;       <span class="hljs-comment">// 静态链表类型</span><br><br><span class="hljs-comment">//----------------直接插入排序--------------</span><br><span class="hljs-function">Status <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList L)</span></span>;<br><span class="hljs-comment">//----------------折半插入排序--------------</span><br><span class="hljs-function">Status <span class="hljs-title">BInsertSort</span><span class="hljs-params">(SqList L)</span></span>;<br><span class="hljs-comment">//----------------表插入排序--------------</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsertSort</span><span class="hljs-params">(SLinkList &amp;SL)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">Arrange</span><span class="hljs-params">(SLinkList &amp;SL)</span></span>;   <span class="hljs-comment">// 重排</span><br><span class="hljs-comment">//-----------------希尔排序--------------</span><br><span class="hljs-function">Status <span class="hljs-title">ShellInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dk)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span>* dlta,<span class="hljs-type">int</span> t)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>    SqList L;<br>    cin &gt;&gt; L.length;<br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,L.length) cin &gt;&gt; L.r[i].key;<br><br>    <span class="hljs-comment">// 进行排序</span><br>    <span class="hljs-built_in">InsertSort</span>(L);<br>    <span class="hljs-built_in">BInsertSort</span>(L);<br>    <span class="hljs-comment">// 希尔排序增量数组</span><br>    <span class="hljs-type">int</span>* dlta = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[Max_time_num];<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">0</span>, Max_time_num)<br>        <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">2</span>) dlta[i] = i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>) dlta[i] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">else</span> dlta[i] = <span class="hljs-number">9</span>;<br>    <br>    <span class="hljs-built_in">ShellSort</span>(L, dlta, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 表排序</span><br>    SLinkList SL;<br>    cin &gt;&gt; SL.length;<br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,SL.length)&#123;<br>        cin &gt;&gt; SL.r[i].key;<br>    &#125;<br>    SL.r[i].key = INT_MAX;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ListInsertSort</span>(SL))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;List InsertSort Result:\n&quot;</span>;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,SL.length)&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;&lt;&quot;</span> &lt;&lt; SL.r[i].key &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; SL.r[i].next &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Rearrange Records Result:\n&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Arrange</span>(SL))&#123;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,SL.length)&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;&lt;&quot;</span> &lt;&lt; SL.r[i].key &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; SL.r[i].next &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] dlta;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 对顺序表 L 进行直接插入排序</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">2</span>, L.length)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">LT</span>(L.r[i].key, L.r[i<span class="hljs-number">-1</span>].key))&#123;<br>            L.r[<span class="hljs-number">0</span>] = L.r[i];     <span class="hljs-comment">// 复制为哨兵</span><br>            L.r[i] = L.r[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-2</span>;<span class="hljs-built_in">LT</span>(L.r[<span class="hljs-number">0</span>].key, L.r[j].key);j--)<br>                L.r[j+<span class="hljs-number">1</span>] = L.r[j];    <span class="hljs-comment">// 记录后移</span><br>            L.r[j+<span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];       <span class="hljs-comment">// 插入正确位置j+1</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;InsertSort Result:\n&quot;</span>;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,L.length)<br>            cout &lt;&lt; L.r[i].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">BInsertSort</span><span class="hljs-params">(SqList L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对顺序表L作折半插入排序</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">2</span>, L.length)&#123;<br>        L.r[<span class="hljs-number">0</span>] = L.r[i];    <span class="hljs-comment">// 哨兵</span><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>, high = i - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 默认前i个位置已经排好序</span><br>        <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>            <span class="hljs-type">int</span> m = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">LT</span>(L.r[<span class="hljs-number">0</span>].key, L.r[m].key)) high = m<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> low = m + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-comment">// 结束条件是high &lt; low 退出时待插入位置即是high之后 low之前</span><br>        <span class="hljs-built_in">dep</span>(j,i<span class="hljs-number">-1</span>,high+<span class="hljs-number">1</span>) L.r[j+<span class="hljs-number">1</span>] = L.r[j];     <span class="hljs-comment">// 记录后移</span><br>        L.r[high + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];     <span class="hljs-comment">// high指向待插位置之前</span><br>        <span class="hljs-comment">//等价于</span><br>        <span class="hljs-comment">/* dep(j,i-1,low) L.r[j+1] = L.r[j];     // 记录后移</span><br><span class="hljs-comment">        L.r[low] = L.r[0];*/</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Binary InsertSort Result:\n&quot;</span>;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,L.length)<br>            cout &lt;&lt; L.r[i].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ListInsertSort</span><span class="hljs-params">(SLinkList &amp;SL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化操作</span><br>    SL.r[<span class="hljs-number">0</span>].next = <span class="hljs-number">1</span>;SL.r[<span class="hljs-number">1</span>].next = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">2</span>, SL.length)&#123;<br>        <span class="hljs-comment">// j 指向前一节点</span><br>        j = <span class="hljs-number">0</span>; k = SL.r[j].next;<br>        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">LT</span>(SL.r[k].key, SL.r[i].key))&#123;<br>            j = k;k = SL.r[j].next;<br>        &#125;<br>        SL.r[i].next = SL.r[j].next;   <span class="hljs-comment">// 移动指针</span><br>        SL.r[j].next = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Arrange</span><span class="hljs-params">(SLinkList &amp;SL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*--------重排记录---------*/</span><br>    <span class="hljs-comment">// 根据静态链表SL中各节点的指针值调整记录位置，使得SL中记录按关键字非递减有序顺序排列</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p = SL.r[<span class="hljs-number">0</span>].next;      <span class="hljs-comment">// p指示第一个记录的当前位置</span><br>    <span class="hljs-built_in">inp</span>(i, <span class="hljs-number">1</span>, SL.length<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-comment">// p指向的是当前待调整的位置，默认前i个位置已经排好序</span><br>        <span class="hljs-comment">// 前i个位置已经定好顺序</span><br>        <span class="hljs-comment">// 当p &lt; i时，待调整元素已经被转移走了，因此需要往后寻找</span><br>        <span class="hljs-keyword">while</span>(p &lt; i) p = SL.r[p].next;<br>        <span class="hljs-type">int</span> q = SL.r[p].next;    <span class="hljs-comment">// 获取尚未调整的下一元素，以防后面处理造成链表中断</span><br>        <span class="hljs-keyword">if</span>(p != i)&#123;   <span class="hljs-comment">// 如果待调元素位置p不是i即第i个记录未到位</span><br>            SLNode temp = SL.r[p];<br>            SL.r[p] = SL.r[i];<br>            SL.r[i] = temp; <br>            SL.r[i].next = p;<br>        &#125;<br>        p = q;     <span class="hljs-comment">// 获取下一待定位元素位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                            <br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span>* dlta, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 按增量序列dlta[0..t-1]对顺序表L进行希尔排序</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">0</span>,t<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">ShellInsert</span>(L, dlta[i]);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shell InsertSort Result:\n&quot;</span>;<br>        <span class="hljs-built_in">inp</span>(i,<span class="hljs-number">1</span>,L.length)<br>            cout &lt;&lt; L.r[i].key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ShellInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">inp</span>(i,dk+<span class="hljs-number">1</span>,L.length)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">LT</span>(L.r[i].key, L.r[i-dk].key))&#123;<br>            <span class="hljs-comment">// 在不同增量下存在按增量前溯时不能到0位置，因此不能设置哨兵</span><br>            L.r[<span class="hljs-number">0</span>] = L.r[i];         <span class="hljs-comment">// 暂存在r[0]位置</span><br>            <span class="hljs-keyword">for</span>(j=i-dk;j&gt;<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">LT</span>(L.r[<span class="hljs-number">0</span>].key, L.r[j].key); j-=dk)<br>                <span class="hljs-comment">// 子序列插入排序时子序列前溯</span><br>                L.r[j+dk] = L.r[j];   <span class="hljs-comment">// 记录后移</span><br>            L.r[j+dk] = L.r[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>给出一个算例演示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">10 </span><br><span class="hljs-comment">49 38 65 97 76 13 27 49 55 4 </span><br><span class="hljs-comment">InsertSort Result:</span><br><span class="hljs-comment">4 13 27 38 49 49 55 65 76 97 </span><br><span class="hljs-comment">Binary InsertSort Result:    </span><br><span class="hljs-comment">4 13 27 38 49 49 55 65 76 97 </span><br><span class="hljs-comment">Shell InsertSort Result:     </span><br><span class="hljs-comment">4 13 27 38 49 49 55 65 76 97 </span><br><span class="hljs-comment">10 </span><br><span class="hljs-comment">49 38 65 97 76 13 27 49 55 4</span><br><span class="hljs-comment">List InsertSort Result:</span><br><span class="hljs-comment">&lt;0, 10&gt; &lt;49, 9&gt; &lt;38, 8&gt; &lt;65, 5&gt; &lt;97, 0&gt; &lt;76, 4&gt; &lt;13, 7&gt; &lt;27, 2&gt; &lt;49, 1&gt; &lt;55, 3&gt; &lt;4, 6&gt; </span><br><span class="hljs-comment">Rearrange Records Result:</span><br><span class="hljs-comment">&lt;4, 10&gt; &lt;13, 6&gt; &lt;27, 7&gt; &lt;38, 6&gt; &lt;49, 8&gt; &lt;49, 10&gt; &lt;55, 9&gt; &lt;65, 9&gt; &lt;76, 4&gt; &lt;97, 0&gt;  </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵转置</title>
    <url>/2022/10/10/%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="稀疏矩阵转置"><a href="#稀疏矩阵转置" class="headerlink" title="稀疏矩阵转置"></a>稀疏矩阵转置</h3><p>本文采用顺序存储结构的三元组表压缩存储稀疏矩阵，并基于此数据结构对稀疏矩阵进行转置，介绍两种转置处理方法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//---------------稀疏矩阵的三元组顺序表存储表示-------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 500</span><br><span class="hljs-comment">// 抽象数据类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    ElemType value;<br>&#125;Triple;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Triple data[MAXSIZE + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> rows, cols, nums;  <span class="hljs-comment">// 行列和非零元数 </span><br>&#125;TSMatrix;<br><br><br><span class="hljs-function">Status <span class="hljs-title">TransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; T)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">FastTransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; FT)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixRead</span><span class="hljs-params">(TSMatrix&amp; M)</span></span>;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixPrint</span><span class="hljs-params">(TSMatrix M)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TSMatrix M, T, FT;<br>    <span class="hljs-built_in">TSMatrixRead</span>(M);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before Transpose Matrix:\n&quot;</span>;<br>    <span class="hljs-built_in">TSMatrixPrint</span>(M);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After Transpose Matrix:\n&quot;</span>;<br>    <span class="hljs-built_in">TransposeMatrix</span>(M, T);<br>    <span class="hljs-built_in">TSMatrixPrint</span>(T);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After FastTranspose Matrix:\n&quot;</span>;<br>    <span class="hljs-built_in">FastTransposeMatrix</span>(M, FT);<br>    <span class="hljs-built_in">TSMatrixPrint</span>(FT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">TransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br>    T.rows = M.cols; T.cols = M.rows; T.nums = M.nums;<br>    <span class="hljs-keyword">if</span> (T.nums) &#123;    <span class="hljs-comment">// 如果矩阵非空</span><br>        <span class="hljs-type">int</span> q = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">1</span>; col &lt;= M.cols; col++) &#123;  <span class="hljs-comment">// 指定循环M列序保证T矩阵的行主序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= M.nums; p++) &#123;  <span class="hljs-comment">// 搜寻M中当前列元素</span><br>                <span class="hljs-comment">// M又是按照行主序存储的，所以M每一列的列序即是T中每一行的行序</span><br>                <span class="hljs-keyword">if</span> (M.data[p].j == col) &#123;<br>                    T.data[q].i = M.data[p].j;<br>                    T.data[q].j = M.data[p].i;<br>                    T.data[q].value = M.data[p].value;<br>                    q++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">FastTransposeMatrix</span><span class="hljs-params">(TSMatrix M, TSMatrix&amp; FT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 快速转置算法</span><br>    <span class="hljs-comment">// 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br>    FT.rows = M.cols; FT.cols = M.rows; FT.nums = M.nums;<br>    <span class="hljs-keyword">if</span> (FT.nums) &#123;  <span class="hljs-comment">// 矩阵非空</span><br>        <span class="hljs-type">int</span>* num = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[M.cols + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>* cpot = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[M.cols + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 记录矩阵M中每一列的元素个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">1</span>; col &lt;= M.cols; col++) num[col] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= M.nums; ++t) ++num[M.data[t].j];<br>        <span class="hljs-comment">// 记录矩阵M中，每一列的首非零元在三元组表中的下标位置</span><br>        cpot[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 默认第一个元素从首位置开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">2</span>; col &lt;= M.cols; col++) cpot[col] = cpot[col - <span class="hljs-number">1</span>] + num[col - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 累加定位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= M.nums; p++) &#123;<br>            <span class="hljs-type">int</span> col = M.data[p].j;<br>            <span class="hljs-type">int</span> q = cpot[col];  <span class="hljs-comment">// 提取位置编号</span><br>            <span class="hljs-comment">// 元素放置</span><br>            FT.data[q].i = M.data[p].j;<br>            FT.data[q].j = M.data[p].i;<br>            FT.data[q].value = M.data[p].value;<br>            <span class="hljs-comment">// 后移控制=====&gt;填充三元组表</span><br>            cpot[col]++;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixRead</span><span class="hljs-params">(TSMatrix&amp; M)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix rows, cols and nums:\n&quot;</span>;<br>    cin &gt;&gt; M.rows &gt;&gt; M.cols &gt;&gt; M.nums;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input Matrix elements:\n&quot;</span>;<br>    <span class="hljs-comment">// 这里默认输入是行主序的</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M.nums; i++) &#123;<br>        cin &gt;&gt; M.data[i].i &gt;&gt; M.data[i].j &gt;&gt; M.data[i].value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">TSMatrixPrint</span><span class="hljs-params">(TSMatrix M)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 由三元组表输出标准矩阵</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M.rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= M.cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (M.data[cnt].i == i &amp;&amp; M.data[cnt].j == j)<br>                cout &lt;&lt; M.data[cnt++].value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里给出一个演示算例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input Matrix rows, cols and nums:</span><br><span class="hljs-comment">3 4 4</span><br><span class="hljs-comment">Input Matrix elements:</span><br><span class="hljs-comment">1 1 3</span><br><span class="hljs-comment">1 4 5</span><br><span class="hljs-comment">2 2 -1</span><br><span class="hljs-comment">3 1 2</span><br><span class="hljs-comment">Before Transpose Matrix:</span><br><span class="hljs-comment">3 0 0 5</span><br><span class="hljs-comment">0 -1 0 0</span><br><span class="hljs-comment">2 0 0 0</span><br><span class="hljs-comment">After Transpose Matrix:</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">0 -1 0</span><br><span class="hljs-comment">0 0 0</span><br><span class="hljs-comment">5 0 0</span><br><span class="hljs-comment">After FastTranspose Matrix:</span><br><span class="hljs-comment">3 0 2</span><br><span class="hljs-comment">0 -1 0</span><br><span class="hljs-comment">0 0 0</span><br><span class="hljs-comment">5 0 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>积分学</title>
    <url>/2022/10/24/%E7%A7%AF%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="第八讲-不定积分与定积分的计算"><a href="#第八讲-不定积分与定积分的计算" class="headerlink" title="第八讲 不定积分与定积分的计算"></a>第八讲 不定积分与定积分的计算</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251614821.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251616345.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241955556.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241958615.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210241959118.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210242002681.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210242004790.png" alt=""><br>注解：（式5证明——区间对称性)</p>
<script type="math/tex; mode=display">
\int_a^b\frac{f(x)}{f(x)+f(a+b-x)}dx=\int_b^a\frac{f(a+b-x)}{f(a+b-x)+f(x)}(-dx)</script><script type="math/tex; mode=display">
= \frac{1}{2}\int_a^b\frac{f(x)+f(a+b-x)}{f(x)+f(a+b-x)}dx=\frac{b-a}{2}</script><h2 id="八、典型例题"><a href="#八、典型例题" class="headerlink" title="八、典型例题"></a>八、典型例题</h2><h3 id="8-1-不定积分计算"><a href="#8-1-不定积分计算" class="headerlink" title="8.1 不定积分计算"></a>8.1 不定积分计算</h3><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251604876.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251611655.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251611015.png" alt=""><br>【欧拉变换】<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251619458.png" alt=""><br>【根式换元】<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251623470.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251633845.png" alt=""><br>【分部积分】<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251629358.png" alt=""><br>【三角换元】<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251639570.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251639408.png" alt=""><br>注解：</p>
<script type="math/tex; mode=display">
\int\frac{1}{(1+x^2)^{3/2}}dx = \frac{x}{\sqrt{1+x^2}}</script><p>【构造函数】——凑微分（注意以下两种凑微分相同的方式）<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251649753.png" alt=""><br>【参数方程】——借助参数方程转变为单变量积分<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251659583.png" alt=""><br>注解：最后一道题中需要注意：</p>
<script type="math/tex; mode=display">
1-y^4=(1-y)(1+y+y^2+y3)</script><h3 id="8-2-定积分的计算"><a href="#8-2-定积分的计算" class="headerlink" title="8.2 定积分的计算"></a>8.2 定积分的计算</h3><p>【构造奇偶函数】<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251703854.png" alt=""><br>【区间对称性】<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210251712211.png" alt=""></p>
]]></content>
      <categories>
        <category>数学竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼树</title>
    <url>/2022/10/24/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//------------赫夫曼树和赫夫曼编码的存储表示-----------//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// 赫夫曼树节点</span><br>    <span class="hljs-type">char</span> sign;   <span class="hljs-comment">// 待编码字符</span><br>    <span class="hljs-type">int</span>  weight;     <span class="hljs-comment">//节点值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> parent, lchild, rchild;<br>&#125;HTNode, * HuffmanTree;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;    <span class="hljs-comment">// 动态分配数组存储赫夫曼编码表</span><br>    <span class="hljs-type">char</span> **NodesCode;  <span class="hljs-comment">// 字符对应编码</span><br>    <span class="hljs-type">char</span> *sign;    <span class="hljs-comment">// 字符</span><br>&#125;HuffmanCode;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree HT, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span>&amp; s1, <span class="hljs-type">int</span>&amp; s2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HuffmanCoding</span><span class="hljs-params">(HuffmanTree&amp; HT, HuffmanCode&amp; HC, <span class="hljs-type">int</span>* w, <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HuffmanCodePrint</span><span class="hljs-params">(HuffmanCode HC, <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    HuffmanTree HT;<br>    HuffmanCode HC;<br>    <span class="hljs-type">int</span> n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input the number of chars: &quot;</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> *w = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n]&#123;&#125;;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n]&#123;&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Input n chars in the tuple:(char, weight):\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; s[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-built_in">HuffmanCoding</span>(HT, HC, w, s, n);<br>    <span class="hljs-built_in">HuffmanCodePrint</span>(HC, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree HT, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span>&amp; s1, <span class="hljs-type">int</span>&amp; s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    s1 = s2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++) &#123;<br>        <span class="hljs-keyword">if</span> (HT[i].parent) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!s1) s1 = i;     <span class="hljs-comment">// 保证先有节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!s2) &#123;<br>                <span class="hljs-keyword">if</span> (HT[s1].weight &gt; HT[i].weight) &#123;<br>                    s2 = s1;<br>                    s1 = i;<br>                &#125;<br>                <span class="hljs-keyword">else</span> s2 = i;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (HT[i].weight &lt; HT[s1].weight) &#123;<br>                    s2 = s1;<br>                    s1 = i;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HT[i].weight &lt; HT[s2].weight) &#123;<br>                    s2 = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HuffmanCoding</span><span class="hljs-params">(HuffmanTree&amp; HT, HuffmanCode&amp; HC, <span class="hljs-type">int</span>* w, <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// w存放n个字符的权值，构造赫夫曼树HT，并求出n个字符的赫夫曼编码HC</span><br><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 赫夫曼树的节点数</span><br>    HT = (HuffmanTree)<span class="hljs-built_in">malloc</span>((m + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(HTNode)); <span class="hljs-comment">// 0号单元未用</span><br>    HuffmanTree p = HT;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (p=HT+<span class="hljs-number">1</span>; i &lt;= n; ++i, ++p, ++w, ++s) *p = &#123;*s,*w,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;   <span class="hljs-comment">// 对赫夫曼树叶子节点进行赋值</span><br>    <span class="hljs-keyword">for</span> (; i &lt;= m; i++, p++) *p = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;    <span class="hljs-comment">// 其他节点初始化操作</span><br>    <span class="hljs-keyword">for</span> (i = n + <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;       <span class="hljs-comment">// 建赫夫曼树</span><br>        <span class="hljs-comment">//在HT[1..i-1]选择parent为0且weight最小的两个节点，其序号分别为s1和s2</span><br>        <span class="hljs-type">int</span> s1 = <span class="hljs-number">0</span>, s2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">Select</span>(HT, i - <span class="hljs-number">1</span>, s1, s2);<br>        HT[s1].parent = i; HT[s2].parent = i;   <span class="hljs-comment">// 更新构造</span><br>        HT[i].lchild = s1; HT[i].rchild = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br><br>    <span class="hljs-comment">//--------从叶子到根逆向求每个字符的赫夫曼编码-------------//</span><br>    HC.NodesCode = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">malloc</span>((n + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*)); <span class="hljs-comment">// 分配n个字符编码的头指针向量</span><br>    HC.sign = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((n+<span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-type">char</span>* cd = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));    <span class="hljs-comment">// 分配n个字符求编码的工作空间，最长编码是n-1</span><br>    cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;     <span class="hljs-comment">// 编码结束符</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;   <span class="hljs-comment">// 遍历叶子节点（前n个位置）</span><br>        <span class="hljs-type">int</span> start = n - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 编码结束符位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = i, f = HT[i].parent; f != <span class="hljs-number">0</span>; c = f, f = HT[f].parent)   <span class="hljs-comment">// 从叶子到根逆向求编码</span><br>            <span class="hljs-keyword">if</span> (HT[f].lchild == c) cd[--start] = <span class="hljs-string">&#x27;0&#x27;</span>;   <span class="hljs-comment">// 左孩子定义为0</span><br>            <span class="hljs-keyword">else</span> cd[--start] = <span class="hljs-string">&#x27;1&#x27;</span>;    <span class="hljs-comment">// 右孩子定义为1</span><br>        HC.NodesCode[i] = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((n - start) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));    <span class="hljs-comment">// 为第i个字符编码分配空间</span><br>        HC.sign[i] = HT[i].sign;<br>        <span class="hljs-built_in">strcpy</span>(HC.NodesCode[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(cd);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HuffmanCodePrint</span><span class="hljs-params">(HuffmanCode HC, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Chars Huffmancodes:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cout &lt;&lt; HC.sign[i] &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; HC.NodesCode[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>具体的一个算例演示</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">//-------------Here is a demo---------//</span><br><span class="hljs-comment">Input the number of chars: 8</span><br><span class="hljs-comment">Input n chars in the tuple:(char, weight):</span><br><span class="hljs-comment">A 1   </span><br><span class="hljs-comment">B 2 </span><br><span class="hljs-comment">C 3   </span><br><span class="hljs-comment">D 4 </span><br><span class="hljs-comment">E 5</span><br><span class="hljs-comment">F 6</span><br><span class="hljs-comment">G 7</span><br><span class="hljs-comment">H 8</span><br><span class="hljs-comment">Chars Huffmancodes:</span><br><span class="hljs-comment">A: 11110</span><br><span class="hljs-comment">B: 11111</span><br><span class="hljs-comment">C: 1110</span><br><span class="hljs-comment">D: 100</span><br><span class="hljs-comment">E: 101</span><br><span class="hljs-comment">F: 110</span><br><span class="hljs-comment">G: 00</span><br><span class="hljs-comment">H: 01</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>链表与邻接表</title>
    <url>/2022/10/13/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h3><p><strong>数组模拟双向链表</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-type">int</span> value;<br>	<span class="hljs-type">int</span> prev, next;<br>&#125;node[SIZE];<br><span class="hljs-type">int</span> head, tail, tot;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	tot = <span class="hljs-number">2</span>;    <span class="hljs-comment">//控制节点存储位置</span><br>	head = <span class="hljs-number">1</span>,tail = <span class="hljs-number">2</span>;<br>	node[head].next = tail;<br>	node[tail].prev = head;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 在p点后向链表中插入一个节点</span><br>	q = ++tot;  <span class="hljs-comment">// 向节点数组中申请空间</span><br>	node[q].value = val;<br>	<span class="hljs-comment">// 交接</span><br>	node[node[p].next].prev = q;  <br>	node[q].next = node[p].next;<br>	node[p].next = q;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 移除p节点</span><br>	node[node[p].prev].next = node[p].next;<br>	node[node[p].next].prev = node[p].prev;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(node, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(node));<br>	head = tail = tot = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="二、二叉平衡树"><a href="#二、二叉平衡树" class="headerlink" title="二、二叉平衡树"></a>二、二叉平衡树</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<h3 id="三、邻接表"><a href="#三、邻接表" class="headerlink" title="三、邻接表"></a>三、邻接表</h3><ul>
<li>邻接表：带有索引数组的多个数据链表构成的结构集合；</li>
<li>在这样的结构中存储的数据被分成若干类，每一类的数据构成一个链表；</li>
<li>每一类数据有一个代表元素，成为该类数据对应链表的“表头”；</li>
<li>所有“表头”构成一个表头数组，作为一个可以随机访问的索引；<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210132241493.png" alt=""><br>如上图所示，在插入新节点时，通过表头数组直接索引到对应数据类的链表处，并在链表表头处插入数据。    <h4 id="图论应用"><a href="#图论应用" class="headerlink" title="图论应用"></a>图论应用</h4><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210132244755.png" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 加入有向边(x,y),权值z</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>	ver[++tot] = y, edge[tot] = z;<span class="hljs-comment">// 记录真实数据</span><br>	next[tot] = head[x],head[x] = tot;  <span class="hljs-comment">// 在表头x处插入</span><br>	<span class="hljs-comment">// 通过head[x]索引对应的边，首先将上次head[x]更换next数组值，再次将当前边终点位置更新head[x]</span><br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">// 访问从x出发的所有边</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[x];i;i = next[i])&#123;<br>	<span class="hljs-type">int</span> y = ver[i],z = edge[i];<br>&#125;<br></code></pre></td></tr></table></figure>
注解：<br><code>head</code>与<code>next</code>数组存储<code>ver</code>数组的下标，相当于指针，其中用<code>0</code>表示空；<code>ver</code>数组存储每条边的终点，是真实数据；       </li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序栈</title>
    <url>/2022/10/03/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈的顺序存储表示"><a href="#栈的顺序存储表示" class="headerlink" title="栈的顺序存储表示"></a>栈的顺序存储表示</h2><hr>
<h3 id="1、顺序存储结构"><a href="#1、顺序存储结构" class="headerlink" title="1、顺序存储结构"></a>1、顺序存储结构</h3><p>利用一组地址连续的存储单元<br><strong>顺序栈定义</strong>：   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;Sqstack;<br></code></pre></td></tr></table></figure>
<p>_注：当用数组作为存储结构时，可以用下标代替指针_      </p>
<h3 id="2、基本操作算法描述"><a href="#2、基本操作算法描述" class="headerlink" title="2、基本操作算法描述"></a>2、基本操作算法描述</h3><p>对栈的常用操作做简要描述：      </p>
<ul>
<li><p>栈的初始化     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以初始化容量申请一块连续的内存，<code>S.top=S.base</code>保证<code>top=base</code>时栈空。    </p>
</li>
<li><p>返回栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == S.base)  <span class="hljs-keyword">return</span> ERROR;<br>    e = *(S.base<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>压栈操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>出栈操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>判断栈空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>清空栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用栈空标志进行清空</span><br>    S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>释放栈空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">free</span>(S.base);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3、栈的应用举例"><a href="#3、栈的应用举例" class="headerlink" title="3、栈的应用举例"></a>3、栈的应用举例</h3><h4 id="3-1-数制转换"><a href="#3-1-数制转换" class="headerlink" title="3.1 数制转换"></a>3.1 数制转换</h4><p>十进制数与其他d进制数转换时，一个简单算法原理：<br><code>N = (N div d) X d + N mod d</code>,其中<code>div</code>表示整除操作，<code>mod</code>表示求余操作     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Conversion</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType data;<br>    <span class="hljs-type">int</span> Obj = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; data &gt;&gt; Obj;<br>    <span class="hljs-keyword">while</span>(data)&#123;<br>        <span class="hljs-built_in">Push</span>(S,data % Obj);<br>        data = data/Obj;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">StackEmpty</span>(S))<br>    &#123;<br>        SElemType e;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Pop</span>(S,e)) <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; e;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对于输入的十进制数和目标进制，打印输出目标进制数</span><br>    <span class="hljs-built_in">Conversion</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-行编辑程序"><a href="#3-2-行编辑程序" class="headerlink" title="3.2 行编辑程序"></a>3.2 行编辑程序</h4><p>将用户从键盘输入的符号存入一个输入缓冲区，然后逐行存入用户数据区；这个过程允许用户删除字符，删除整行字符<br>基本操作规则：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 退格符<br>@ 退行符<br>^ 结束符<br></code></pre></td></tr></table></figure>
<p>程序实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackPrint</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    SElemType *mp = S.base;<br>    <span class="hljs-keyword">while</span>(mp != S.top)&#123;<br>        <span class="hljs-built_in">putchar</span>(*mp);<br>        mp++;<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用栈空标志进行清空</span><br>    S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">free</span>(S.base);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-function">Status <span class="hljs-title">LineEdit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构造字符栈</span><br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType ch;<br>    ch = <span class="hljs-built_in">getchar</span>();  <span class="hljs-comment">//从终端接受一个字符</span><br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span>)&#123;<br>        <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            <span class="hljs-keyword">switch</span>(ch)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-built_in">Pop</span>(S,ch);  <span class="hljs-comment">//退字符</span><br>                         <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>:<span class="hljs-built_in">ClearStack</span>(S); <span class="hljs-comment">//退行</span><br>                         <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<span class="hljs-built_in">Push</span>(S,ch); <span class="hljs-comment">//字符入栈</span><br>            &#125;<br>            ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//从终端接受下一个字符</span><br>        &#125;<br>        <span class="hljs-comment">//对缓冲区的一行字符存入数据区，这里只是打印输出</span><br>        <span class="hljs-built_in">StackPrint</span>(S);<br>        <span class="hljs-built_in">ClearStack</span>(S);<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-built_in">DestroyStack</span>(S);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LineEdit</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-3-括号匹配问题"><a href="#3-3-括号匹配问题" class="headerlink" title="3.3 括号匹配问题"></a>3.3 括号匹配问题</h4><p>给定一个包含各种括号的表达式，判断是否满足括号匹配<br>利用栈操作，可在线性时间内检查出是否匹配，具体实现如下：   </p>
</li>
<li><p>利用<code>STL</code>模板库</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">paren</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> exp[])</span> </span>&#123; <span class="hljs-comment">//表达式括号匹配检查，可兼顾三种括号</span><br>    Stack&lt;<span class="hljs-type">char</span>&gt; S; <span class="hljs-comment">//使用栈记录已出现但尚未匹配的左括号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; exp[i]; i++) <span class="hljs-comment">/* 逐一检查当前字符 */</span><br>        <span class="hljs-keyword">switch</span> (exp[i]) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: S.<span class="hljs-built_in">push</span>(exp[i]); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;(&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;[&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;&#123;&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>自定义栈操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;    <span class="hljs-comment">//栈元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">SElemType <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">return</span> *--S.top;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">paren</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//构造字符栈</span><br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType ch;<br>    ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>        <span class="hljs-keyword">switch</span> (ch) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-built_in">Push</span>(S, ch); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;(&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;[&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;&#123;&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>        &#125;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">StackEmpty</span>(S);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">paren</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-4-表达式求值"><a href="#3-4-表达式求值" class="headerlink" title="3.4 表达式求值"></a>3.4 表达式求值</h4><hr>
<p><strong>_延迟缓冲_</strong><br>    在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算<br>往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后,才能作出判断并实施计算。在这类场合，栈结构则可以扮演数据缓冲区的角色。</p>
<hr>
<p>表达式求值<br>    关于运算符执行次序的规则(即运算优先级)，一部分决定于事先约定的惯例(比如乘除优先于加减)，另一部分则决定于括号。也就是说，仅根据表达式的某一前缀，并不能完全确定其中各运算符可否执行以及执行的次序；只有在已获得足够多后续信息之后，才能确定其中哪些运算符可以执行。<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210081906581.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210081907925.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210081909380.png" alt=""><br>    由于栈基本结构较为简单，常用操作内容上文已经介绍，因此本代码在此处调用<code>STL</code>中<code>stack</code>模板直接进行相关操作。       </p>
<ul>
<li>定义优先级表      </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_OPTR 9 <span class="hljs-comment">//运算符总数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Opr 100  <span class="hljs-comment">//表达式最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE&#125; Operator; <span class="hljs-comment">//运算符集合</span><br> <span class="hljs-comment">//加、减、乘、除、乘斱、阶乘、左括号、右括号、起始符不终止符</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> pri[N_OPTR][N_OPTR] = &#123; <span class="hljs-comment">//运算符优先等级 [栈顶] [弼前]</span><br><span class="hljs-comment">/* |-------------- 当前运算符 --------------| */</span><br><span class="hljs-comment">/* + - * / ^ ! ( ) \0 */</span><br><span class="hljs-comment">/* -- + */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* | - */</span>  <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 栈 * */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 顶 / */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 运 ^ */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 算 ! */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 符 ( */</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>,<br><span class="hljs-comment">/* | ) */</span>  <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>,<br><span class="hljs-comment">/* -- \0*/</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; p, stack&lt;<span class="hljs-type">float</span>&gt;&amp; stk)</span> </span>&#123; <span class="hljs-comment">//将起始于p癿子串解析为数值，并存入操作数栈</span><br>    stk.<span class="hljs-built_in">push</span>((<span class="hljs-type">float</span>)(*p - <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//当前数位对应的数值进栈</span><br>    <span class="hljs-comment">// 处理多位整数情况</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(*(++p)))&#123;<br>        <span class="hljs-type">float</span> temp = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">push</span>(temp * <span class="hljs-number">10</span> + (*p - <span class="hljs-string">&#x27;0&#x27;</span>));   <span class="hljs-comment">//弹出原操作数，转换新数值重新入栈</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;.&#x27;</span> != *p) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">//此后非小数点，则意味着当前操作数解析完成</span><br><br>    <span class="hljs-comment">//处理小数部分  fraction设置挺关键</span><br>    <span class="hljs-type">float</span> fraction = <span class="hljs-number">1</span>; <span class="hljs-comment">//否则，意味着还有小数部分 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(*(++p)))&#123; <span class="hljs-comment">//逐位加入</span><br>        <span class="hljs-type">float</span> temp = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">push</span>(temp + (*p - <span class="hljs-string">&#x27;0&#x27;</span>)*(fraction /= <span class="hljs-number">10</span>)); <span class="hljs-comment">//小数部分</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function">Operator <span class="hljs-title">optr2rank</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123; <span class="hljs-comment">//由运算符转译出编号</span><br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-keyword">return</span> ADD; <span class="hljs-comment">//加</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-keyword">return</span> SUB; <span class="hljs-comment">//减</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> : <span class="hljs-keyword">return</span> MUL; <span class="hljs-comment">//乘</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> : <span class="hljs-keyword">return</span> DIV; <span class="hljs-comment">//除</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span> : <span class="hljs-keyword">return</span> POW; <span class="hljs-comment">//乘斱</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span> : <span class="hljs-keyword">return</span> FAC; <span class="hljs-comment">//阶乘</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span> : <span class="hljs-keyword">return</span> L_P; <span class="hljs-comment">//左括号</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span> : <span class="hljs-keyword">return</span> R_P; <span class="hljs-comment">//右括号</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>: <span class="hljs-keyword">return</span> EOE; <span class="hljs-comment">//起始符与终止符</span><br>        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">//未知运算符</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">orderBetween</span><span class="hljs-params">(<span class="hljs-type">char</span> op1, <span class="hljs-type">char</span> op2)</span> <span class="hljs-comment">//比较两个运算符之间的优先级</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> pri[<span class="hljs-built_in">optr2rank</span>(op1)][<span class="hljs-built_in">optr2rank</span>(op2)]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; rpn, <span class="hljs-type">float</span> opnd)</span> </span>&#123; <span class="hljs-comment">//将操作数接至RPN末尾</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//分数值类型进行压栈</span><br>    <span class="hljs-keyword">if</span> (opnd != (<span class="hljs-type">float</span>)(<span class="hljs-type">int</span>)opnd) <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%.2f \0&quot;</span>, opnd); <span class="hljs-comment">//浮点格式，或</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%d \0&quot;</span>, (<span class="hljs-type">int</span>)opnd); <span class="hljs-comment">//整数格式</span><br><br>    <span class="hljs-keyword">if</span>(rpn==<span class="hljs-literal">NULL</span>)&#123;<br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (<span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">strcpy</span>(rpn,buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(rpn); <span class="hljs-comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span><br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">realloc</span>(rpn, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (n + <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>)); <span class="hljs-comment">//扩展空间</span><br>        <span class="hljs-built_in">strcat</span>(rpn, buf); <span class="hljs-comment">//RPN加长</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; rpn, <span class="hljs-type">char</span> optr)</span> </span>&#123; <span class="hljs-comment">//将运算符接至RPN末尾</span><br>    <span class="hljs-keyword">if</span>(rpn == <span class="hljs-literal">NULL</span>)&#123;<br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (<span class="hljs-number">3</span>));<br>        <span class="hljs-built_in">sprintf</span>(rpn, <span class="hljs-string">&quot;%c &quot;</span>, optr); rpn[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//接入指定癿运算符</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(rpn); <span class="hljs-comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span><br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">realloc</span>(rpn, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (n + <span class="hljs-number">3</span>)); <span class="hljs-comment">//扩展空间</span><br>        <span class="hljs-built_in">sprintf</span>(rpn + n, <span class="hljs-string">&quot;%c &quot;</span>, optr); rpn[n + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//接入指定癿运算符</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">char</span> op, <span class="hljs-type">float</span> data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 一元计算</span><br>    <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)data == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum_data = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(<span class="hljs-type">int</span>)data;i++) sum_data *= i;<br>    <span class="hljs-keyword">return</span> sum_data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">float</span> opd1,<span class="hljs-type">char</span> op, <span class="hljs-type">float</span> opd2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//前后操作数</span><br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> opd1+opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> opd1-opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> opd1*opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> opd1/opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(opd1,opd2);<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                  <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-type">char</span>* S, <span class="hljs-type">char</span>*&amp; RPN, <span class="hljs-type">float</span> &amp;result)</span> </span>&#123; <span class="hljs-comment">//对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN</span><br>    stack&lt;<span class="hljs-type">float</span>&gt; opnd; stack&lt;<span class="hljs-type">char</span>&gt; optr; <span class="hljs-comment">//运算数栈、运算符栈</span><br>    optr.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;\0&#x27;</span>); <span class="hljs-comment">//尾哨兵&#x27;\0&#x27;也作为头哨兵首先入栈，主要为了判断计算结束退出</span><br>    <span class="hljs-keyword">while</span> (!optr.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">//在运算符栈非空之前，逐个处理表达式中各字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(*S)) &#123; <span class="hljs-comment">//若当前字符为操作数，则</span><br>            <span class="hljs-built_in">readNumber</span>(S, opnd);   <span class="hljs-comment">// 读入操作数</span><br>            <span class="hljs-built_in">append</span>(RPN, opnd.<span class="hljs-built_in">top</span>()); <span class="hljs-comment">//并将其接至RPN末尾</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//若当前字符为运算符，则</span><br>            <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">orderBetween</span>(optr.<span class="hljs-built_in">top</span>(), *S)) &#123; <span class="hljs-comment">//视其与栈顶运算符之间优先级高低分别处理</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-comment">//栈顶运算符优先级更低时</span><br>                    optr.<span class="hljs-built_in">push</span>(*S); S++; <span class="hljs-comment">//计算推迟，当前运算符入栈</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>: <span class="hljs-comment">//优先级相等（当前运算符为右括号或者尾部哨兵&#x27;\0&#x27;）时</span><br>                    optr.<span class="hljs-built_in">pop</span>(); S++; <span class="hljs-comment">//脱括号并接收下一个字符</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>: &#123; <span class="hljs-comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span><br>                    <span class="hljs-type">char</span> op = optr.<span class="hljs-built_in">top</span>();<br>                    optr.<span class="hljs-built_in">pop</span>(); <br>                    <span class="hljs-built_in">append</span>(RPN, op); <span class="hljs-comment">//栈顶运算符出栈并续接至RPN末尾</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;!&#x27;</span> == op) &#123; <span class="hljs-comment">//若属于一元运算符</span><br>                        <span class="hljs-type">float</span> pOpnd = opnd.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//叧需取出一个操作数，并</span><br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        opnd.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calcu</span>(op, pOpnd)); <span class="hljs-comment">//实施一元计算，结果入栈</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//对于其它（二元）运算符</span><br>                        <span class="hljs-type">float</span> pOpnd2 = opnd.<span class="hljs-built_in">top</span>();<br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> pOpnd1 = opnd.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//取出后、前操作数</span><br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        opnd.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calcu</span>(pOpnd1, op, pOpnd2)); <span class="hljs-comment">//实施二元计算，结果入栈</span><br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//逢语法错误，并做处理直接退出</span><br>            &#125;<span class="hljs-comment">//switch</span><br>    &#125;<span class="hljs-comment">//while</span><br>    result = opnd.<span class="hljs-built_in">top</span>();<br>    opnd.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//弹出并返回最后的计算结果</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>* RPN = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> S[Opr] = &#123;<span class="hljs-number">0</span>&#125;;<br>    cin &gt;&gt; S;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">evaluate</span>(S,RPN,ans))<br>        cout &lt;&lt; <span class="hljs-string">&quot;Ans = &quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Reverse Polish Notation:\n&quot;</span>;<br>    cout &lt;&lt; RPN;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>算法计算示例:<br>计算给定表达式<code>(0!+1)*2^(3!+4)-(5!-67-(8+9))</code>的值<br>运行结果   <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Result">Ans = 988<br>Reverse Polish Notation:<br>0 ! 1 + 2 3 ! 4 + ^ * 5 ! 67 - 8 9 + - -<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列进阶数据结构</title>
    <url>/2022/10/13/%E9%98%9F%E5%88%97%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一、基本队列"><a href="#一、基本队列" class="headerlink" title="一、基本队列"></a>一、基本队列</h3><h4 id="相对等效"><a href="#相对等效" class="headerlink" title="相对等效"></a>相对等效</h4><p>对于给定的一个序列，如果每次操作都需要改变大部分数据，数学运算一个相同的算子，而只有少部分数据不需要改变；则可以通过逆向改变少部分数据，赋予一个逆算子，进行相应运算化简，记录相对差量，最终换算为数据结果。  </p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210111444054.png" alt=""><br>分析思路：<br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210111444904.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210111445005.png" alt=""><br>其中应当证明在依次选取 $x_1, x_2$ 时，对应的第一秒后 $[px_1], x_1-[px_1], x_2+q$，在 $x_2$ 的一秒后 $[px_1]+q, x_1-[px_1]+q, [p(x_2+q)], (x_2+q)-[p(x_2+q)]$，则易证 $[px_1]+q &gt; [p(x_2+q)]$， $x_1-[px_1]+q &gt; (x_2+q)-[p(x_2+q)]$，进而推广到任意两段满足 $x_1 &gt;= x_2$ 时，只要 $x_1$ 在 $x_2$ 之前被取出，不论之后是否接着取 $x_2$，还是直接取 $x_1$ 分出的两端，或是其他段，都等效于最开始的 $x_2$。</p>
<h3 id="二、单调队列——基于双端队列"><a href="#二、单调队列——基于双端队列" class="headerlink" title="二、单调队列——基于双端队列"></a>二、单调队列——基于双端队列</h3><p>单调队列是指队列中元素之间的关系始终保持单调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。（注意是始终保持）<br>单调队列功能：在每次加入或者删除元素时都保持序列里的元素有序，即队首元素始终是最小值或者最大值。   </p>
<h4 id="最大子序和——单调队列算法"><a href="#最大子序和——单调队列算法" class="headerlink" title="最大子序和——单调队列算法"></a>最大子序和——单调队列算法</h4><p><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210111848537.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210111849219.png" alt=""><br><img src="https://ms-blogimage.oss-cn-chengdu.aliyuncs.com/picture/img/202210111849692.png" alt=""><br>最优策略集合：下标位置递增、对应的前缀和<code>S</code>的值也递增<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;  <span class="hljs-comment">// l指向队头，r指向队尾</span><br>q[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 保存决策的基于数组的模拟队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 枚举最右端节点i</span><br>	<span class="hljs-comment">// Step 1:</span><br>	<span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; (i - q[l]) &gt; m) l++; <span class="hljs-comment">// 边界判断，最多只能选m个数，否则队首出队</span><br>	<span class="hljs-comment">// Step 2:</span><br>	ans = <span class="hljs-built_in">max</span>(ans, sum[i]-sum[q[l]]); <span class="hljs-comment">// 寻找最大值，sum[]表示数组前缀和</span><br>	<span class="hljs-comment">// Step 3:</span><br>	<span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; sum[q[r]] &gt;= sum[i]) r--;  <span class="hljs-comment">//更新，删除不小于i结点对应的队列元素</span><br>	q[++r] = i;<br>&#125;<br></code></pre></td></tr></table></figure><br>时间复杂度：$O(N)$<br>注解：</p>
<ul>
<li>$Step   1$：检查队首，如果队首指向的下标小于等于 $i-m$，即相对于 $i$ 而言，队首的元素已经跑出区间 $[i-m+1, i]$，子序列长度超过了 $m$，那么弹出队首元素，对应操作 $l++$；对最大连续子序列和问题而言，在上一轮中队首元素对应的最长子序列的和已经计算并比较存入 $ans$ 中，此时进入新元素后，队首元素已经属于无效元素，所以直接出队；</li>
<li>$Step   2$：相对于右端点 $i$ 而言，队首元素 $q[l]$ 对应的便是最优左端点 $j$；</li>
<li>$Step   3$：检查队尾，如果队尾元素大于或等于要添加的值，则弹出队尾元素，对应操作 $r-  -$，目的就是保持队首元素一直是最小值，且队列单调；</li>
<li>$Step   4$：更新队尾，$q[++r]=i$，首先 $++r$ 为新元素腾出位置，加入元素的下标；<br>解释： <ul>
<li>根据前面分析的结论，以相对于右端点 $i$ 来看，如果 $sum[q[r]] &gt;= sum[i]$，最大连续子序列和一定不会是 $q[r]$ 对应的元素节点,因为此时 $sum[q[l]] &lt;= sum[q[r]]$，比较而言 $q[l]$ 更优；</li>
<li>如果不弹出 $q[r]$,那么当 $q[l]==q[r]$ 时，此时会出现 $sum(q[l]) &gt;= sum(q[l+1])$,很明显在这种条件下，决策 $q[l+1]$ 优于决策 $q[l]$，因为相对于右端点  $i$ 选 $q[l+1]$ 可以获得不劣于 $q[l]$ 的最大连续和，因此没有必要保留 $q[r]$;</li>
<li>$q[i]$ 替换 $q[r]$ 机制，当需要弹出队尾元素 $q[r]$ 时，$r- -$ 之后 $Step   4$ 再次更新序列对应元素处在队列中的决策下标为新元素节点 $q[i]$，当下一轮 $l==r$ 时，$q[l]=q[i]$ 直接索引下一元素的下标；</li>
</ul>
</li>
</ul>
<p>单调队列思想：在决策集合（队列）中及时排除一定不是最优解的选择。<br>单调队列模板：<br><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> data[N+<span class="hljs-number">1</span>];    <span class="hljs-comment">// 原始数据序列集合</span><br><span class="hljs-type">int</span> q[N];       <span class="hljs-comment">// 用于模拟单调队列的数组</span><br><span class="hljs-type">int</span> k = Nnum;    <span class="hljs-comment">// 支持的最大区间长度</span><br><span class="hljs-type">int</span> head = <span class="hljs-number">1</span>,tail = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 初始队列没有元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>	<span class="hljs-keyword">while</span>(head &lt;= tail <span class="hljs-keyword">and</span> q[head] &lt;= i - k) head++; <span class="hljs-comment">//队首检查：保证队列长度合法</span><br>	<span class="hljs-keyword">while</span>(head &lt;= tail <span class="hljs-keyword">and</span> data[q[tail]] &gt;= data[i]) tail--; <span class="hljs-comment">// 队尾检查：保证队列单调性</span><br>	q[++tail] = i; <span class="hljs-comment">//插入新元素</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
</search>
