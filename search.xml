<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Programming</title>
    <url>/2022/05/16/C++%20Programming/</url>
    <content><![CDATA[<h2 id="bfs算法"><a class="markdownIt-Anchor" href="#bfs算法"></a> BFS算法</h2>
<p>1、可以考虑压缩状态空间，用bool数组进行存储时将其转换为bool8个位，用一个整数存储即可<br />
2、A*算法</p>
<pre><code>Astr 、估价函数    
BFS 层次分析，状态压缩，进行整理总结能够简化运算  
DFS 不能进行状态压缩   
数据结构（增删改查）——树（决策树、搜索树）    
数据结构都是描述数据的关联性的，    
</code></pre>
<h2 id="二叉树存储"><a class="markdownIt-Anchor" href="#二叉树存储"></a> 二叉树存储：</h2>
<p>1、数组：关系用位置存储，存储结点<br />
2、链表存储：类似双向链表，<code>Lchild data Rchild</code><br />
3、三叉链表存储：作用是双向搜索<br />
先序遍历，循环递推结构<br />
<strong>程序设计：</strong><br />
1、不确定行为<code>bug：</code>未初始化值、数组越界、带符号整数溢出<br />
2、命名空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">Namespace fluke<br>&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-type">int</span> m = <span class="hljs-number">999999</span>;<br>		<span class="hljs-function">poly <span class="hljs-title">poly_mul</span><span class="hljs-params">(poly a,poly b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>3、竞赛头文件：<code>#include&lt;bits/stdc++.h&gt;</code><br />
4、寻找指定数据所在范围</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-built_in">sort</span>(a, a + <span class="hljs-number">6</span>);<br>	<span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(a, a + <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) - a;<br>	<span class="hljs-type">int</span> r = <span class="hljs-built_in">upper_bound</span>(a, a + <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) - a;<br>	cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>5、二分查找函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;  arg)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (arg == final_state)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">114</span>;<br>	vector&lt;<span class="hljs-type">int</span>&gt; new_state1 = <span class="hljs-built_in">get</span>(arg);<br>	vector&lt;<span class="hljs-type">int</span>&gt; new_state2 = <span class="hljs-built_in">get</span>(arg);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">recuresive</span>(new_state1) + <span class="hljs-built_in">recuresive</span>(new_state2) + <span class="hljs-number">514</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>6、重载运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">Struct vec<br>&#123;<br>		<span class="hljs-type">int</span> x, y;<br>		<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">len</span><span class="hljs-params">()</span> </span>&#123;…&#125;<br>		<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; &#123;<span class="hljs-type">const</span> vec &amp;rhs&#125; <span class="hljs-type">const</span><br>		&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>() &lt;= rhs.<span class="hljs-built_in">len</span>();<br>		&#125;<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> *(<span class="hljs-type">const</span> vec &amp;rhs)  <span class="hljs-type">const</span><br>		&#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-number">111</span> * x * rhs.x + <span class="hljs-number">111</span> * y * rhs.y;<br>			&#125;<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> ^(<span class="hljs-type">const</span> vec &amp;rhs) <span class="hljs-type">const</span><br>		&#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-number">111</span> * x * rhs.y - <span class="hljs-number">111</span> * y * rhs.x;<br>		&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>7、<code>std::set</code>数据结构(基于有序的数据结构具体是二叉搜索树）</p>
<pre class="highlight"><code class="C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
		set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a: s)                        #简便写法类似python中的可迭代对象
			cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;
</code></pre>
<p><code>multiset</code>数据结构和<code>set</code>类似，只不过允许数据重复，插入时即是有序的<br />
8、映射数据结构</p>
<pre class="highlight"><code class="C++">map&lt;string, <span class="hljs-type">int</span>&gt; mp = &#123;
		&#123;<span class="hljs-string">&quot;Monday&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;Tuesday&quot;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&quot;Wenesday&quot;</span>,<span class="hljs-number">3</span>&#125;
	&#125;;
	cout &lt;&lt; mp[<span class="hljs-string">&quot;Tuesday&quot;</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	cout &lt;&lt; mp.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-string">&quot;Tue&quot;</span>)-&gt;first &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
	cout &lt;&lt; mp.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-string">&quot;Tue&quot;</span>)-&gt;second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&gt;&gt;<span class="hljs-number">2</span>
&gt;&gt;Tuesday
&gt;&gt;<span class="hljs-number">2</span>
</code></pre>
<p>9、加快输入输出流的速度：</p>
<pre class="highlight"><code class="C++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);
用来加快cin、cout的速率
</code></pre>
<p>10、<code>cout &lt;&lt; x+y &lt;&lt; '\n' &lt;&lt; flush;</code>强行刷新缓冲区，使数据立即输出<br />
11、移位运算</p>
<pre class="highlight"><code class="C++">a &lt;&lt;= <span class="hljs-number">10</span>  <span class="hljs-comment">//a * 1024;</span>
a &lt;&lt;= k   <span class="hljs-comment">//a * 2^k;</span>
b &gt;&gt;= k   <span class="hljs-comment">//a / 2^k;</span>
a |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>);  <span class="hljs-comment">//将a的二进制第十一位换成1，进行调节</span>
a &amp; <span class="hljs-number">1</span> <span class="hljs-comment">// a % 2</span>
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>MATLAB基本操作学习</title>
    <url>/2022/03/27/MATLAB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="matlab基本操作学习"><a class="markdownIt-Anchor" href="#matlab基本操作学习"></a> MATLAB基本操作学习</h2>
<figure class="highlight matlab"><table><tr><td class="code"><pre><code class="hljs MATLAB">• 清除变量：clear <span class="hljs-built_in">pi</span> /clearvars <span class="hljs-built_in">pi</span> <span class="hljs-built_in">inf</span>   /恢复默认变量<br>• 判别是否是关键字    iskeyword(<span class="hljs-string">&#x27;for&#x27;</span>)<br>• 数据输出格式<br>Format <span class="hljs-built_in">rat</span> 分子格式<br>Format compact 压缩格式，不显示空白行<br>• 常用函数<br>指数函数：<span class="hljs-built_in">exp</span>      以<span class="hljs-number">2</span>对数：<span class="hljs-built_in">log2</span>     自然对数：<span class="hljs-built_in">log</span><br>取整: 四舍五入 <span class="hljs-built_in">round</span>  正无穷方向取整  <span class="hljs-built_in">ceil</span> 负无穷方向取整  <span class="hljs-built_in">floor</span>  向零方向取整 <span class="hljs-built_in">fix</span> <br>求余函数：<span class="hljs-built_in">rem</span>     取模函数：<span class="hljs-built_in">mod</span><br>反正弦：<span class="hljs-built_in">asin</span><br>求复数实部：<span class="hljs-built_in">real</span>       求复数虚部：<span class="hljs-built_in">imag</span>        求共轭复数：<span class="hljs-built_in">conj</span><br>求平均值：<span class="hljs-built_in">mean</span>    标准差：std     方差：var     协方差：cov<br>相关系数：corrcoef                极差：range      <br>符号函数：<span class="hljs-built_in">sign</span>    例<span class="hljs-built_in">sign</span>(x)求 x 中元素的符号<br>• 规模化定义向量<br>X = 初值：步长：终值/初值：终值<br>X = <span class="hljs-built_in">linspace</span>(初值，终值，向量长度）  用来生成等间隔向量    <br>• 向量与矩阵的转换<br>X = A(:)            <span class="hljs-comment">% 矩阵A转为列向量x</span><br>A = <span class="hljs-built_in">reshape</span>(x, [m, n])    <span class="hljs-comment">% 将长度为m*n的向量x转换为m行n列矩阵</span><br>• 按指定阵列复制矩阵<br>B = <span class="hljs-built_in">repmat</span>(A,[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])      <span class="hljs-comment">% 复制矩阵A按行方向复制两次，列方向复制3次</span><br>• 复数矩阵<br>C = <span class="hljs-built_in">complex</span>(a, b)            <span class="hljs-comment">% 以a为实部，b为虚部生成复数矩阵   a, b 均为矩阵</span><br>• 符号矩阵<br>Y = sym(y)  <span class="hljs-comment">% 将数值矩阵y转换为符号矩阵Y</span><br>Z = sym(<span class="hljs-string">&#x27;a%d%d&#x27;</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])     <span class="hljs-comment">% 其中%d、%d按照下标进行赋值</span><br>特殊矩阵    <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(A)）生成与A相同大小的零矩阵<br>对角阵  <span class="hljs-built_in">diag</span>      X  = <span class="hljs-built_in">diag</span>(v,k)    以向量v为第k个对角线生成对角矩阵<br>X  = <span class="hljs-built_in">diag</span>(v)  以v为主对角线生成对角阵<br>v  = <span class="hljs-built_in">diag</span>(X, k)   返回矩阵X的第k条对角线上元素   省略k时默认为主对角线<br>• 元胞数组<br>&lt;<span class="hljs-number">1</span>&gt; 直接用花括号赋值创建；&lt;<span class="hljs-number">2</span>&gt; cell(m, n, p···)创建空元胞数组<br>访问元胞：C(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>)           访问元胞中的元素：C&#123;I,<span class="hljs-built_in">j</span>&#125;          celldisp显示元胞数组里面所有内容<br>• 结构体数组<br>&lt;<span class="hljs-number">1</span>&gt; 直接赋值定义  struct1(n).attris           指定第n个结构体数组单元的各属性<br>&lt;<span class="hljs-number">2</span>&gt; struct函数构造    s  =struct(<span class="hljs-string">&#x27;field1&#x27;</span>, values1, <span class="hljs-string">&#x27;field2&#x27;</span>, values2····)<br>Example: s  = struct(<span class="hljs-string">&#x27;name&#x27;</span>, &#123;<span class="hljs-string">&#x27;Mark&#x27;</span>, <span class="hljs-string">&#x27;Lucy&#x27;</span>&#125;, <span class="hljs-string">&#x27;age&#x27;</span>, &#123;<span class="hljs-number">31</span>,<span class="hljs-number">22</span>&#125;)<br>• 数组转换<br>str2func - 根据字符向量构造函数句柄  <br>• 表格型数组（Table Class)<br>工作区的变量定义为表格型<br>T = <span class="hljs-built_in">table</span>(Age, Height, Weight, Blood, <span class="hljs-string">&#x27;RowNames&#x27;</span>, Name)      (其中各变量均为向量)<br>访问 T.Height<br>• 逻辑运算<br>或运算：A|B   对应元素非零为<span class="hljs-number">1</span>否则为<span class="hljs-number">0</span>得到一个布尔矩阵<br>与运算：A&amp;B 均非零<br>非运算：~A 非零为零，零为<span class="hljs-number">1</span><br>异或运算：xor(A,B)    均为零或均非零为零否则为<span class="hljs-number">1</span><br>判断逻辑运算：A||B   判断A或B是否为零矩阵    A&amp;&amp;B<br>• 逆矩阵   Ai = inv(A)    <span class="hljs-comment">% 求A的逆矩阵</span><br>[V, D] = eig(A)      <span class="hljs-comment">% 求数值矩阵A的特征值D和特征向量矩阵V  （D为对角阵）</span><br>矩阵的迹  t  =trace(A)<br>矩阵的秩  r  = rank(A)<br></code></pre></td></tr></table></figure>
<p><strong>附录——常用数组转换函数</strong><br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172805394-926335148.png" alt="" /></p>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex基本操作</title>
    <url>/2022/10/04/Latex%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="latex学习一基本结构"><a class="markdownIt-Anchor" href="#latex学习一基本结构"></a> Latex学习一————基本结构</h3>
<h4 id="11-主体结构"><a class="markdownIt-Anchor" href="#11-主体结构"></a> 1.1 主体结构</h4>
<p>源程序分为导言区和正文区，其中导言区设置文章的一些性质或自定义命令，选定文档类命令为<code>\documentclass&#123;article&#125;</code>，设置文章属性可以加入命令<code>\title&#123;&#125;</code>,<code>\auther&#123;&#125;</code>,<code>\date&#123;&#125;</code><br />
正文区又称文稿区，设置文档环境命令<code>\begin&#123;document&#125;</code>,<code>\end&#123;document&#125;</code>,一篇文档有且只能设置一个文档环境。</p>
<h4 id="12-部分命令"><a class="markdownIt-Anchor" href="#12-部分命令"></a> 1.2 部分命令</h4>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\maketitle</span> <span class="hljs-comment">% 生成标题，用在`book/report/article`类的正文区中，而`letter`类在正文区并没有此命令。                    </span><br><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span>  <span class="hljs-comment">% 单`$`命令主要用于行内公式书写     </span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-comment">% 而双`$$`命令用于行间公式    </span><br><span class="hljs-keyword">\tableofcontents</span>  <span class="hljs-comment">% 输出文章目录       </span><br><span class="hljs-keyword">\bibliographystyle</span>   <span class="hljs-comment">% 声明参考文献的格式     </span><br><span class="hljs-keyword">\footnote</span>&#123;&#125;   <span class="hljs-comment">% 在正文后面设置脚注，花括号内的部分是命令的参数，即脚注的内容。   </span><br><span class="hljs-keyword">\emph</span>&#123;&#125;  <span class="hljs-comment">% 改变字体形状，表示强调(emphasis)的内容     </span><br><span class="hljs-keyword">\begin</span>&#123;quote&#125;<br><span class="hljs-comment">% 将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。</span><br><span class="hljs-comment">% 同时设置引用的字体</span><br><span class="hljs-keyword">\zihao</span>&#123;-5&#125;<span class="hljs-keyword">\kaishu</span>   <span class="hljs-comment">% 设置字号和字体命令  会影响后面所有文字(环境内)</span><br><span class="hljs-comment">% 注：\zihao&#123;&#125;有参数，-5即小五号</span><br><span class="hljs-keyword">\end</span>&#123;quote&#125;<br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>文章摘要环境，在<span class="hljs-keyword">\maketitle</span>之后设置<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br></code></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 导言区</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;    <span class="hljs-comment">% book,report,letter</span><br><br><span class="hljs-keyword">\title</span>&#123;My First Document&#125;<br><span class="hljs-keyword">\author</span>&#123;MarkStiff&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-comment">% 正文区(文稿区)</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>	<span class="hljs-keyword">\maketitle</span><br>	Hello World!<br>	<br>	<span class="hljs-comment">% here is my big formula</span><br>	Let <span class="hljs-built_in">$</span>f(x)<span class="hljs-built_in">$</span> be defined by the formula <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>f(x)=3x<span class="hljs-built_in">^</span>2+x-1<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> which is a polynomial of degree 2.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
<p>生成效果图:<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/1.png" alt="" /></p>
<h3 id="latex学习二中文文档设置"><a class="markdownIt-Anchor" href="#latex学习二中文文档设置"></a> Latex学习二————中文文档设置</h3>
<h4 id="21-文档整体设置"><a class="markdownIt-Anchor" href="#21-文档整体设置"></a> 2.1 文档整体设置</h4>
<ul>
<li>可以加入<code>\usepackage&#123;ctex&#125;</code>命令使用扩展包；</li>
<li>直接设置整体文档类<code>\documentclass[UTF8]&#123;ctexart&#125;</code>,此外还有<code>ctexbook ctexrep</code></li>
</ul>
<p>可选参数表明中文文档的编码，主要有<code>GBK和UTF8</code>，不同<code>Latex</code>编辑器默认编码方式不同。</p>
<h4 id="22-equation环境"><a class="markdownIt-Anchor" href="#22-equation环境"></a> 2.2 <code>equation</code>环境</h4>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2.<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
<p>此环境命令主要是用于产生带编号的行间公式。</p>
<h4 id="24-章节设置"><a class="markdownIt-Anchor" href="#24-章节设置"></a> 2.4 章节设置</h4>
<p><code>\section&#123;章节标题&#125;</code>生成一节的标题</p>
<h4 id="23-中文字体设置"><a class="markdownIt-Anchor" href="#23-中文字体设置"></a> 2.3 中文字体设置</h4>
<h5 id="字体族设置"><a class="markdownIt-Anchor" href="#字体族设置"></a> 字体族设置</h5>
<p>——罗马字体、无衬线字体、打字机字体</p>
<ul>
<li>字体命令</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\textrm</span>&#123;文本&#125; <span class="hljs-comment">% 设置字体族为罗马字体</span><br><span class="hljs-keyword">\textsf</span>&#123;文本&#125;  <span class="hljs-comment">% 无衬线字体</span><br><span class="hljs-keyword">\texttt</span>&#123;文本&#125;  <span class="hljs-comment">% 打字机字体</span><br></code></pre></td></tr></table></figure>
<ul>
<li>字体声明命令</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\rmfamily</span> 文本    <span class="hljs-comment">% 声明以后的字体使用罗马字体</span><br><span class="hljs-keyword">\sffamily</span> 文本 <span class="hljs-comment">% 无衬线字体</span><br><span class="hljs-keyword">\ttfamily</span> 文本  <span class="hljs-comment">% 打字机字体</span><br>&#123;<span class="hljs-keyword">\rmfamily</span> 文本&#125;  <span class="hljs-comment">% 使用括号限定字体声明范围</span><br></code></pre></td></tr></table></figure>
<h5 id="字体系列设置"><a class="markdownIt-Anchor" href="#字体系列设置"></a> 字体系列设置</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Pass<br></code></pre></td></tr></table></figure>
<h3 id="latex学习三-杂谈"><a class="markdownIt-Anchor" href="#latex学习三-杂谈"></a> Latex学习三———— 杂谈</h3>
<h4 id="31-定理环境"><a class="markdownIt-Anchor" href="#31-定理环境"></a> 3.1 定理环境</h4>
<p>文章定理之类的是用一类定理环境输出的，在使用之前需要在导言区做定义:<br />
<code>\newtheorem&#123;thm&#125;&#123;定理&#125;</code><br />
定理环境有一个指定定理名字的可选参数，示例:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;thm&#125;[勾股定理]<br>直角三角形斜边的平方等于两腰的平方和。<br><br>可以用符号语言表述为······<br>起源于6--7年份  <span class="hljs-comment">% 表示数字范围时可以用两个减号来输出Latex中的短横线</span><br><span class="hljs-keyword">\end</span>&#123;thm&#125;<br></code></pre></td></tr></table></figure>
<h4 id="32-数学公式"><a class="markdownIt-Anchor" href="#32-数学公式"></a> 3.2 数学公式</h4>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 行间公式 行内公式 pass</span><br><span class="hljs-keyword">\angle</span> ACB = <span class="hljs-keyword">\pi</span>/2    <span class="hljs-comment">% 角符号以及使用pi命令</span><br>f<span class="hljs-built_in">_</span>pump   <span class="hljs-comment">% &#x27;_&#x27; 命令下标设置</span><br>f<span class="hljs-built_in">^</span>2      <span class="hljs-comment">% &#x27;^&#x27; 命令上标设置</span><br><span class="hljs-comment">% 注：如果上下标不止一个符号则需要用花括号进行分组</span><br>90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span>   <span class="hljs-comment">% 设置角度上标</span><br></code></pre></td></tr></table></figure>
<p>实际效果如图:<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/20221006213148.png" alt="" /></p>
<h4 id="33-使用图表"><a class="markdownIt-Anchor" href="#33-使用图表"></a> 3.3 使用图表</h4>
<ul>
<li>插图功能<br />
插图功能由<code>graphicx</code>宏包提供，需要在导言区进行设置<br />
<code>		 \usepackage&#123;graphicx&#125;</code><br />
具体的插图命令为：<br />
<code>		 \includegraphics[width=3cm]&#123;xiantu.pdf&#125;</code><br />
其中可选参数设置图片在文档中的宽度，第二个参数是图形的文件名（放在源文件所在目录）<br />
使用xelatex命令编译时，支持的图形格式包括PDF、PNG、JPG、FPS等<br />
<strong><em>图形放置</em></strong><br />
通常将图像放置在一个浮动体中，处于一个可以变动相对位置的环境中</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;figure&#125;[ht]    <span class="hljs-comment">% 设置浮动体环境</span><br>	<span class="hljs-keyword">\centering</span>   <span class="hljs-comment">% 表示后面的内容居中</span><br>	<span class="hljs-keyword">\includegraphics</span>[scale=0.6]&#123;cover.jpg&#125;<br>	<span class="hljs-keyword">\caption</span>&#123;博客封面设计图&#125; <span class="hljs-comment">% 给插图加自动编号和标题</span><br>	<span class="hljs-keyword">\label</span>&#123;fig:封面图&#125;  <span class="hljs-comment">% 设置插图标签</span><br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br></code></pre></td></tr></table></figure>
<p>注：可选参数<code>ht</code>表示浮动体可以出现在环境周围的文本所在处(<code>here</code>)和一页的底部(<code>top</code>)<br />
具体效果图如下：<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071411539.png" alt="" /></p>
<ul>
<li>制作表格<br />
设置表格环境<code>tabular</code>：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|rrr|&#125;<br>	<span class="hljs-keyword">\hline</span><br>	直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边  <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>		3 <span class="hljs-built_in">&amp;</span>   4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>		5 <span class="hljs-built_in">&amp;</span>   12 <span class="hljs-built_in">&amp;</span>   13<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>可选参数<code>|rrr|</code>表示表格有三列，都是右对齐，行与行之间用<code>\\</code>隔开，列于列之间用<code>&amp;</code>隔开，表格中的横线用<code>\hline</code>绘制</li>
<li>表格环境设置，一般表格也放置在浮动体中，即<code>table</code>环境</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\usepackage</span>&#123;float&#125;<br><span class="hljs-keyword">\begin</span>&#123;table&#125;[H] <span class="hljs-comment">% 使用H参数表示设置表格不浮动，需要在导言区添加float宏包</span><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|lll|&#125;<br>	<span class="hljs-keyword">\hline</span><br>	直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边  <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>	3 <span class="hljs-built_in">&amp;</span>   4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br>	5 <span class="hljs-built_in">&amp;</span>   12 <span class="hljs-built_in">&amp;</span>   13<span class="hljs-keyword">\\</span><br>	<span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<span class="hljs-comment">%</span><br><span class="hljs-keyword">\qquad</span>  <span class="hljs-comment">% 此命令可以产生两个M宽度的空格</span><br>(<span class="hljs-built_in">$</span>a<span class="hljs-built_in">^</span>2 + b<span class="hljs-built_in">^</span>2 = c<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span>)<br><span class="hljs-keyword">\end</span>&#123;table&#125;   <br></code></pre></td></tr></table></figure>
<p>效果图:<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071412672.png" alt="" /></p>
<h4 id="34-图表引用"><a class="markdownIt-Anchor" href="#34-图表引用"></a> 3.4 图表引用</h4>
<ul>
<li>图片引用<br />
根据上文插图设置的标签属性可以很容易引用图片一个示例：<code>图\ref&#123;fig:xiantu&#125;是我国古代对勾股定理的一种证明</code>。</li>
<li>公式引用<br />
公式添加标签示例:</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<span class="hljs-keyword">\label</span>&#123;eq:gougu&#125;   <span class="hljs-comment">% 设定公式标签名</span><br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
<p>在正文中引用示例: <code>(\ref&#123;eq:gougu&#125;)</code>注意公式引用的括号要手动添加<br />
另解，使用宏包<code>amsmath</code>,在导言区添加宏包，之后通过命令<code>\eqref&#123;eq:gougu&#125;</code>引用，并能自动产生括号</p>
<h4 id="35-设计文章格式"><a class="markdownIt-Anchor" href="#35-设计文章格式"></a> 3.5 设计文章格式</h4>
<p>一般设置文章整体格式可以借用宏包直接进行处理，现列举较为常用的文章格式宏包:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\usepackage</span>&#123;gemetry&#125;   <span class="hljs-comment">% 设计页面尺寸宏包</span><br><span class="hljs-keyword">\geometry</span>&#123;a4paper,centering,scale=0.8&#125;  <span class="hljs-comment">% 定义A4纸大小，版心居中，宽0.8倍</span><br><br><span class="hljs-keyword">\usepackage</span>[format=hang,font=small,texfont=it]&#123;caption&#125;   <span class="hljs-comment">% 改变图表标题格式</span><br><span class="hljs-comment">% 设定图表标题悬挂对齐，整体用小字号，标题文本使用斜体（对汉字而言是楷书）</span><br><span class="hljs-keyword">\usepackage</span>[nottoc]&#123;tocbibind&#125;  <span class="hljs-comment">% 增加目录的项目</span><br><span class="hljs-comment">% 宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身</span><br></code></pre></td></tr></table></figure>
<p><strong><em>自定义环境</em></strong><br />
如果需要设置特定的段落环境，可以利用已有的环境在导言区构造新的环境，以达到增加格式控制的目的</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 这里对引用(quote)环境重新设置，增加更多格式控制命令</span><br><span class="hljs-keyword">\newenvironment</span>&#123;myquote&#125;<br>	&#123;<span class="hljs-keyword">\begin</span>&#123;quote&#125;<span class="hljs-keyword">\kaishu</span><span class="hljs-keyword">\zihao</span>&#123;-5&#125;&#125;<br>	&#123;<span class="hljs-keyword">\end</span>&#123;quote&#125;&#125;<br><span class="hljs-comment">% 这里新环境由环境名字、环境开始代码和环境末尾代码三个参数，这样在导言区定义可以重复使用</span><br><span class="hljs-comment">% 使用</span><br><span class="hljs-keyword">\begin</span>&#123;myquote&#125;<br>text······<br><span class="hljs-keyword">\end</span>&#123;myquote&#125;<br></code></pre></td></tr></table></figure>
<p><strong><em>自定义命令</em></strong><br />
在一些需要的地方，<code>Latex</code>给我们提供了自定义新的命令的代码，这极大地拓展了不同背景和领域使用的便利性。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 这里以角度上标为例</span><br><span class="hljs-keyword">\newcommand</span><span class="hljs-keyword">\degree</span>&#123;<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span>&#125;      <span class="hljs-comment">% 在导言区定义</span><br><span class="hljs-built_in">$</span>90<span class="hljs-keyword">\degree</span><span class="hljs-built_in">$</span> = <span class="hljs-built_in">$</span>90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span><span class="hljs-built_in">$</span>  <br></code></pre></td></tr></table></figure>
<p>插图版式调整后效果:<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071440767.png" alt="" /></p>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Codetest</title>
    <url>/2022/10/02/code/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">12</span>];<br>    <span class="hljs-type">char</span> axs;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>* next;<br>&#125;Stu;<br>Stu* head;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stu_read</span><span class="hljs-params">(Stu* &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Stu* temp = (Stu*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Stu));<br>    <span class="hljs-keyword">if</span> (!temp) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    cin &gt;&gt; temp-&gt;name;<br>    <span class="hljs-keyword">if</span> (temp-&gt;name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>        <span class="hljs-built_in">free</span>(temp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    cin &gt;&gt; temp-&gt;num &gt;&gt; temp-&gt;axs;<br>    p-&gt;next = temp;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    p = p-&gt;next;<br>    head-&gt;num++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search_stu</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    Stu* p = head;<br>    <span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next-&gt;num == m) &#123;<br>            Stu* q = p-&gt;next;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            <span class="hljs-built_in">free</span>(q);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stu_print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Stu* p = head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        cout &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;axs &lt;&lt; endl;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = (Stu*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Stu));<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;num = <span class="hljs-number">0</span>;<br>    Stu* temp = head;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Stu_read</span>(temp) == <span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> Out_stu = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; Out_stu;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search_stu</span>(Out_stu)) <span class="hljs-built_in">Stu_print</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>code</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/2022/09/28/%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="数据结构串"><a class="markdownIt-Anchor" href="#数据结构串"></a> 数据结构——串</h2>
<p>(字符串实现与操作）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>分治与倍增</title>
    <url>/2022/05/03/%E5%88%86%E6%B2%BB%E4%B8%8E%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<hr />
<h4 id="double-powdouble-x-double-y"><a class="markdownIt-Anchor" href="#double-powdouble-x-double-y"></a> <code>Double pow(double x, double y)</code></h4>
<h4 id="xxxxxxxxxx-passpython"><a class="markdownIt-Anchor" href="#xxxxxxxxxx-passpython"></a> xxxxxxxxxx     passPython</h4>
<p>倍增 从字面的上意思看就是成倍的增长 ,这是指我们在进行递推时,如果状态空间很大,通常的线性递推无法满足时间和空间复杂度的要求 ,那么我们就可以通过成倍的增长,只递推状态空间中在 2 的整数次幂位置上的值作为代表 。当需要其他位置上的值时,我们只需要通过&quot; 任意整数可以表示成若干个2的次幂项的和 &quot; 这一性质<code>(13 = 2^3 + 2^2 +2^0)</code>, 使用之前求出的代表值拼成所需的值。<br />
核心思想：不断以2的次幂的跨度向前试探，行进跨度，不行就降幂，迭代可以表示任意整数</p>
<h4 id="倍增主要应用"><a class="markdownIt-Anchor" href="#倍增主要应用"></a> 倍增主要应用：</h4>
<p><code>LCA(least common ancestors)</code>:最近公共祖先<br />
在有根树中，找出某两个结点u和v最近的公共祖先。<br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929170840386-1257726897.png" alt="" /><br />
在寻找两个节点的公共祖先时，按2的指数来跳，并且从大到小，……32, 16, 8 , 4 , 2, 1 【从大到小试探】</p>
<h4 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理：</h4>
<p>处理结点的深度、父节点、以及2i级的祖先<br />
<strong>开辟数组：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">&lt;<span class="hljs-number">1</span>&gt;  depth数组是记录每个节点的深度        <br>&lt;<span class="hljs-number">2</span>&gt;  fa[i][j]是指节点 i 的 <span class="hljs-number">2</span>j 级的祖先的编号      <br>&lt;<span class="hljs-number">3</span>&gt; lg数组是常数优化的数组，存的是log2N+<span class="hljs-number">1</span>的值，注意用的时候要<span class="hljs-number">-1</span>，开始之前先初始化一下，这样直接调用可以优化节约时间其中初始化的方法：l g [ i ] = l g [ i − <span class="hljs-number">1</span> ] + ( <span class="hljs-number">1</span> &lt; &lt; l g [ i − <span class="hljs-number">1</span> ] = = i ) lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i)lg[i]=lg[i−<span class="hljs-number">1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i−<span class="hljs-number">1</span>]==i)，自己手算一下很清楚的（lg[<span class="hljs-number">1</span>~<span class="hljs-number">10</span>]为<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>，应该很好懂吧）   <br></code></pre></td></tr></table></figure>
<p><strong>手写对数运算lg2[i]:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n)<span class="hljs-comment">//预处理一下 </span><br>lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-comment">//可以学习宏定义简便写法</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p&lt;&lt;1)  <span class="hljs-comment">//取半</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p&lt;&lt;1|1)   <span class="hljs-comment">//取半加一</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l+r)/2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> over(i,s,t) for(register long long i=s;i&lt;=t;++i)   <span class="hljs-comment">//循环的简写 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lver(i,t,s) for(register long long i=t;i&gt;=s;--i)</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<span class="hljs-comment">//全用ll可能会MLE或者直接WA,试着改成int看会不会A</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">500007</span>;<br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">1e9</span>+<span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS=<span class="hljs-number">1e-10</span>;<span class="hljs-comment">//-10次方约等于趋近为0</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi=<span class="hljs-number">3.1415926535897</span>;<br>ll n,m;<br><span class="hljs-comment">//前向星写法的数据结构实现：</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	ll u,v,nex;<br>&#125;e[N&lt;&lt;<span class="hljs-number">1</span>];<br>ll head[N],cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll u,ll v)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++cnt].v=v;    <span class="hljs-comment">//记录边的终点</span><br>	e[cnt].u=u;<span class="hljs-comment">//没什么用，还白占空间</span><br>	e[cnt].nex=head[u];     <span class="hljs-comment">//以u为起点的上一条边，往往更喜欢写做pre</span><br>	head[u]=cnt;    <span class="hljs-comment">//更新以u为起点的上一条边</span><br>&#125;<br>ll depth[N],fa[N][<span class="hljs-number">30</span>],lg[N],s,x,y;<br><br><span class="hljs-comment">/*dfs函数的作用就是更新该点的所有祖先的fa数组，并通过递归把</span><br><span class="hljs-comment">该节点的所有的子节点和该节点一样去更新*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll now,ll fath)</span><span class="hljs-comment">//子节点和父节点</span></span><br><span class="hljs-function"></span>&#123;<br>	fa[now][<span class="hljs-number">0</span>]=fath;<span class="hljs-comment">//更新一下fa数组，2^0=1就是父节点</span><br>	depth[now]=depth[fath]+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新深度，递归的思想</span><br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,lg[depth[now]]<span class="hljs-number">-1</span>)<br>		fa[now][i]=fa[fa[now][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>		<span class="hljs-comment">/*更新now的所有 2^i 级的祖先。先找到now的2^(i-1)级祖先，再往上找</span><br><span class="hljs-comment">		该祖先的2^(i-1)级祖先，就是now的2^i祖先，必须一节一节地往上搜*/</span><br>	<span class="hljs-keyword">for</span>(ll i=head[now];i;i=e[i].nex)<span class="hljs-comment">//链式前向星遍历</span><br>		<span class="hljs-comment">//如果now有子节点的话，就递归往子节点的子节点走（禁止套娃）</span><br>		ll v = e[i].v;<br>		<span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>	<span class="hljs-built_in">dfs</span>(e[i].v,now);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">LCA</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(depth[x]&lt;depth[y])<span class="hljs-comment">//用数学语言就是说不妨设x的深度比y的深度大</span><br>		<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//这样下面只需要写一种代码就好了</span><br>	<span class="hljs-keyword">while</span>(depth[x]&gt;depth[y])<br>		<span class="hljs-comment">//让x跳到y的高度（同一高度）</span><br>		x=fa[x][lg[depth[x]-depth[y]]<span class="hljs-number">-1</span>];<br>	<span class="hljs-comment">//如果跳到一块了那LCA肯定就是y了</span><br>	<span class="hljs-keyword">if</span>(x==y)<br>		<span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(ll k=lg[depth[x]]<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;--k)<span class="hljs-comment">//倒着从大到小地跳</span><br>		<span class="hljs-comment">/*因为我们要求跳到x和y的LCA的下一层，所以没有跳到的时候就</span><br><span class="hljs-comment">		让x和y利用dfs里早就用倍增算法处理过的祖先路径快速地一块往上跳*/</span><br>		<span class="hljs-keyword">if</span>(fa[x][k]!=fa[y][k])<br>			x=fa[x][k],y=fa[y][k];<span class="hljs-comment">//往上跳</span><br>	<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<span class="hljs-comment">//返回x，y的父节点（肯定是相同的嘛）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;s);<br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)<br>	&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">add</span>(x,y),<span class="hljs-built_in">add</span>(y,x);<span class="hljs-comment">//无向图一定要记得建双向边</span><br>	&#125;<br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,n)<span class="hljs-comment">//预处理一下</span><br>	lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//log2(8)=3//这个手写的lg[]要-1才能用lg[8]=4;</span><br>	<span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<span class="hljs-comment">//从树根开始，因为用的是链式前向星所以给一个假想根0（其实就是到这儿停）</span><br>	<span class="hljs-comment">//dfs一下，预处理各点的深度和祖先</span><br>	<span class="hljs-built_in">over</span>(i,<span class="hljs-number">1</span>,m)<br>	&#123;<br><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">LCA</span>(x,y));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2022/02/12/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一-基本操作语法"><a class="markdownIt-Anchor" href="#一-基本操作语法"></a> 一、基本操作语法</h2>
<h3 id="11-基本格式"><a class="markdownIt-Anchor" href="#11-基本格式"></a> 1.1 基本格式</h3>
<p>&lt;1&gt; 设置标题前后均留有空格</p>
<p>&lt;2&gt; 加粗:</p>
<p><strong>加粗示例1（较推荐）</strong></p>
<p><strong>加粗示例2</strong></p>
<p>&lt;3&gt; 斜体：</p>
<p><em>斜体示例1(较推荐）</em></p>
<p><em>斜体示例2</em></p>
<h3 id="12-段落和换行"><a class="markdownIt-Anchor" href="#12-段落和换行"></a> 1.2 段落和换行</h3>
<h4 id="没有空行示例"><a class="markdownIt-Anchor" href="#没有空行示例"></a> 没有空行示例</h4>
<p>第一行<br />
第二行</p>
<h4 id="有空行示例"><a class="markdownIt-Anchor" href="#有空行示例"></a> 有空行示例</h4>
<p>第一行</p>
<p>第二行</p>
<h4 id="段内换行"><a class="markdownIt-Anchor" href="#段内换行"></a> 段内换行</h4>
<p>第一行，如果在段内换行需要在结尾插入两个及以上的空格<br />
第二行</p>
<h3 id="13-有序列表"><a class="markdownIt-Anchor" href="#13-有序列表"></a> 1.3 有序列表</h3>
<h4 id="有序列表示例"><a class="markdownIt-Anchor" href="#有序列表示例"></a> 有序列表示例</h4>
<p>(数字序号+英文句号+空格+列表内容)</p>
<ol>
<li>我有一个梦想</li>
<li>我有两个梦想</li>
<li>我有三个梦想</li>
</ol>
<h3 id="14-无序列表"><a class="markdownIt-Anchor" href="#14-无序列表"></a> 1.4 无序列表</h3>
<h4 id="无序列表示例"><a class="markdownIt-Anchor" href="#无序列表示例"></a> 无序列表示例</h4>
<p>(*/+/- + 空格 + 列表内容)</p>
<h5 id="使用星号"><a class="markdownIt-Anchor" href="#使用星号"></a> 使用星号</h5>
<ul>
<li>我有一个梦想</li>
<li>我有两个梦想</li>
<li>我有三个梦想<br />
（其他标记效果相同）</li>
</ul>
<h3 id="15-嵌套列表"><a class="markdownIt-Anchor" href="#15-嵌套列表"></a> 1.5 嵌套列表</h3>
<h4 id="语法示例"><a class="markdownIt-Anchor" href="#语法示例"></a> 语法示例</h4>
<p>在第一层列表上，每一层多一个TAB键</p>
<ul>
<li>我有一个梦想
<ul>
<li>你有一个梦想
<ul>
<li>她有一个梦想
<ul>
<li>他有一个梦想<br />
(有序列表类似可以互相嵌套）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>(建议使用-标记无序列表避免与粗体和斜体混淆)</em></strong></p>
<h3 id="16-分割线"><a class="markdownIt-Anchor" href="#16-分割线"></a> 1.6 分割线</h3>
<h4 id="基本格式"><a class="markdownIt-Anchor" href="#基本格式"></a> 基本格式</h4>
<p>分割线由3个及以上的*/-/_来标记，对应效果不同。<br />
<strong>分割线示例</strong></p>
<ul>
<li>星号</li>
</ul>
<hr />
<hr />
<hr />
<ul>
<li>减号</li>
</ul>
<hr />
<hr />
<hr />
<ul>
<li>下画线</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="二-图片文件操作"><a class="markdownIt-Anchor" href="#二-图片文件操作"></a> 二、图片文件操作</h2>
<h3 id="21-插入图片"><a class="markdownIt-Anchor" href="#21-插入图片"></a> 2.1 插入图片</h3>
<h4 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h4>
<ul>
<li>
<p>本地图片<br />
（支持相对路径和绝对路径）<br />
<img src="D:/VisualStudioIDE/background/1.png" alt="本地图片" /></p>
</li>
<li>
<p>网络图片<br />
<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fd5f14e00482699c1c3b3509142b16f88126deff7.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1666447219&amp;t=b8c922e69db81319d3dc686fb66a0e53" alt="网络图片" /></p>
</li>
</ul>
<h3 id="22-链接"><a class="markdownIt-Anchor" href="#22-链接"></a> 2.2 链接</h3>
<h4 id="基本语法-2"><a class="markdownIt-Anchor" href="#基本语法-2"></a> 基本语法</h4>
<h5 id="文字链接"><a class="markdownIt-Anchor" href="#文字链接"></a> 文字链接</h5>
<p><strong><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接文字</a></strong><br />
经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a></p>
<h5 id="引用链接"><a class="markdownIt-Anchor" href="#引用链接"></a> 引用链接</h5>
<p>经常使用的网站<a href="http://www.google.com/">Google</a>、<a href="http://github.com/">Github</a></p>
<p>语法说明如下：</p>
<ul>
<li>链接标记可以有字母、数字、空格和标点符号；</li>
<li>链接标记不区分大小写；</li>
<li>定义的链接内容可以放在当前文件的任意位置，建议放在页尾；</li>
<li>当链接地址为网络地址时要以http/https开头，否则会被识别为本地地址。</li>
</ul>
<h4 id="网址链接"><a class="markdownIt-Anchor" href="#网址链接"></a> 网址链接</h4>
<p>在Markdown中，将网络地址或邮箱地址使用＜＞包裹起来会被自动转换为超链接。<br />
<strong>邮箱链接示例</strong><br />
获取更多信息，请访问MarkStiff的邮箱<a href="mailto:LZH1314521ligao@163.com">LZH1314521ligao@163.com</a></p>
<h4 id="链接标题"><a class="markdownIt-Anchor" href="#链接标题"></a> 链接标题</h4>
<p>如果想了解关于Markdown的更多信息，请查看<a href="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0.md">Markdown指南</a></p>
<h3 id="23-行内代码与代码块"><a class="markdownIt-Anchor" href="#23-行内代码与代码块"></a> 2.3 行内代码与代码块</h3>
<h4 id="行内代码"><a class="markdownIt-Anchor" href="#行内代码"></a> 行内代码</h4>
<p><strong>语法格式<code>Insert_Codes</code></strong></p>
<ul>
<li>使用<code>mkdir 文件夹</code>命令创建文件夹</li>
</ul>
<h4 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h4>
<p><strong>语法格式：Tab键或4个空格开头</strong> //注意代码块需要隔行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;node;  <br></code></pre></td></tr></table></figure>
<h3 id="24-引用"><a class="markdownIt-Anchor" href="#24-引用"></a> 2.4 引用</h3>
<p><strong>语法格式：&gt; + 引用内容</strong><br />
语法说明如下：</p>
<ol>
<li>多行引用也可以在每一行的开头都插入＞；</li>
<li>在引用中可以嵌套引用；</li>
<li>在引用中可以使用其他的Markdown语法；</li>
<li>段落与换行的格式在引用中也是适用的。</li>
</ol>
<h4 id="单行引用"><a class="markdownIt-Anchor" href="#单行引用"></a> 单行引用</h4>
<blockquote>
<p>基于改进的自约束差分进化算法的多目标优化模型</p>
</blockquote>
<h4 id="多行引用"><a class="markdownIt-Anchor" href="#多行引用"></a> 多行引用</h4>
<blockquote>
<p>引用MarkStiff的博客文章<a href="https://www.cnblogs.com/MarkStiff/p/16716797.html">MarkStiff</a><br />
算法介绍</p>
</blockquote>
<h4 id="嵌套引用"><a class="markdownIt-Anchor" href="#嵌套引用"></a> 嵌套引用</h4>
<blockquote>
<p>多目标优化模型</p>
<blockquote>
<p>差分进化算法</p>
<blockquote>
<p>改进的自约束处理</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="25-转义"><a class="markdownIt-Anchor" href="#25-转义"></a> 2.5 转义</h3>
<p><strong>介绍</strong><br />
当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用 <code>\</code> 进行转义<br />
<strong>语法格式：\特殊字符</strong></p>
<pre><code>`// 常见转义字符`
</code></pre>
<p>\   反斜线<br />
`   反引号<br />
*   星号<br />
_   底线<br />
{}  花括号<br />
[]  方括号<br />
()  括弧<br />
#   井字号<br />
+   加号<br />
-   减号<br />
.   英文句点<br />
!   惊叹号</p>
]]></content>
  </entry>
  <entry>
    <title>数模C题</title>
    <url>/2022/05/13/%E6%95%B0%E6%A8%A1C%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数模c题总结"><a class="markdownIt-Anchor" href="#数模c题总结"></a> 数模C题总结</h2>
<h4 id="第一部分问题分析"><a class="markdownIt-Anchor" href="#第一部分问题分析"></a> 第一部分——问题分析</h4>
<p>拆分问题，将各个问题进行拆分，尤其是效果分析类的</p>
<h4 id="第一部分数据预处理"><a class="markdownIt-Anchor" href="#第一部分数据预处理"></a> 第一部分——数据预处理</h4>
<p><strong>数据探索性分析</strong></p>
<pre><code>箱型图======&gt;探究是否有偏好情况=======&gt;决定了之后问题解决是否要考虑材料种类差异
对数直方图、洛伦兹图======&gt;探究数据是否存在数量级差异以及数据的均衡程度
散点图======&gt;探究数据的分布情况
</code></pre>
<h4 id="第二部分评价类"><a class="markdownIt-Anchor" href="#第二部分评价类"></a> 第二部分——评价类</h4>
<p><strong>熵权法-TOPSIS</strong></p>
<pre><code>叙述:
熵权法通过计算指标的信息熵，根据其相对变化程度对系统的整体影响来决定权重，避免了
层次分析法等主观赋权法的弊端，获取权重的客观性较强。在得到权重后， 利用 TOPSIS
方法将它们综合， TOPSIS 法通过构建评价问题的正理想解和负理想解，计算每个方案到理
想方案的相对贴近度来对方案进行排序，最终求解出最优方案。
</code></pre>
<h4 id="第三部分横纵向分析"><a class="markdownIt-Anchor" href="#第三部分横纵向分析"></a> 第三部分——横纵向分析</h4>
<pre><code>模型构建分析时，直接显著点出横向角度和纵向角度（一般有时间）来分析
核密度曲线
季节性分解
</code></pre>
<p><em>机会约束叙述：</em><br />
<img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929172332648-38102188.png" alt="" /></p>
<pre><code>蒙特卡洛法
针状图====&gt;检验有效数据的完整性      
</code></pre>
<h4 id="第四部分方案实施效果分析"><a class="markdownIt-Anchor" href="#第四部分方案实施效果分析"></a> 第四部分——方案实施效果分析</h4>
<pre><code>绘制数据结果图=====&gt;结合图像说明或解释
变化面积图
置信因子α灵敏度分析:
分别取置信因子α=0.85， 0.9， 0.95对约束进行松弛，可以得到丌同的决策集合。
随着置信度𝛼的上升，随机变量𝜉的少数极端抖动造成约束条件难以满足， 迫使企
业需要增大订单量来对冲风险，亍是表现为总订单额的升高。
类似的，对亍转运损失率，随着置信度𝛼的上升，转运损失率也在违约率高的周
内相应明显升高，这也进一步印证了前文关亍损失率和违约率的机理猜测。    
</code></pre>
<h4 id="第五部分惩罚因子"><a class="markdownIt-Anchor" href="#第五部分惩罚因子"></a> 第五部分——惩罚因子</h4>
<pre><code>问题三只在问题二的基础上改变了一点要求，即尽量多地采购A 类和尽量少地采购C类原材料，
可以考虑为每立方米 A、 B、 C 三种材料分别赋予惩罚因子为 1、 5、10，以惩罚函数最小为目标，约束同问题二，建立右图所示的觃划模型。转运方案制定不方案实施效果分析同问题二。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>算法竞赛——概述</title>
    <url>/2022/04/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="算法竞赛"><a class="markdownIt-Anchor" href="#算法竞赛"></a> 算法竞赛</h2>
<hr />
<h3 id="卡常技巧"><a class="markdownIt-Anchor" href="#卡常技巧"></a> 卡常技巧</h3>
<p><img src="https://img2022.cnblogs.com/blog/2979937/202209/2979937-20220929165652647-2103037728.png" alt="" /></p>
<p>注：最终的取模操作或者是在中间过程取模，使得不出现负数的余数</p>
<h3 id="rand函数生成随机数时一定要考虑rand_max的值"><a class="markdownIt-Anchor" href="#rand函数生成随机数时一定要考虑rand_max的值"></a> rand（）函数生成随机数时一定要考虑RAND_MAX的值</h3>
<h3 id="函数调用时对其参数求值的顺序就是未指定的"><a class="markdownIt-Anchor" href="#函数调用时对其参数求值的顺序就是未指定的"></a> 函数调用时，对其参数求值的顺序就是未指定的。</h3>
<h3 id="评测系统返回的错误信息"><a class="markdownIt-Anchor" href="#评测系统返回的错误信息"></a> 评测系统返回的错误信息：</h3>
<pre><code>* CE(compiler error): 无法编译成可执行文件（不算罚时)
* TL(TIMELIMIT):时间超限
* RE(RUN-ERROR):
	○ return返回值非0，未正常退出
	○ 也可能是内存超限
	○ 内存开得过大也可能报错
* OL(OUTPUT-LIMIT):输出超限
	○ 可能陷入了带输出的死循环
	○ 忘记删除调试输出
	○ 有时只是WA的一种表现形式
* WA(WRONG-ANSWER):
	○ 空白字符(行末空格和文末回车），因此每行应以&quot;\n&quot;结束
</code></pre>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<pre><code>Ø 栈溢出主要表现：
	○ RUN-ERROR
	○ 段错误
	○ segmentation fault (core dumped)
Ø 预防排查
	○    避免死递归
	○ 热身赛可以测试评测系统是否调整了栈空间
	○ 全局变量：
	不要将巨大的数组或结构体声明为自动局部变量或按值传递的参数，可以开全局或者静态变量，通过指针/引用传递
</code></pre>
<h3 id="整数溢出"><a class="markdownIt-Anchor" href="#整数溢出"></a> 整数溢出</h3>
<p>未定义行为：<br />
§ 带符号整数算术运算溢出<br />
§ 移位位数超过整数位数<br />
§ 使用 scanf 读取数字时，输入超过格式化字符串指定的表示范围<br />
§ 浮点数转化为整数时，其值超过了整数类型能表示的范围<br />
以下行为可能导致出人意料的结果：<br />
§ 无符号整数算术运算溢出 (丢弃高位)<br />
§ 使用 cin 读取数字时，输入超过变量的表示范围 (读入错误的值，并设定 failbit)<br />
§ 整数类型互相转化时高位被丢弃<br />
§ 浮点数转化为整数时小数部分被截断<br />
§ 浮点数精度问题导致负0的出现</p>
<h3 id="常见错误的预防和排查"><a class="markdownIt-Anchor" href="#常见错误的预防和排查"></a> 常见错误的预防和排查</h3>
<pre><code>I 开始编码前预先考虑好输入、中间结果、最终结果的可能范围 
I 该取模的模（指中间过程就开始取模运算，因为结果直接取模一般没必要） 
I 该开 64 位和 128 位整数的开 
I 该转型的转：1ll * a * b（转换成long long型的避免运算时结果溢出）
I 该换语言的换（指python方便处理时用）
I 该写高精度的写（不能用python时，必要就写） 
I 打开编译器相关警告选项（辅助） 
I 编造数据测试是否有溢出 
I 如果测试过程中发现溢出，打开运行时检查工具 
I 如果确实需要溢出，使用无符号整数 
I 反对盲目蛮干
</code></pre>
<h3 id="无效指针"><a class="markdownIt-Anchor" href="#无效指针"></a> 无效指针</h3>
<pre><code>Ø 未初始化的指针使用就是未定义行为 
Ø 越出数组界限的指针 
	○ 对不指向数组中元素的指针进行偏移运算是未定义的 
	○ 对指向数组中元素的指针进行偏移运算，越出数组范围 (结果不指向同一数组中的元素，或该数组最后一个元素“之后的一个元素”)，行为是未定义的
Ø 预防和排查
	○ 数组开得尽量大
	○ 对指针和数组下标进行必要检查
	○ 打开运行时检查进行检查
</code></pre>
<h3 id="无效迭代器"><a class="markdownIt-Anchor" href="#无效迭代器"></a> 无效迭代器</h3>
<p>在一些 (可能意想不到的) 情况下，迭代器会失效变成非法的<br />
Ø 迭代器不能越界<br />
Ø 例1：<br />
预防与排查：<br />
○ 不要滥用迭代器<br />
○ 在range-based for循环中，不要对迭代的容器进行插入或删除操作<br />
○ 在 set、map、multiset、multimap、list 等中进行删除操作时，可以使用 c.erase(it++) 的写法<br />
对于 C<ins>11 以上，还支持 it = c.erase(it) 的写法<br />
○ 如果怀疑使用了无效迭代器，可以打开 C</ins> 标准库的运行时检查</p>
<h3 id="超时的分析"><a class="markdownIt-Anchor" href="#超时的分析"></a> 超时的分析</h3>
<pre><code>Ø 算法的选择不合适
Ø 算法合适，但某个细节未考虑，导致高次时间复杂度
举例：
	
&lt;1&gt;循环多次调用strlen(s)，时间复杂度 O(n2)
&lt;2&gt;对大的数组，如果每组数据用的数组内存较少而数据组数较多时，多次memset会做很多无用功，导致时间复杂度较高 O(mn)
Ø 常数太大
I 典型代表：endl 或者忘了用 cin.tie(0)、valarray
预防和排查：
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>顺序栈</title>
    <url>/2022/10/03/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈的顺序存储表示"><a href="#栈的顺序存储表示" class="headerlink" title="栈的顺序存储表示"></a>栈的顺序存储表示</h2><hr>
<h3 id="1、顺序存储结构"><a href="#1、顺序存储结构" class="headerlink" title="1、顺序存储结构"></a>1、顺序存储结构</h3><p>利用一组地址连续的存储单元<br><strong>顺序栈定义</strong>：   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;Sqstack;<br></code></pre></td></tr></table></figure>
<p><em>注：当用数组作为存储结构时，可以用下标代替指针</em>      </p>
<h3 id="2、基本操作算法描述"><a href="#2、基本操作算法描述" class="headerlink" title="2、基本操作算法描述"></a>2、基本操作算法描述</h3><p>对栈的常用操作做简要描述：      </p>
<ul>
<li><p>栈的初始化     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以初始化容量申请一块连续的内存，<code>S.top=S.base</code>保证<code>top=base</code>时栈空。    </p>
</li>
<li><p>返回栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == S.base)  <span class="hljs-keyword">return</span> ERROR;<br>    e = *(S.base<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>压栈操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>出栈操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>判断栈空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>清空栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用栈空标志进行清空</span><br>    S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>释放栈空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">free</span>(S.base);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3、栈的应用举例"><a href="#3、栈的应用举例" class="headerlink" title="3、栈的应用举例"></a>3、栈的应用举例</h3><h4 id="3-1-数制转换"><a href="#3-1-数制转换" class="headerlink" title="3.1 数制转换"></a>3.1 数制转换</h4><p>十进制数与其他d进制数转换时，一个简单算法原理：<br><code>N = (N div d) X d + N mod d</code>,其中<code>div</code>表示整除操作，<code>mod</code>表示求余操作     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Conversion</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType data;<br>    <span class="hljs-type">int</span> Obj = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; data &gt;&gt; Obj;<br>    <span class="hljs-keyword">while</span>(data)&#123;<br>        <span class="hljs-built_in">Push</span>(S,data % Obj);<br>        data = data/Obj;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">StackEmpty</span>(S))<br>    &#123;<br>        SElemType e;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Pop</span>(S,e)) <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; e;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对于输入的十进制数和目标进制，打印输出目标进制数</span><br>    <span class="hljs-built_in">Conversion</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-行编辑程序"><a href="#3-2-行编辑程序" class="headerlink" title="3.2 行编辑程序"></a>3.2 行编辑程序</h4><p>将用户从键盘输入的符号存入一个输入缓冲区，然后逐行存入用户数据区；这个过程允许用户删除字符，删除整行字符<br>基本操作规则：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 退格符<br>@ 退行符<br>^ 结束符<br></code></pre></td></tr></table></figure>
<p>程序实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackPrint</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    SElemType *mp = S.base;<br>    <span class="hljs-keyword">while</span>(mp != S.top)&#123;<br>        <span class="hljs-built_in">putchar</span>(*mp);<br>        mp++;<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用栈空标志进行清空</span><br>    S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">free</span>(S.base);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-function">Status <span class="hljs-title">LineEdit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构造字符栈</span><br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType ch;<br>    ch = <span class="hljs-built_in">getchar</span>();  <span class="hljs-comment">//从终端接受一个字符</span><br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span>)&#123;<br>        <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            <span class="hljs-keyword">switch</span>(ch)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-built_in">Pop</span>(S,ch);  <span class="hljs-comment">//退字符</span><br>                         <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>:<span class="hljs-built_in">ClearStack</span>(S); <span class="hljs-comment">//退行</span><br>                         <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<span class="hljs-built_in">Push</span>(S,ch); <span class="hljs-comment">//字符入栈</span><br>            &#125;<br>            ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//从终端接受下一个字符</span><br>        &#125;<br>        <span class="hljs-comment">//对缓冲区的一行字符存入数据区，这里只是打印输出</span><br>        <span class="hljs-built_in">StackPrint</span>(S);<br>        <span class="hljs-built_in">ClearStack</span>(S);<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27;^&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-built_in">DestroyStack</span>(S);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LineEdit</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-3-括号匹配问题"><a href="#3-3-括号匹配问题" class="headerlink" title="3.3 括号匹配问题"></a>3.3 括号匹配问题</h4><p>给定一个包含各种括号的表达式，判断是否满足括号匹配<br>利用栈操作，可在线性时间内检查出是否匹配，具体实现如下：   </p>
</li>
<li><p>利用<code>STL</code>模板库</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">paren</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> exp[])</span> </span>&#123; <span class="hljs-comment">//表达式括号匹配检查，可兼顾三种括号</span><br>    Stack&lt;<span class="hljs-type">char</span>&gt; S; <span class="hljs-comment">//使用栈记录已出现但尚未匹配的左括号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; exp[i]; i++) <span class="hljs-comment">/* 逐一检查当前字符 */</span><br>        <span class="hljs-keyword">switch</span> (exp[i]) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: S.<span class="hljs-built_in">push</span>(exp[i]); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;(&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;[&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ((S.<span class="hljs-built_in">empty</span>()) || (<span class="hljs-string">&#x27;&#123;&#x27;</span> != S.<span class="hljs-built_in">pop</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>自定义栈操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;    <span class="hljs-comment">//栈元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> Status;<br><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> OK = <span class="hljs-literal">true</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> ERROR = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> SElemType STACK_INIT_SIZE = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> SElemType STACKINCREMENT = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    SElemType *base;   <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;    <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;   <span class="hljs-comment">// 当前栈的最大容量 </span><br>&#125;SqStack;<br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造空栈S</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先判断是否栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base &gt;= S.stacksize)&#123;<br>        S.base = (SElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));   <span class="hljs-comment">//申请增量空间</span><br>        <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(EOVERFLOW);<br>        <span class="hljs-comment">// 更新回原来位置</span><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">SElemType <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 栈空标志</span><br>    <span class="hljs-keyword">if</span>(S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">return</span> *--S.top;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base == S.top) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">paren</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//构造字符栈</span><br>    SqStack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    SElemType ch;<br>    ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>        <span class="hljs-keyword">switch</span> (ch) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-built_in">Push</span>(S, ch); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;(&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;[&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">StackEmpty</span>(S)) || (<span class="hljs-string">&#x27;&#123;&#x27;</span> != <span class="hljs-built_in">Pop</span>(S))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>        &#125;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">StackEmpty</span>(S);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">paren</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-4-表达式求值"><a href="#3-4-表达式求值" class="headerlink" title="3.4 表达式求值"></a>3.4 表达式求值</h4><hr>
<p><strong><em>延迟缓冲</em></strong><br>    在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算<br>往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后,才能作出判断并实施计算。在这类场合，栈结构则可以扮演数据缓冲区的角色。</p>
<hr>
<p>表达式求值<br>    关于运算符执行次序的规则(即运算优先级)，一部分决定于事先约定的惯例(比如乘除优先于加减)，另一部分则决定于括号。也就是说，仅根据表达式的某一前缀，并不能完全确定其中各运算符可否执行以及执行的次序；只有在已获得足够多后续信息之后，才能确定其中哪些运算符可以执行。<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081906581.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081907925.png" alt=""><br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081909380.png" alt=""><br>    由于栈基本结构较为简单，常用操作内容上文已经介绍，因此本代码在此处调用<code>STL</code>中<code>stack</code>模板直接进行相关操作。       </p>
<ul>
<li>定义优先级表      </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_OPTR 9 <span class="hljs-comment">//运算符总数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Opr 100  <span class="hljs-comment">//表达式最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE&#125; Operator; <span class="hljs-comment">//运算符集合</span><br> <span class="hljs-comment">//加、减、乘、除、乘斱、阶乘、左括号、右括号、起始符不终止符</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> pri[N_OPTR][N_OPTR] = &#123; <span class="hljs-comment">//运算符优先等级 [栈顶] [弼前]</span><br><span class="hljs-comment">/* |-------------- 当前运算符 --------------| */</span><br><span class="hljs-comment">/* + - * / ^ ! ( ) \0 */</span><br><span class="hljs-comment">/* -- + */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* | - */</span>  <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 栈 * */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 顶 / */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 运 ^ */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 算 ! */</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br><span class="hljs-comment">/* 符 ( */</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>,<br><span class="hljs-comment">/* | ) */</span>  <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>,<br><span class="hljs-comment">/* -- \0*/</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; p, stack&lt;<span class="hljs-type">float</span>&gt;&amp; stk)</span> </span>&#123; <span class="hljs-comment">//将起始于p癿子串解析为数值，并存入操作数栈</span><br>    stk.<span class="hljs-built_in">push</span>((<span class="hljs-type">float</span>)(*p - <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//当前数位对应的数值进栈</span><br>    <span class="hljs-comment">// 处理多位整数情况</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(*(++p)))&#123;<br>        <span class="hljs-type">float</span> temp = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">push</span>(temp * <span class="hljs-number">10</span> + (*p - <span class="hljs-string">&#x27;0&#x27;</span>));   <span class="hljs-comment">//弹出原操作数，转换新数值重新入栈</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;.&#x27;</span> != *p) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">//此后非小数点，则意味着当前操作数解析完成</span><br><br>    <span class="hljs-comment">//处理小数部分  fraction设置挺关键</span><br>    <span class="hljs-type">float</span> fraction = <span class="hljs-number">1</span>; <span class="hljs-comment">//否则，意味着还有小数部分 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(*(++p)))&#123; <span class="hljs-comment">//逐位加入</span><br>        <span class="hljs-type">float</span> temp = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">push</span>(temp + (*p - <span class="hljs-string">&#x27;0&#x27;</span>)*(fraction /= <span class="hljs-number">10</span>)); <span class="hljs-comment">//小数部分</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function">Operator <span class="hljs-title">optr2rank</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123; <span class="hljs-comment">//由运算符转译出编号</span><br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-keyword">return</span> ADD; <span class="hljs-comment">//加</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-keyword">return</span> SUB; <span class="hljs-comment">//减</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> : <span class="hljs-keyword">return</span> MUL; <span class="hljs-comment">//乘</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> : <span class="hljs-keyword">return</span> DIV; <span class="hljs-comment">//除</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span> : <span class="hljs-keyword">return</span> POW; <span class="hljs-comment">//乘斱</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span> : <span class="hljs-keyword">return</span> FAC; <span class="hljs-comment">//阶乘</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span> : <span class="hljs-keyword">return</span> L_P; <span class="hljs-comment">//左括号</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span> : <span class="hljs-keyword">return</span> R_P; <span class="hljs-comment">//右括号</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>: <span class="hljs-keyword">return</span> EOE; <span class="hljs-comment">//起始符与终止符</span><br>        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">//未知运算符</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">orderBetween</span><span class="hljs-params">(<span class="hljs-type">char</span> op1, <span class="hljs-type">char</span> op2)</span> <span class="hljs-comment">//比较两个运算符之间的优先级</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> pri[<span class="hljs-built_in">optr2rank</span>(op1)][<span class="hljs-built_in">optr2rank</span>(op2)]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; rpn, <span class="hljs-type">float</span> opnd)</span> </span>&#123; <span class="hljs-comment">//将操作数接至RPN末尾</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//分数值类型进行压栈</span><br>    <span class="hljs-keyword">if</span> (opnd != (<span class="hljs-type">float</span>)(<span class="hljs-type">int</span>)opnd) <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%.2f \0&quot;</span>, opnd); <span class="hljs-comment">//浮点格式，或</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%d \0&quot;</span>, (<span class="hljs-type">int</span>)opnd); <span class="hljs-comment">//整数格式</span><br><br>    <span class="hljs-keyword">if</span>(rpn==<span class="hljs-literal">NULL</span>)&#123;<br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (<span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">strcpy</span>(rpn,buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(rpn); <span class="hljs-comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span><br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">realloc</span>(rpn, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (n + <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>)); <span class="hljs-comment">//扩展空间</span><br>        <span class="hljs-built_in">strcat</span>(rpn, buf); <span class="hljs-comment">//RPN加长</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">char</span>*&amp; rpn, <span class="hljs-type">char</span> optr)</span> </span>&#123; <span class="hljs-comment">//将运算符接至RPN末尾</span><br>    <span class="hljs-keyword">if</span>(rpn == <span class="hljs-literal">NULL</span>)&#123;<br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (<span class="hljs-number">3</span>));<br>        <span class="hljs-built_in">sprintf</span>(rpn, <span class="hljs-string">&quot;%c &quot;</span>, optr); rpn[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//接入指定癿运算符</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(rpn); <span class="hljs-comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span><br>        rpn = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">realloc</span>(rpn, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (n + <span class="hljs-number">3</span>)); <span class="hljs-comment">//扩展空间</span><br>        <span class="hljs-built_in">sprintf</span>(rpn + n, <span class="hljs-string">&quot;%c &quot;</span>, optr); rpn[n + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//接入指定癿运算符</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">char</span> op, <span class="hljs-type">float</span> data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 一元计算</span><br>    <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)data == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum_data = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(<span class="hljs-type">int</span>)data;i++) sum_data *= i;<br>    <span class="hljs-keyword">return</span> sum_data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">float</span> opd1,<span class="hljs-type">char</span> op, <span class="hljs-type">float</span> opd2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//前后操作数</span><br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> opd1+opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> opd1-opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> opd1*opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> opd1/opd2;<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(opd1,opd2);<br>                  <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                  <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-type">char</span>* S, <span class="hljs-type">char</span>*&amp; RPN, <span class="hljs-type">float</span> &amp;result)</span> </span>&#123; <span class="hljs-comment">//对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN</span><br>    stack&lt;<span class="hljs-type">float</span>&gt; opnd; stack&lt;<span class="hljs-type">char</span>&gt; optr; <span class="hljs-comment">//运算数栈、运算符栈</span><br>    optr.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;\0&#x27;</span>); <span class="hljs-comment">//尾哨兵&#x27;\0&#x27;也作为头哨兵首先入栈，主要为了判断计算结束退出</span><br>    <span class="hljs-keyword">while</span> (!optr.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">//在运算符栈非空之前，逐个处理表达式中各字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(*S)) &#123; <span class="hljs-comment">//若当前字符为操作数，则</span><br>            <span class="hljs-built_in">readNumber</span>(S, opnd);   <span class="hljs-comment">// 读入操作数</span><br>            <span class="hljs-built_in">append</span>(RPN, opnd.<span class="hljs-built_in">top</span>()); <span class="hljs-comment">//并将其接至RPN末尾</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//若当前字符为运算符，则</span><br>            <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">orderBetween</span>(optr.<span class="hljs-built_in">top</span>(), *S)) &#123; <span class="hljs-comment">//视其与栈顶运算符之间优先级高低分别处理</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-comment">//栈顶运算符优先级更低时</span><br>                    optr.<span class="hljs-built_in">push</span>(*S); S++; <span class="hljs-comment">//计算推迟，当前运算符入栈</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>: <span class="hljs-comment">//优先级相等（当前运算符为右括号或者尾部哨兵&#x27;\0&#x27;）时</span><br>                    optr.<span class="hljs-built_in">pop</span>(); S++; <span class="hljs-comment">//脱括号并接收下一个字符</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>: &#123; <span class="hljs-comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span><br>                    <span class="hljs-type">char</span> op = optr.<span class="hljs-built_in">top</span>();<br>                    optr.<span class="hljs-built_in">pop</span>(); <br>                    <span class="hljs-built_in">append</span>(RPN, op); <span class="hljs-comment">//栈顶运算符出栈并续接至RPN末尾</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;!&#x27;</span> == op) &#123; <span class="hljs-comment">//若属于一元运算符</span><br>                        <span class="hljs-type">float</span> pOpnd = opnd.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//叧需取出一个操作数，并</span><br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        opnd.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calcu</span>(op, pOpnd)); <span class="hljs-comment">//实施一元计算，结果入栈</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//对于其它（二元）运算符</span><br>                        <span class="hljs-type">float</span> pOpnd2 = opnd.<span class="hljs-built_in">top</span>();<br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> pOpnd1 = opnd.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//取出后、前操作数</span><br>                        opnd.<span class="hljs-built_in">pop</span>();<br>                        opnd.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calcu</span>(pOpnd1, op, pOpnd2)); <span class="hljs-comment">//实施二元计算，结果入栈</span><br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//逢语法错误，并做处理直接退出</span><br>            &#125;<span class="hljs-comment">//switch</span><br>    &#125;<span class="hljs-comment">//while</span><br>    result = opnd.<span class="hljs-built_in">top</span>();<br>    opnd.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//弹出并返回最后的计算结果</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>* RPN = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> S[Opr] = &#123;<span class="hljs-number">0</span>&#125;;<br>    cin &gt;&gt; S;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">evaluate</span>(S,RPN,ans))<br>        cout &lt;&lt; <span class="hljs-string">&quot;Ans = &quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Reverse Polish Notation:\n&quot;</span>;<br>    cout &lt;&lt; RPN;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>算法计算示例:<br>计算给定表达式<code>(0!+1)*2^(3!+4)-(5!-67-(8+9))</code>的值<br>运行结果   <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Result">Ans = 988<br>Reverse Polish Notation:<br>0 ! 1 + 2 3 ! 4 + ^ * 5 ! 67 - 8 9 + - -<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>顺序栈</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex组织文本</title>
    <url>/2022/10/07/Latex%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%84%E7%BB%87%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="一、标点符号"><a href="#一、标点符号" class="headerlink" title="一、标点符号"></a>一、标点符号</h3><h4 id="1-1-引号"><a href="#1-1-引号" class="headerlink" title="1.1 引号"></a>1.1 引号</h4><p><code>Latex</code>使用<code>‘’</code>来表示引号，如果遇到连续使用单引号和双引号的情形，则需要使用<code>\,</code>命令隔开，会产生很小的间距</p>
<h4 id="1-2-符号"><a href="#1-2-符号" class="headerlink" title="1.2 符号-"></a>1.2 符号<code>-</code></h4><ul>
<li>数学减号</li>
<li>单独使用时表示连字符</li>
<li>两个连用时，是<code>en dash</code>，表示数字范围</li>
<li>三个连用时，是<code>em dash</code>，即破折号</li>
</ul>
<p><code>~</code>符号命令：数学模式<script type="math/tex">\sim</script>    </p>
<h4 id="1-3-省略号"><a href="#1-3-省略号" class="headerlink" title="1.3 省略号"></a>1.3 省略号</h4><p>西文省略号: <code>\ldots</code>或者<code>\dots</code>，在句中使用时直接命令，而在句末使用时要把省略号放进数学模式中。<br>中文写作使用全角标点，一般由<code>xsCJK</code>宏包控制，可以使用<code>\punctstyle&#123;&#125;</code>命令修改，<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071546897.png" alt=""></p>
<h4 id="1-4-空格"><a href="#1-4-空格" class="headerlink" title="1.4 空格"></a>1.4 空格</h4><p>以字母命名的宏后面空格会被自动忽略掉，此时可以使用<code>\</code>命令添加<br>或者添加一个空分组<code>&#123;&#125;</code>分隔，或者<code>&#123;\TeX&#125;</code>包裹进来<br><strong>不可打断的空格(带子)</strong><br>用<code>~</code>表示，<code>function ~$f(x)$</code><br>西方文体中，句末标点和缩写标点问题<br><code>Latex</code>默认在大写字母的点看作缩写标记，小写字母后面的点看作句子结束而设置不同的点间隔；但当特殊情况时需要明确指定具体用法，示例:<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">Tinker et al.<span class="hljs-keyword">\ </span>made the double play.  <span class="hljs-comment">% &#x27;\空格&#x27;命令放在&#x27;.&#x27;后直接分隔单词</span><br><br>Tinker et al,made the double play. <span class="hljs-comment">% 一般情况下标点后需加空格</span><br><br><span class="hljs-keyword">\frenchspacing</span>  <span class="hljs-comment">% 禁止标点后的额外间距</span><br>Roman number XII<span class="hljs-keyword">\@</span>. Yes.  <span class="hljs-comment">% &#x27;\@&#x27;命令放在&#x27;.&#x27;前面只处理&#x27;.&#x27;是句子结束点，之后再添加空格表示正常的句号标点</span><br></code></pre></td></tr></table></figure></p>
<h4 id="1-5-幻影空格"><a href="#1-5-幻影空格" class="headerlink" title="1.5 幻影空格"></a>1.5 幻影空格</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-comment">% 幻影空格实际上起到占位作用，接受一个参数，生成与参数内容大小一样的空盒子</span><br><span class="hljs-comment">% 类似的还有\hphantom和\vphantom表示水平竖直方向上的幻影</span><br>MarkStiff<span class="hljs-keyword">\phantom</span>&#123;神奇&#125;速速隐形<br><br>MarkStiff神奇速速显形<br></code></pre></td></tr></table></figure>
<h4 id="1-6-换行"><a href="#1-6-换行" class="headerlink" title="1.6 换行"></a>1.6 换行</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\\</span>[2cm]  <span class="hljs-comment">% 命令直接另起一行，上一行保持原样,可选参数设置换行后增加的额外垂直距离</span><br><span class="hljs-keyword">\linebreak</span> <span class="hljs-comment">% 命令指定一行的断点，上一行仍按完整一行散开对齐</span><br></code></pre></td></tr></table></figure>
<h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><h4 id="2-1-字体族格式命令"><a href="#2-1-字体族格式命令" class="headerlink" title="2.1 字体族格式命令"></a>2.1 字体族格式命令</h4><p>带参数命令主要用于少量字体的更换，三种字体族对应的带参数命令，而声明命令主要用偶遇分组或环境中字体的整体更换.<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textrm</span>&#123;Roman font family&#125;<br>	<span class="hljs-keyword">\textsf</span>&#123;Sans serif font family&#125;<br>	<span class="hljs-keyword">\texttt</span>&#123;Typewriter font family&#125;<br>	<br>声明命令<br>	&#123;<span class="hljs-keyword">\rmfamily</span> Roman font family&#125;<br>	&#123;<span class="hljs-keyword">\sffamily</span> Sans serif font family&#125;<br>	&#123;<span class="hljs-keyword">\ttfamily</span> Typewriter font family&#125;<br></code></pre></td></tr></table></figure><br>效果图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071651052.png" alt=""></p>
<h4 id="2-2-字体形状命令"><a href="#2-2-字体形状命令" class="headerlink" title="2.2 字体形状命令"></a>2.2 字体形状命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textup</span>&#123;Upright shape&#125;  <span class="hljs-comment">% 直立形状</span><br>	<span class="hljs-keyword">\textit</span>&#123;Italic shape&#125; <span class="hljs-comment">% 意大利形状</span><br>	<span class="hljs-keyword">\textsl</span>&#123;Slanted shape&#125; <span class="hljs-comment">% 倾斜形状</span><br>	<span class="hljs-keyword">\textsc</span>&#123;SMALL CAPITALS SHAPE&#125; <span class="hljs-comment">% 小型大写形状</span><br><br>声明命令<br>	&#123;<span class="hljs-keyword">\upshape</span> Upright shape&#125;<br>	&#123;<span class="hljs-keyword">\itshape</span> Italic shape&#125;<br>	&#123;<span class="hljs-keyword">\slshape</span> Slanted shape&#125;<br>	&#123;<span class="hljs-keyword">\scshape</span> SMALL CAPITALS SHAPE&#125;<br></code></pre></td></tr></table></figure>
<p>效果图：<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071650619.png" alt=""><br>倾斜形状一般是对符号直接倾斜产生的，而通常的“斜体”往往指意大利形状，数学公式的字体一般就使用意大利形状</p>
<h4 id="2-3-字体系列命令"><a href="#2-3-字体系列命令" class="headerlink" title="2.3 字体系列命令"></a>2.3 字体系列命令</h4><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">带参数命令<br>	<span class="hljs-keyword">\textmd</span>&#123;Medium series&#125; <span class="hljs-comment">% 中等字体，正文默认使用此系列</span><br>	<span class="hljs-keyword">\textbf</span>&#123;Bold extended series&#125; <span class="hljs-comment">% 加宽加粗</span><br>	<br>声明命令<br>	&#123;<span class="hljs-keyword">\mdseries</span> Medium series&#125; 	<br>	&#123;<span class="hljs-keyword">\bfseries</span> Bold extended series&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-字体坐标"><a href="#2-4-字体坐标" class="headerlink" title="2.4 字体坐标"></a>2.4 字体坐标</h4><p>经上文介绍了字体的三个特征，综合起来构成了确定一种字体的三维坐标：族、形状、系列，不同组合会产生不同的字体效果。<br>具体组合效果图:<br><img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210071702667.png" alt=""><br><strong><em>恢复普通字体</em></strong><br>在复杂的字体环境中，恢复普通字体就显得十分重要了。<br><code>\textnormal&#123;文字&#125; % 带参数命令</code><br><code>&#123;\normalfont 文字&#125; % 声明命令</code><br><strong><em>斜体校正</em></strong><br>在使用斜体声明<code>\itshape、\slshape</code>时，最后一个倾斜的字体会超过右边界，使得间距过近；<br>而用带参数命令<code>\textit、\textsl</code>时，可以自动修正这个距离，也可以手工使用<code>\/</code>命令进行校正。<br><strong><em>禁止校正</em></strong><br>有时对于倾斜校正是不必要的，则应关闭带参数倾斜命令的自动校正功能:<br><code>\textit&#123;M\nocorr&#125;M</code> 通过添加命令<code>\nocorr</code>命令来关闭自动校正    </p>
<h4 id="2-5-中文字体族"><a href="#2-5-中文字体族" class="headerlink" title="2.5 中文字体族"></a>2.5 中文字体族</h4><p>对于中文字体，一般只使用不同的字体族进行区分，选择中文字体族使用<code>\CJKfamily</code>命令<br>在<code>ctex</code>宏包及文档下有一些预定义，默认情况下配置了四种字体族：<br><figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs Latex">&#123;<span class="hljs-keyword">\heiti</span> 这是黑体&#125;<br>&#123;<span class="hljs-keyword">\songti</span> 这是宋体&#125;<br>&#123;<span class="hljs-keyword">\kaishu</span> 这是楷书&#125;<br>&#123;<span class="hljs-keyword">\fangsong</span> 这是仿宋&#125;<br></code></pre></td></tr></table></figure><br><strong><em>组合字体</em></strong><br><code>ctex</code>宏包及文档类也定义了一些组合字体，可以让中文也具备使用粗体和意大利体功能，并且重定义<code>\rmfamily</code>使它同时对中文起作用<br>默认的中文字体是<code>rm</code>，正常字体是宋体，粗体是黑体，意大利体是楷体 </p>
]]></content>
      <categories>
        <category>Latex学习</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>栈进阶数据结构</title>
    <url>/2022/10/08/%E6%A0%88%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一-栈维护最值"><a class="markdownIt-Anchor" href="#一-栈维护最值"></a> 一、栈维护最值</h3>
<p>时间复杂度<code>O(1)</code>；设置三个栈<code>A、B、C</code>，其中<code>A</code>栈存储原始数据，<code>B、C</code>栈分别维护栈中最小值和最大值:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 进栈操作</span><br>A.<span class="hljs-built_in">push</span>(x);<br>B.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(B.<span class="hljs-built_in">top</span>(),x));<br>C.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">max</span>(C.<span class="hljs-built_in">top</span>(),x));<br><span class="hljs-comment">// 出栈操作</span><br>A.<span class="hljs-built_in">pop</span>();<br>B.<span class="hljs-built_in">pop</span>();<br>C.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure>
<h3 id="二-对顶栈"><a class="markdownIt-Anchor" href="#二-对顶栈"></a> 二、对顶栈</h3>
<p>应用思想：始终在序列中间某个指定位置进行修改；<br />
建立两个栈，<code>A</code>栈存储从序列开头到当前位置的这一段子序列，栈<code>B</code>存储当前位置到序列结尾处的这一段子序列，二者都以当前位置那一端作为栈顶。<br />
栈求**_最大前缀和**_时，用一个数组<code>f</code>维护栈<code>A</code>的最大前缀和；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A的栈顶位置下标pA，使用数组模拟栈</span><br><span class="hljs-comment">// sum是A的前缀和数组</span><br>A.<span class="hljs-built_in">push</span>(x);<br>sum[pA]=sum[pA<span class="hljs-number">-1</span>]+A[pA];<br>f[pA] = <span class="hljs-built_in">max</span>(f[pA<span class="hljs-number">-1</span>],sum[pA]);<br></code></pre></td></tr></table></figure>
<h3 id="三-单调栈"><a class="markdownIt-Anchor" href="#三-单调栈"></a> 三、单调栈</h3>
<p>单调栈算法：时间复杂度<code>O(N)</code>，处理问题思想在于**<em>及时排除不可能的选项，保持策略集合的高度有效性和秩序性</em>**<br />
应用：需要维护一个单调的序列并且可以不断从一端插入或删除<br />
典例：<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081928282.png" alt="" /><br />
思路分析:<br />
<img src="http://cdn.jsdelivr.net/gh/Markstiff/BlogImage/img/202210081937079.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 数组模拟栈：往往更快一些</span><br>a[n+<span class="hljs-number">1</span>] = p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// p为栈顶位置，初始为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<br>&#123;<br>	<span class="hljs-keyword">if</span>(a[i] &gt; s[p])&#123; <span class="hljs-comment">// 矩形高度大于栈顶高度时直接进栈</span><br>		s[++p] = a[i];<br>		w[p] = <span class="hljs-number">1</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// 否则依次比较、寻找不高于当前矩形的位置</span><br>		<span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(s[p] &gt; a[i])&#123;<br>			width += w[p];<span class="hljs-comment">// 宽度叠加</span><br>			<span class="hljs-comment">// 这里s[p]是当前栈顶的高度值，ans记录最终的最大值</span><br>			ans = <span class="hljs-built_in">max</span>(ans, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)width*s[p]); <br>			p--;<br>		&#125;<br>		<span class="hljs-comment">// 更新栈，基于当前栈顶位置</span><br>		s[++p] = a[i],w[p] = width + <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
